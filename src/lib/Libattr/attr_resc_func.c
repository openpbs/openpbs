/*
 * Copyright (C) 1994-2016 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *  
 * This file is part of the PBS Professional ("PBS Pro") software.
 * 
 * Open Source License Information:
 *  
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free 
 * Software Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *  
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.
 *  
 * You should have received a copy of the GNU Affero General Public License along 
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *  
 * Commercial License Information: 
 * 
 * The PBS Pro software is licensed under the terms of the GNU Affero General 
 * Public License agreement ("AGPL"), except where a separate commercial license 
 * agreement for PBS Pro version 14 or later has been executed in writing with Altair.
 *  
 * Altair’s dual-license business model allows companies, individuals, and 
 * organizations to create proprietary derivative works of PBS Pro and distribute 
 * them - whether embedded or bundled with other software - under a commercial 
 * license agreement.
 * 
 * Use of Altair’s trademarks, including but not limited to "PBS™", 
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's 
 * trademark licensing policies.
 *
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <assert.h>
#include <ctype.h>
#include <memory.h>
#ifndef NDEBUG
#include <stdio.h>
#endif
#include <stdlib.h>
#include <string.h>
#include <pbs_ifl.h>
#include "pbs_internal.h"
#include "log.h"
#include "list_link.h"
#include "attribute.h"
#include "resource.h"
#include "pbs_error.h"


/**
 * @file	attr_resc_func.c
 * @brief
 * This file contains functions for decoding "nodes" and "select" resources
 *
 * The prototypes are declared in "attribute.h", also see resource.h
 *
 * ----------------------------------------------------------------------------
 * Attribute functions for attributes with value type resource
 * ----------------------------------------------------------------------------
 */


/**
 * @brief
 * 	decode_nodes - decode a node requirement specification,
 *	Check if node requirement specification is syntactically ok,
 *	then call decode_str()
 *
 *	val if of the form:	node_spec[+node_spec...]
 *	where node_spec is:	number | properity | number:properity
 *
 * @param[out] patr - pointer to attribute structure
 * @param[in] name - attribute name 
 * @param[in] rescn - resource name 
 * @param[in] val - attribute value
 * 
 * @return	int
 * @retval	0	success
 * @retval	>0	error
 *
 */

int
decode_nodes(struct attribute *patr, char *name, char *rescn, char *val)
{
	char *pc;

	pc = val;

	if ((pc == NULL) || (*pc == '\0'))  /* effectively unsetting value */
		return (decode_str(patr, name, rescn, val));

	while (1) {
		while (isspace((int)*pc))
			++pc;

		if (! isalnum((int)*pc))
			return (PBSE_BADATVAL);
		if (isdigit((int)*pc)) {
			while (isalnum((int)*++pc)) ;
			if (*pc == '\0')
				break;
			else if ((*pc != '+') && (*pc != ':') && (*pc != '#'))
				return (PBSE_BADATVAL);
		} else if (isalpha((int)*pc)) {
			while (isalnum((int)*++pc) || *pc == '-' || *pc == '.' || *pc == '=' || *pc == '_');
			if (*pc  == '\0')
				break;
			else if ((*pc != '+') && (*pc != ':') && (*pc != '#'))
				return (PBSE_BADATVAL);
		}
		++pc;
	}
	return (decode_str(patr, name, rescn, val));
}


/**
 * @brief
 * 	decode_select - decode a selection specification,
 *	Check if the specification is syntactically ok, then call decode_str()
 *
 *	Spec is of the form:
 *
 * @param[out] patr - pointer to attribute structure
 * @param[in] name - attribute name
 * @param[in] rescn - resource name
 * @param[in] val - attribute value
 *
 * @return      int
 * @retval      0       success
 * @retval      >0      error
 *
 */

int
decode_select(struct attribute *patr, char *name, char *rescn, char *val)
{
	int   new_chunk = 1;
	char *pc;
	char *quoted = NULL;

	if (val == NULL)
		return (PBSE_BADATVAL);
	pc = val;
	/* skip leading white space */
	while (isspace((int)*pc))
		++pc;

	if (*pc == '\0')
		return (PBSE_BADATVAL);

	while (*pc) {

		/* each chunk must start with number or letter */
		if (! isalnum((int)*pc))
			return (PBSE_BADATVAL);

		if (new_chunk && isdigit((int)*pc)) {
			/* if digit, it is chunk multipler */
			while (isdigit((int)*++pc)) ;
			if (*pc == '\0')	/* just number is ok */
				return (decode_str(patr, name, rescn, val));
			else if (*pc == '+') {
				++pc;
				if (*pc == '\0')
					return (PBSE_BADATVAL);
				continue;
			} else if (*pc != ':')
				return (PBSE_BADATVAL);
			++pc;
			/* a colon must be followed by a resource=value */
		}

		/* resource=value pairs */
		new_chunk = 0;

		/* resource first and must start with alpha */
		if (! isalpha((int)*pc))
			return (PBSE_BADATVAL);

		while (isalnum((int)*pc) || *pc == '-' || *pc == '_')
			++pc;
		if (*pc != '=')
			return (PBSE_BADATVAL);

		++pc;	/* what following the '=' */
		if (*pc == '\0')
			return (PBSE_BADATVAL);

		/* next comes the value substring */

		while (*pc) {

			/* is it a quoted substring ? */
			if (*pc == '\'' || *pc == '"') {
				/* quoted substring, goto close quote */
				quoted = pc;
				while (*++pc) {
					if (*pc == *quoted) {
						quoted = NULL;
						break;
					}
				}
				if (quoted != NULL) /* didn't find close */
					return (PBSE_BADATVAL);
				++pc;
				continue;
			}

			if (*pc == '\0') {
				/* valid end of string */
				return (decode_str(patr, name, rescn, val));

			} else if (*pc == ':') {
				/* should start new resource=value */
				++pc;
				if (*pc)
					break;
				else
					return (PBSE_BADATVAL);
			} else if (*pc == '+') {
				/* should start new chunk */
				++pc;
				new_chunk = 1;
				if (*pc)
					break;	/* end of chunk, next */
				else
					return (PBSE_BADATVAL);

			} if  (isprint((int)*pc)) {
				++pc;	/* legal character */

			} else
				return (PBSE_BADATVAL);
		}
	}
	return (decode_str(patr, name, rescn, val));
}
