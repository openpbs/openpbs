/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */

#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <gssapi.h>

#include "rpp.h"
#include "tpp_common.h"
#include "libutil.h"

#include "pbs_gss.h"

pthread_mutex_t gss_lock;

/* the function pointer to the upper layer received packet handler */
int (*tpp_pkt_handler)(int tfd, void *data, int len, void *ctx, void *extra);

/* the function pointer to the upper layer connection close handler */
int (*tpp_close_handler)(int tfd, int error, void *ctx, void *extra);

/* the function pointer to the upper layer connection restore handler */
int (*tpp_post_connect_handler)(int tfd, void *data, void *ctx, void *extra);

/* the function pointer to the upper layer pre packet send handler */
int (*tpp_pkt_presend_handler)(int tfd, tpp_packet_t *pkt, void *extra);

/* the function pointer to the upper layer post packet send handler */
int (*tpp_pkt_postsend_handler)(int tfd, tpp_packet_t *pkt, void *extra);

/* upper layer timer handler */
int (*tpp_timer_handler)(time_t now);

/**
 * @brief
 * 	-tpp_gss_logerror - logs the provided error
 *
 * @param[in] func_name - function name that invokes the error
 * @param[in] msg - error message
 */
void
tpp_gss_logerror(const char *func_name, const char* msg)
{
	tpp_log_func(LOG_ERR, func_name, (char*) msg);
}

/**
 * @brief
 * 	-tpp_gss_logdebug - logs the provided debug message
 *
 * @param[in] func_name - function name that invokes the message
 * @param[in] msg - error message
 */
void
tpp_gss_logdebug(const char *func_name, const char* msg)
{
	tpp_log_func(LOG_DEBUG, func_name, (char*) msg);
}

/**
 * @brief
 * 	-tpp_gss_set_extra_host - allocates the hostname to gss_extra structure.
 *	The hostname is supposed to be the hostname of the GSS server.
 *	For GSS client, the parameter 'hostname' conveys the GSS server hostname
 *	and it is used. For GSS server, the parameter 'hostname' is not used
 *	because it is set to the GSS client hostname.
 *	The server hostname is retrieved by gethostname() in this case.
 *
 * @param[in] extra - gss extra structure as void*
 * @param[in] hostname - hostname
 *
 * @return	int
 * @retval	PBS_GSS_OK on success
 * @retval	!= PBS_GSS_OK on error
 */
int
tpp_gss_set_extra_host(void *extra, char *hostname)
{
	pbs_gss_extra_t *gss_extra = (pbs_gss_extra_t*) extra;
	char *hn;

	if (gss_extra->hostname)
		return PBS_GSS_OK;

	if (gss_extra->role == PBS_GSS_SERVER) {
		if ((hn = malloc(PBS_MAXHOSTNAME + 1)) == NULL) {
			tpp_log_func(LOG_CRIT, __func__, "malloc failure");
			return PBS_GSS_ERR_INTERNAL;
		}
		gethostname(hn, PBS_MAXHOSTNAME + 1);
		gss_extra->hostname = hn;
	} else {
		gss_extra->hostname = strdup(hostname);
		if (gss_extra->hostname == NULL) {
			tpp_log_func(LOG_CRIT, __func__, "malloc failure");
			return PBS_GSS_ERR_INTERNAL;
		}
	}

	return PBS_GSS_OK;
}


/**
 * @brief
 *	Log GSS-API messages associated with maj_stat or min_stat
 *
 * @param[in] m - error message followed by GSS maj or min message
 * @param[in] code - gss error code
 * @param[in] type - type of gss error code
 */
static void
tpp_log_status_1(const char *m, OM_uint32 code, int type)
{
	OM_uint32 min_stat;
	gss_buffer_desc msg;
	OM_uint32 msg_ctx;
	msg_ctx = 0;

	do {
		gss_display_status(&min_stat, code, type, GSS_C_NULL_OID, &msg_ctx, &msg);
		snprintf(log_buffer, LOG_BUF_SIZE, "%s : %.*s\n", m, (int)msg.length, (char *)msg.value);
		tpp_log_func(LOG_CRIT, "TPP GSS", log_buffer);
		(void) gss_release_buffer(&min_stat, &msg);
	} while (msg_ctx != 0);
}

/**
 * @brief
 *	The GSS-API messages associated with maj_stat and min_stat are
 *	logged, each preceeded by "GSS-API error <msg>: ".
 *
 * @param[in] msg - a error string to be displayed with the message
 * @param[in] maj_stat - the GSS-API major status code
 * @param[in] min_stat - the GSS-API minor status code
 */
void
tpp_gss_log_status(const char *msg, OM_uint32 maj_stat, OM_uint32 min_stat)
{
	tpp_log_status_1(msg, maj_stat, GSS_C_GSS_CODE);
	tpp_log_status_1(msg, min_stat, GSS_C_MECH_CODE);
}

/**
 * @brief
 * 	-tpp_gss_send_ctx_token - assemble gss context token and sends the token
 *	via tpp_transport_vsend
 *
 * @param[in] fd - file descriptor
 * @param[in] data - token string data
 * @param[in] len - length of data
 *
 * @return	int
 * @retval	PBS_GSS_OK 	on success
 * @retval	!= PBS_GSS_OK	on error
 *
 */
static int
tpp_gss_send_ctx_token(int tfd, void *data, int len)
{
	tpp_chunk_t chunks[1];
	char *tosend;
	
	tosend = malloc(len + 1);
	if (tosend == NULL) {
		tpp_log_func(LOG_CRIT, __func__, "malloc failure");
		return PBS_GSS_ERR_INTERNAL;
	}
	tosend[0] = (char)TPP_GSS_CTX;
	memcpy(tosend + 1, data, len);

	chunks[0].data = tosend;
	chunks[0].len = len + 1;

	if (tpp_transport_vsend(tfd, chunks, 1) != 0) {
		snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "tpp_transport_vsend failed, err=%d", errno);
		tpp_log_func(LOG_CRIT, __func__, tpp_get_logbuf());
		free(tosend);
		free(data);
		return PBS_GSS_ERR_SENDTOKEN;
	}

	free(tosend);
	free(data);
	return PBS_GSS_OK;
}

/**
 * @brief
 *	The pre-send handler registered with the IO thread. If the GSS context
 *	has been established then the paket is wrapped.
 *
 * @param[in] tfd - The actual IO connection on which data was about to be
 *			sent (unused)
 * @param[in] pkt - The data packet that is about to be sent
 * @param[in] extra - The structure with GSS data
 *
 * @retval 0 - Success
 * @retval -1 - Failure
 *
 */
static int
gss_pkt_presend_handler(int tfd, tpp_packet_t *pkt, void *extra)
{
	pbs_gss_extra_t *gss_extra = (pbs_gss_extra_t*)extra;
	char *data_out = NULL;
	int len_out = 0;
	int totpktlen = 0;
	int rc;
	int ntotlen;
	char *tmpdata;

	/* never wrap handshake */
	if ((char)(*(pkt->data + sizeof(int))) == (char)TPP_GSS_CTX)
		return 0;

	if (tpp_pkt_presend_handler)
		if ((rc = tpp_pkt_presend_handler(tfd, pkt, extra)))
			return rc;

	/* if presend handler is called from handle_disconnect() gss_extra is NULL
	 * and this is just a sending simulation. No gss needed. */
	if (gss_extra == NULL)
		return 0;

	gss_extra->cleartext = pkt->data;
	gss_extra->cleartext_len = pkt->len;

	if (gss_extra->ready) {
		if (pbs_gss_wrap(gss_extra, pkt->data, pkt->len, &data_out, &len_out) != PBS_GSS_OK)
			return -1;

		totpktlen = len_out + 1 + sizeof(int); /* + sizeof(int) for ntotlen and +1 for TPP_GSS */
		tmpdata = malloc(totpktlen);
		if (tmpdata != NULL) {
			pkt->data = tmpdata;
		} else {
			tpp_log_func(LOG_CRIT, __func__, "malloc failure");
			return -1;
		}

		pkt->pos = pkt->data;

		ntotlen = htonl(len_out + 1);
		memcpy(pkt->pos, &ntotlen, sizeof(int));
		pkt->pos = pkt->pos + sizeof(int);

		*pkt->pos = (char)TPP_GSS_WRAP;
		pkt->pos++;
		memcpy(pkt->pos, data_out, len_out);

		pkt->pos = pkt->data;
		pkt->len = totpktlen;

		free(data_out);
		data_out = NULL;
	}


	return 0;
}

/**
 * @brief
 *	The post-send handler registered with the IO thread. If pkt is wrapped
 *	then revert data with cleartext for the postsend_handler of the lower layer
 *
 *
 * @param[in] tfd - The actual IO connection on which data was sent (unused)
 * @param[in] pkt - The data packet that is sent out by the IO thrd
 * @param[in] extra - The structure with GSS data
 *
 * @retval 0 - Success
 * @retval -1 - Failure
 */
static int
gss_pkt_postsend_handler(int tfd, tpp_packet_t *pkt, void *extra)
{
	pbs_gss_extra_t *gss_extra = (pbs_gss_extra_t*)extra;

	/* if postsend handler is called from handle_disconnect() gss_extra is NULL
	 * and this is just a sending simulation. No gss needed. */
	if (gss_extra) {
		if ((char)(*(pkt->data + sizeof(int))) == (char)TPP_GSS_CTX) {
			tpp_free_pkt(pkt);
			return 0;
		}

		if ((char)(*(pkt->data + sizeof(int))) == (char)TPP_GSS_WRAP) {
			free(pkt->data);

			/* recover saved cleartext */
			pkt->data = gss_extra->cleartext;
			pkt->len = gss_extra->cleartext_len;

			pkt->pos = pkt->data;
		}
	}

	if (tpp_pkt_postsend_handler)
		return tpp_pkt_postsend_handler(tfd, pkt, extra);

	tpp_free_pkt(pkt);
	return 0;
}

/**
 * @brief
 *	The received packet handler registered with the IO thread. The packet
 *	is either GSS context or wrapped data. It reads the type of packet and
 *	for GSS context, the GSS handshake is performed. For wrapped data, the
 *	data are unwrapped and regular pkt_handler is called with this data.
 *
 * @param[in] tfd - The actual IO connection on which data was about to be
 *			sent (unused)
 * @param[in] data - The pointer to the data that arrived
 * @param[in] len  - Length of the arrived data
 * @param[in] ctx - The context (prior associated, if any) with the IO thread
 *		    (unused at the leaf)
 * @param[in] extra - The structure with GSS data
 *
 * @retval 0 - Success
 * @retval -1 - Failure
 */
static int
gss_pkt_handler(int tfd, void *data, int len, void *ctx, void *extra)
{
	enum TPP_MSG_TYPES type;
	pbs_gss_extra_t *gss_extra = (pbs_gss_extra_t*) extra;
	char *data_out = NULL;
	int len_out = 0;
	int rc;

	if (gss_extra == NULL) {
		gss_extra = pbs_gss_alloc_gss_extra();
		gss_extra->role = PBS_GSS_SERVER;
		tpp_transport_set_conn_extra(tfd, gss_extra);
	}

	type = *((unsigned char *) data);
	if(type >= TPP_LAST_MSG) {
		snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "unknown message type");
		tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());

		return -1;
	}
	
	switch (type) {
		case TPP_GSS_CTX:
			if (gss_extra->gssctx_established) {
				snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "GSS context already established");
				tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());

				return -1;
			}

			tpp_lock(&gss_lock);
			rc = pbs_gss_establish_context(gss_extra, gss_extra->hostname, (char*)(data + 1), len - 1, &data_out, &len_out);
			tpp_unlock(&gss_lock);

			if (rc != PBS_GSS_OK) {
				snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "Failed to establish GSS context");
				tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());

				return -1;
			}

			if (len_out > 0) {
				if (tpp_gss_send_ctx_token(tfd, data_out, len_out) != PBS_GSS_OK) {
					snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "Failed to send GSS context token");
					tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());

					return -1;
				}
			}

			if (gss_extra->gssctx_established) {
				gss_extra->ready = 1;

				if (gss_extra->role == PBS_GSS_SERVER) {
					snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "Entered encrypted communication with client %s", gss_extra->clientname);
					tpp_log_func(LOG_DEBUG, __func__, tpp_get_logbuf());
				}

				if (gss_extra->role == PBS_GSS_CLIENT) {
					snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "Entered encrypted communication with server %s", gss_extra->hostname);
					tpp_log_func(LOG_DEBUG, __func__, tpp_get_logbuf());
				}
			}

			if (gss_extra->ready && gss_extra->role == PBS_GSS_CLIENT)
				tpp_post_connect_handler(tfd, NULL, ctx, extra);

			break;

		case TPP_GSS_WRAP:
			if (gss_extra->ready == 0) {
				snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "wrapped data ready but GSS layer not ready");
				tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());

				return -1;
			}

			if (gss_extra->confidential == 0) {
				snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "wrapped data ready but confidentiality not ensured");
				tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());

				return -1;
			}

			if (pbs_gss_unwrap(gss_extra, data + 1, len -1, &data_out, &len_out) != PBS_GSS_OK) {/* +/- 1 for TPP_GSS_WRAP */
				snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "unwrapping data error");
				tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());

				return -1;
			}

			rc = tpp_pkt_handler(tfd, data_out + sizeof(int), len_out - sizeof(int), ctx, extra);

			free(data_out);

			return rc;
			break;
		default:
			return -1;
	}

	return 0;
}

/**
 * @brief
 *	The connection drop (close) handler registered with the IO thread.
 *	The GSS structures are freed here and regular close_handler is called.
 *
 *
 * @param[in] tfd - The actual IO connection on which data was about to be
 *			sent (unused)
 * @param[in] c - context associated with the IO thread (unused here)
 * @param[in] extra - The structure with GSS data
 *
 */
static int
gss_close_handler(int tfd, int error, void *c, void *extra)
{
	pbs_gss_free_gss_extra((pbs_gss_extra_t*)extra);

	return tpp_close_handler(tfd, error, c, extra);
}

/**
 * @brief
 *	The post connect handler. This is the client part of the GSS handshake.
 *	The GSS handshake is initiated here and first GSS context token is sent.
 *
 *
 * @param[in] tfd - The actual IO connection on which data was about to be
 *			sent (unused)
 * @param[in] data - Any data the IO thread might want to pass to this function.
 *		     (unused)
 * @param[in] c - Context associated with this connection, points us to the
 *                router being connected to
 * @param[in] extra - The structure with GSS data
 *
 * @return Error code
 * @retval 0 - Success
 * @retval -1 - Failure
 *
 */
static int
gss_post_connect_handler(int tfd, void *data, void *c, void *extra)
{
	pbs_gss_extra_t *gss_extra = (pbs_gss_extra_t*) extra;
	char *data_out = NULL;
	int len_out = 0;
	int rc;

	if (gss_extra == NULL) {
		gss_extra = pbs_gss_alloc_gss_extra();
		gss_extra->role = PBS_GSS_CLIENT;
		gss_extra->init_client_ccache = 1;
		tpp_transport_set_conn_extra(tfd, gss_extra);
	}

	tpp_lock(&gss_lock);
	rc = pbs_gss_establish_context(gss_extra, gss_extra->hostname, NULL, 0, &data_out, &len_out);
	tpp_unlock(&gss_lock);

	if (rc != PBS_GSS_OK) {
		snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "Failed to establish GSS context");
		tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());
		return -1;
	}

	if (len_out > 0)
		if (tpp_gss_send_ctx_token(tfd, data_out, len_out) != PBS_GSS_OK) {
			snprintf(tpp_get_logbuf(), TPP_LOGBUF_SZ, "Failed to send GSS context token");
			tpp_log_func(LOG_ERR, __func__, tpp_get_logbuf());
			return -1;
		}
	return 0;
}

/**
 * @brief
 *	The timer handler function registered with the IO thread. Not used in GSS.
 *	just a pass to lower layer.
 *
 * @retval  - Time of next event expriry
 *
 */
static int
gss_timer_handler(time_t now)
{
	return tpp_timer_handler(now);
}


/**
 * @brief
 *	Function to register the handler functions and it initializes gss_lock.
 *
 * @param[in] pkt_presend_handler  - function ptr to presend handler
 * @param[in] pkt_postsend_handler - function ptr to postsend handler
 * @param[in] pkt_handler          - function ptr to pkt recvd handler
 * @param[in] close_handler        - function ptr to net close handler
 * @param[in] post_connect_handler - function ptr to post_connect_handler
 * @param[in] timer_handler        - function ptr called periodically
 *
 */
void
gss_transport_set_handlers(int (*pkt_presend_handler)(int phy_con, tpp_packet_t *pkt, void *extra),
	int (*pkt_postsend_handler)(int phy_con, tpp_packet_t *pkt, void *extra),
	int (*pkt_handler)(int, void *data, int len, void *, void *extra),
	int (*close_handler)(int, int, void *, void *extra),
	int (*post_connect_handler)(int sd, void *data, void *ctx, void *extra),
	int (*timer_handler)(time_t now))
{
	tpp_pkt_handler = pkt_handler;
	tpp_close_handler = close_handler;
	tpp_post_connect_handler = post_connect_handler;
	tpp_pkt_postsend_handler = pkt_postsend_handler;
	tpp_pkt_presend_handler = pkt_presend_handler;
	tpp_timer_handler = timer_handler;

	tpp_transport_set_handlers(gss_pkt_presend_handler, /* called before sending pkt */
		gss_pkt_postsend_handler, /* called after sending a packet */
		gss_pkt_handler, /* called when a packet arrives */
		gss_close_handler, /* called when a connection closes */
		gss_post_connect_handler, /* called when connection restores */
		gss_timer_handler /* called after amt of time from previous handler */
		);

	pbs_gss_set_log_handlers(tpp_gss_log_status,
		tpp_gss_logerror,
		tpp_gss_logdebug);

	tpp_init_lock(&gss_lock);
}

#endif
