/*
 * Copyright (C) 1994-2021 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of both the OpenPBS software ("OpenPBS")
 * and the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * OpenPBS is free software. You can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * OpenPBS is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * PBS Pro is commercially licensed software that shares a common core with
 * the OpenPBS software.  For a copy of the commercial license terms and
 * conditions, go to: (http://www.pbspro.com/agreement.html) or contact the
 * Altair Legal Department.
 *
 * Altair's dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of OpenPBS and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair's trademarks, including but not limited to "PBS™",
 * "OpenPBS®", "PBS Professional®", and "PBS Pro™" and Altair's logos is
 * subject to Altair's trademark licensing policies.
 */



/**
 * @file	enc_reply.c
 * @brief
 * encode_DIS_reply() - encode a Batch Protocol Reply Structure
 *
 * 	batch_reply structure defined in libpbs.h, it must be allocated
 *	by the caller.
 */

#include <pbs_config.h>   /* the master config generated by configure */

#include "libpbs.h"
#include "list_link.h"
#include "attribute.h"
#include "dis.h"
#include "net_connect.h"

int encode_DIS_svrattrl(int sock, svrattrl *psattl);


/**
 * @brief-
 *      encode a Batch Protocol Reply Structure for a Command
 *
 * Note: batch_reply structure defined in libpbs.h, it must be allocated
 *       by the caller.
 *
 * @param[in] sock - socket descriptor
 * @param[in] reply - pointer to batch_reply structure
 *
 * @return      int
 * @retval      -1      error
 * @retval      0       Success
 *
 */

static int
encode_DIS_reply_inner(int sock, struct batch_reply *reply)
{
	int ct;
	int i;
	struct brp_select *psel;
	struct brp_status *pstat;
	struct batch_deljob_status *pdelstat;
	svrattrl *psvrl;
	preempt_job_info *ppj;

	int rc;

	/* next encode code, auxcode and choice (union type identifier) */

	if ((rc = diswsi(sock, reply->brp_code)) ||
	    (rc = diswsi(sock, reply->brp_auxcode)) ||
	    (rc = diswui(sock, reply->brp_choice)) ||
	    (rc = diswui(sock, reply->brp_is_part)))
		return rc;

	switch (reply->brp_choice) {

		case BATCH_REPLY_CHOICE_NULL:
			break; /* no more to do */

		case BATCH_REPLY_CHOICE_Queue:
		case BATCH_REPLY_CHOICE_RdytoCom:
		case BATCH_REPLY_CHOICE_Commit:
			if ((rc = diswst(sock, reply->brp_un.brp_jid)) != 0)
				return (rc);
			break;

		case BATCH_REPLY_CHOICE_Select:

			/* have to send count of number of strings first */

			if ((rc = diswui(sock, reply->brp_count)) != 0)
				return rc;

			psel = reply->brp_un.brp_select;
			while (psel) {
				/* now encode each string */
				if ((rc = diswst(sock, psel->brp_jobid)) != 0)
					return rc;
				psel = psel->brp_next;
			}
			break;

		case BATCH_REPLY_CHOICE_Status:

			/* encode "server version" of status structure.
			 *
			 * Server always uses svrattrl form.
			 * Commands decode into their form.
			 */

			if ((rc = diswui(sock, reply->brp_count)) != 0)
				return rc;
			pstat = (struct brp_status *) GET_NEXT(reply->brp_un.brp_status);
			while (pstat) {
				if ((rc = diswui(sock, pstat->brp_objtype)) || (rc = diswst(sock, pstat->brp_objname)))
					return rc;

				psvrl = (svrattrl *) GET_NEXT(pstat->brp_attr);
				if ((rc = encode_DIS_svrattrl(sock, psvrl)) != 0)
					return rc;
				pstat = (struct brp_status *) GET_NEXT(pstat->brp_stlink);
			}
			break;

		case BATCH_REPLY_CHOICE_Delete:

			/* encode "server version" of status structure.
			 *
			 * Server always uses svrattrl form.
			 * Commands decode into their form.
			 */

			if ((rc = diswui(sock, reply->brp_count)) != 0)
				return rc;
			pdelstat = reply->brp_un.brp_deletejoblist.brp_delstatc;
			while (pdelstat) {
				if ((rc = diswst(sock, pdelstat->name)) || (rc = diswui(sock, pdelstat->code)))
					return rc;

				pdelstat = pdelstat->next;
			}
			break;

		case BATCH_REPLY_CHOICE_Text:

			/* text reply */

			rc = diswcs(sock, reply->brp_un.brp_txt.brp_str, (size_t) reply->brp_un.brp_txt.brp_txtlen);
			if (rc)
				return rc;
			break;

		case BATCH_REPLY_CHOICE_Locate:

			/* Locate Job Reply */

			if ((rc = diswst(sock, reply->brp_un.brp_locate)) != 0)
				return rc;
			break;

		case BATCH_REPLY_CHOICE_RescQuery:

			/* Query Resources Reply */

			ct = reply->brp_un.brp_rescq.brq_number;
			if ((rc = diswui(sock, ct)) != 0)
				return rc;
			for (i = 0; (i < ct) && (rc == 0); ++i) {
				rc = diswui(sock, *(reply->brp_un.brp_rescq.brq_avail + i));
			}
			if (rc)
				return rc;
			for (i = 0; (i < ct) && (rc == 0); ++i) {
				rc = diswui(sock, *(reply->brp_un.brp_rescq.brq_alloc + i));
			}
			if (rc)
				return rc;
			for (i = 0; (i < ct) && (rc == 0); ++i) {
				rc = diswui(sock, *(reply->brp_un.brp_rescq.brq_resvd + i));
			}
			if (rc)
				return rc;
			for (i = 0; (i < ct) && (rc == 0); ++i) {
				rc = diswui(sock, *(reply->brp_un.brp_rescq.brq_down + i));
			}
			if (rc)
				return rc;
			break;

		case BATCH_REPLY_CHOICE_PreemptJobs:

			/* Preempt Jobs Reply */
			ct = reply->brp_un.brp_preempt_jobs.count;
			ppj = reply->brp_un.brp_preempt_jobs.ppj_list;

			if ((rc = diswui(sock, ct)) != 0)
				return rc;

			for (i = 0; i < ct; i++) {
				if (((rc = diswst(sock, ppj[i].job_id)) != 0) || ((rc = diswst(sock, ppj[i].order)) != 0))
					return rc;
			}

			break;

		default:
			return -1;
	}

	return 0;
}

int
encode_DIS_reply(int sock, struct batch_reply *reply)
{
	int rc;
	/* first encode "header" consisting of protocol type and version */

	if ((rc = diswui(sock, PBS_BATCH_PROT_TYPE))   ||
		(rc = diswui(sock, PBS_BATCH_PROT_VER)))
			return rc;

	return (encode_DIS_reply_inner(sock, reply));
}

int
encode_DIS_replyTPP(int sock, char *tppcmd_msgid, struct batch_reply *reply)
{
	int rc;

	/* first encode "header" consisting of protocol type and version */
	if (reply->brp_choice == BATCH_REPLY_CHOICE_Status) {
		if ((rc = ps_compose(sock, PS_STAT_RPLY)) != DIS_SUCCESS)
			return rc;
		return encode_DIS_reply(sock, reply);
	} else {
		if ((rc = is_compose(sock, IS_CMD_REPLY)) != DIS_SUCCESS)
		return rc;

		/* 
		* for IS_CMD_REPLY, also send across the tppcmd_msgid, so that
		* server can match the reply with the request it had sent earlier
		*/
		if ((rc = diswst(sock, tppcmd_msgid)) != DIS_SUCCESS)
			return rc;
	}

	return (encode_DIS_reply_inner(sock, reply));
}
