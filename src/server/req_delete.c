/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of both the OpenPBS software ("OpenPBS")
 * and the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * OpenPBS is free software. You can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * OpenPBS is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * PBS Pro is commercially licensed software that shares a common core with
 * the OpenPBS software.  For a copy of the commercial license terms and
 * conditions, go to: (http://www.pbspro.com/agreement.html) or contact the
 * Altair Legal Department.
 *
 * Altair's dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of OpenPBS and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair's trademarks, including but not limited to "PBS™",
 * "OpenPBS®", "PBS Professional®", and "PBS Pro™" and Altair's logos is
 * subject to Altair's trademark licensing policies.
 */

/**
 * @file	req_delete.c
 *
 * Functions relating to the Delete Job Batch Requests.
 *
 * Included funtions are:
 *	remove_stagein()
 *	acct_del_write()
 *	check_deletehistoryjob()
 *	issue_delete()
 *	req_deletejob()
 *	req_deletejob2()
 *	req_deleteReservation()
 *	post_delete_route()
 *	post_deljobfromresv_req()
 *
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <sys/types.h>
#include <signal.h>
#include "portability.h"
#include "libpbs.h"
#include "server_limits.h"
#include "list_link.h"
#include "work_task.h"
#include "attribute.h"
#include "server.h"
#include "credential.h"
#include "batch_request.h"
#include "resv_node.h"
#include "queue.h"
#include "hook.h"

#include "job.h"
#include "reservation.h"
#include "pbs_error.h"
#include "acct.h"
#include "log.h"
#include "pbs_nodes.h"
#include "svrfunc.h"


/* Global Data Items: */

extern char *msg_deletejob;
extern char *msg_delrunjobsig;
extern char *msg_manager;
extern char *msg_noDeljobfromResv;
extern char *msg_deleteresv;
extern char *msg_deleteresvJ;
extern char *msg_job_history_delete;
extern char *msg_job_history_notset;
extern char *msg_also_deleted_job_history;
extern char *msg_err_malloc;
extern struct server server;
extern time_t time_now;

/* External functions */

extern int issue_to_svr(char *, struct batch_request *, void (*func)(struct work_task *));
extern struct batch_request *cpy_stage(struct batch_request *, job *, enum job_atr, int);
extern resc_resv  *chk_rescResv_request(char *, struct batch_request *);

/* Private Functions in this file */

static void post_delete_route(struct work_task *);
static void post_delete_mom1(struct work_task *);
static void post_deljobfromresv_req(struct work_task *);
static void req_deletejob2(struct batch_request *preq, job *pjob);
int update_deletejob_stat(char *jid, struct batch_request *preq, int errcode);

/* Private Data Items */

static char *sigk  = "SIGKILL";
static char *sigt  = "SIGTERM";
static char *sigtj =  SIG_TermJob;
static char *acct_fmt = "requestor=%s@%s";
static int qdel_mail = 1; /* true: sending mail */


/**
 * @brief
 * 		remove_stagein() - request that mom delete staged-in files for a job
 *		used when the job is to be purged after files have been staged in
 *
 * @param[in,out]	pjob	- job
 */

void
remove_stagein(pjob)
job *pjob;
{
	struct batch_request *preq = 0;

	preq = cpy_stage(preq, pjob, JOB_ATR_stagein, 0);

	if (preq) { /* have files to delete		*/

		/* change the request type from copy to delete  */

		preq->rq_type = PBS_BATCH_DelFiles;
		preq->rq_extra = NULL;
		if (relay_to_mom(pjob, preq, release_req) == 0) {
			pjob->ji_qs.ji_svrflags &= ~JOB_SVFLG_StagedIn;
		} else {
			/* log that we were unable to remove the files */
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_FILE,
				LOG_NOTICE, pjob->ji_qs.ji_jobid,
				"unable to remove staged-in files for job");
			free_br(preq);
		}
	}
}

/**
 * @brief
 * 		acct_del_write - write the Job Deleted account record
 *
 * @param[in]	jid	- Job Id.
 * @param[in]	pjob	- Job structure.
 * @param[in]	preq - batch_request
 * @param[in]	nomail	- do not send mail to the job owner if enabled.
 */

static void
acct_del_write(char *jid, job *pjob, struct batch_request *preq, int nomail)
{
	sprintf(log_buffer, acct_fmt, preq->rq_user, preq->rq_host);
	write_account_record(PBS_ACCT_DEL, jid, log_buffer);

	sprintf(log_buffer, msg_manager, msg_deletejob,
		preq->rq_user, preq->rq_host);
	log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO, jid, log_buffer);

	if (pjob != NULL) {
		int jt = is_job_array(jid);

		switch (jt) {
			case IS_ARRAY_NO: /* not a subjob */
			case IS_ARRAY_ArrayJob:

				/* if block set, send word */
				check_block(pjob, log_buffer);
		}

		if (preq->rq_parentbr == NULL && nomail == 0 &&
			svr_chk_owner(preq, pjob) != 0 &&
			qdel_mail != 0) {
			svr_mailowner_id(jid, pjob,
				MAIL_OTHER, MAIL_FORCE, log_buffer);
		}
	}
}

/**
 * @Brief
 *		If the job is a history job then purge its history
 *		If the job is a non-history job then it must be terminated before purging its history. Will be
 *		done by req_deletejob()
 *
 * @param[in]	preq	- Batch request structure.
 *
 * @return	int
 * @retval	TRUE	- Job history  has been purged
 * @retval	FALSE	- Job is not a history job
 */
int
check_deletehistoryjob(struct batch_request * preq, char * jid)
{
	job *histpjob;
	job *pjob;
	int historyjob;
	int histerr;
	int t;
	struct batch_reply *preply = &preq->rq_reply;

	/*
	 * If the array subjob or range of subjobs are in a history state then
	 * reject the request as we cant delete history of array subjobs
	 */
	t = is_job_array(jid);
	if ((t == IS_ARRAY_Single) || (t == IS_ARRAY_Range)) {
		pjob = find_arrayparent(jid);
		if ((histerr = svr_chk_histjob(pjob))) {
			update_deletejob_stat(jid, preq, PBSE_NOHISTARRAYSUBJOB);
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
				req_reject(PBSE_NOHISTARRAYSUBJOB, 0, preq);
			return TRUE;
		} else {
			/*
			 * Job is in a Non Finished state . It must be terminated and then its history
			 *  should be purged .
			 */
			return FALSE;
		}
	}

	histpjob = find_job(jid);

	historyjob = svr_chk_histjob(histpjob);
	if (historyjob == PBSE_HISTJOBID) {
		snprintf(log_buffer, sizeof(log_buffer),
			msg_job_history_delete, preq->rq_user,
			preq->rq_host);
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
			jid,
			log_buffer);

		/* Issue history job delete request to remote server if job is moved. */
		if (check_job_state(histpjob, JOB_STATE_LTR_MOVED))
			issue_delete(histpjob);

		if (histpjob->ji_qs.ji_svrflags & JOB_SVFLG_ArrayJob) {
			if (histpjob->ji_ajinfo) {
				int i;
				for (i = histpjob->ji_ajinfo->tkm_start; i <= histpjob->ji_ajinfo->tkm_end; i += histpjob->ji_ajinfo->tkm_step) {
					job *psjob = get_subjob_and_state(histpjob, i, NULL, NULL);
					if (psjob) {
						log_eventf(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
							psjob->ji_qs.ji_jobid,
							msg_job_history_delete, preq->rq_user,
							preq->rq_host);
						job_purge(psjob);
					}
				}
			}
		}

		job_purge(histpjob);

		update_deletejob_stat(jid, preq, PBSE_HISTJOBDELETED);
		if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
			reply_send(preq);
		return TRUE;
	} else {
		/*
		 *  Job is in a Non Finished state . It must be terminated and then its history
		 * should be purged .
		 */
		return FALSE;
	}
}

/**
 * @Brief
 *		Issue PBS_BATCH_DeleteJob request to remote server.
 *
 * @param[in]	pjob - Job structure.
 */
void
issue_delete(job *pjob)
{
	struct batch_request   *preq;
	char rmt_server[PBS_MAXSERVERNAME + 1] = {'\0'};
	char *at = NULL;

	if (pjob == NULL)
		return;

	if ((at = strchr(get_jattr_str(pjob, JOB_ATR_in_queue), (int)'@')) == NULL)
		return;

	snprintf(rmt_server, sizeof(rmt_server), "%s", at + 1);

	preq = alloc_br(PBS_BATCH_DeleteJob);
	if (preq == NULL)
		return;

	pbs_strncpy(preq->rq_ind.rq_delete.rq_objname, pjob->ji_qs.ji_jobid, sizeof(preq->rq_ind.rq_delete.rq_objname));
	preq->rq_extend = malloc(strlen(DELETEHISTORY) + 1);
	if (preq->rq_extend == NULL) {
		log_err(errno, "issue_delete", msg_err_malloc);
		return;
	}

	strncpy(preq->rq_extend, DELETEHISTORY, strlen(DELETEHISTORY) + 1);

	issue_to_svr(rmt_server, preq, release_req);
}

/**
 * @Brief
 *		decrement entity usage for a single un-instantiated subjob
 *
 * @param[in]	parent - pointer to parent Job structure.
 */
static void
decr_single_subjob_usage(job *parent)
{
	parent->ji_qs.ji_svrflags &= ~JOB_SVFLG_ArrayJob; /* small hack to decrement usage for a single un-instantiated subjob */
	account_entity_limit_usages(parent, NULL, NULL, DECR, ETLIM_ACC_ALL); /* for server limit */
	account_entity_limit_usages(parent, parent->ji_qhdr, NULL, DECR, ETLIM_ACC_ALL); /* for queue limit */
	parent->ji_qs.ji_svrflags |= JOB_SVFLG_ArrayJob; /* setting arrayjob flag back */
}


int update_deletejob_stat(char *jid, struct batch_request *preq, int errcode)
{
	struct batch_deljob_status *pdelstat;
	struct batch_reply *preply = &preq->rq_reply;

	preply->brp_un.brp_deletejoblist.tot_rpys++;

	if (preq->rq_type != PBS_BATCH_DeleteJobList)
		return 0;

	/* allocate reply structure and fill in jobid and status portion */
	pdelstat = (struct batch_deljob_status *)malloc(sizeof(struct batch_deljob_status));
	if (pdelstat == NULL)
		return (PBSE_SYSTEM);

	pdelstat->name = strdup(jid);
	pdelstat->code = errcode;
	pdelstat->next = preply->brp_un.brp_deletejoblist.brp_delstatc;
	preply->brp_un.brp_deletejoblist.brp_delstatc = pdelstat;

	preq->rq_reply.brp_count++;

	return 0;
}

/**
 * @brief
 * 		req_deletejob - service the Delete Job Request
 *
 *		This request deletes a job.
 *
 * @param[in]	preq	- Job Request
 */

void
req_deletejob(struct batch_request *preq)
{
	int forcedel = 0;
	int i;
	char jid[PBS_MAXSVRJOBID + 1];
	int jt; /* job type */
	char *pc;
	job *pjob;
	job *parent;
	char *range;
	char sjst; /* subjob state */
	int rc = 0;
	int delhist = 0;
	int err = PBSE_NONE;
	char **jobids;
	int count;
	int j;
	struct batch_reply *preply = &preq->rq_reply;
	preply->brp_un.brp_deletejoblist.brp_delstatc = NULL;
	preply->brp_count = 0;

	if (preq->rq_type == PBS_BATCH_DeleteJobList) {
		preply->brp_choice = BATCH_REPLY_CHOICE_Delete;
		jobids = preq->rq_ind.rq_deletejoblist.rq_jobslist;
		count = preq->rq_ind.rq_deletejoblist.rq_count;
	} else {
		jobids = break_comma_list(preq->rq_ind.rq_delete.rq_objname);
		count = 1;
	}

	preply->brp_un.brp_deletejoblist.tot_jobs = count;
	preply->brp_un.brp_deletejoblist.tot_arr_jobs = 0;
	preply->brp_un.brp_deletejoblist.tot_rpys = 0;

	if (preq->rq_extend && strstr(preq->rq_extend, DELETEHISTORY))
		delhist = 1;
	if (preq->rq_extend && strstr(preq->rq_extend, FORCE))
		forcedel = 1;
	/* with nomail , nomail_force , nomail_deletehist or nomailforce_deletehist options are set
	 *  no mail is sent
	 */
	if (preq->rq_extend && strstr(preq->rq_extend, NOMAIL))
		qdel_mail = 0;
	else
		qdel_mail = 1;

	for (j = 0; j < count; j++) {
		snprintf(jid, sizeof(jid), "%s", jobids[j]);
		parent = chk_job_request(jid, preq, &jt, &err);
		if (parent == NULL) {
			pjob = find_job(jid);
			if (pjob != NULL && pjob->ji_pmt_preq != NULL)
				reply_preempt_jobs_request(err, PREEMPT_METHOD_DELETE, pjob);
			update_deletejob_stat(jid, preq, err);
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs) {
				if (preq->rq_type == PBS_BATCH_DeleteJobList)
					req_reject(err, 0, preq);  /* note, req_reject is not called for delete job request 2 */
				return;
			} else
				continue;
		}

		if (delhist) {
			rc = check_deletehistoryjob(preq, jid);
			if (rc == TRUE)
				continue;
		}


		if (jt == IS_ARRAY_NO) {

			/* just a regular job, pass it on down the line and be done
			 * If the request is to purge the history of the job then set ji_deletehistory to 1
			 */
			if (delhist)
				parent->ji_deletehistory = 1;
			req_deletejob2(preq, parent);
			continue;

		} else if (jt == IS_ARRAY_Single) {
			/* single subjob, if running do full delete, */
			/* if not then just set it expired		 */

			pjob = get_subjob_and_state(parent, get_index_from_jid(jid), &sjst, NULL);
			if (sjst == JOB_STATE_LTR_UNKNOWN) {
				update_deletejob_stat(jid, preq, PBSE_IVALREQ);
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs) {
					req_reject(PBSE_IVALREQ, 0, preq);
					return;
				} else
					continue;
			}

			if ((sjst == JOB_STATE_LTR_EXITING) && (forcedel == 0)) {
				if (parent->ji_pmt_preq != NULL) {
					pjob = find_job(jid);
					reply_preempt_jobs_request(PBSE_BADSTATE, PREEMPT_METHOD_DELETE, pjob);
				}
				update_deletejob_stat(jid, preq, PBSE_BADSTATE);
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs) {
					req_reject(PBSE_BADSTATE, 0, preq);
					return;
				} else
					continue;
			} else if (sjst == JOB_STATE_LTR_EXPIRED) {
				update_deletejob_stat(jid, preq, PBSE_NOHISTARRAYSUBJOB);
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs) {
					req_reject(PBSE_NOHISTARRAYSUBJOB, 0, preq);
					return;
				} else
					continue;
			} else if (pjob != NULL) {
				/*
				* If the request is to also purge the history of the sub job then set ji_deletehistory to 1
				*/
				if (delhist)
					pjob->ji_deletehistory = 1;
				req_deletejob2(preq, pjob);
			} else {
				update_sj_parent(parent, NULL, jid, sjst, JOB_STATE_LTR_EXPIRED);
				acct_del_write(jid, parent, preq, 0);
				parent->ji_ajinfo->tkm_dsubjsct++;
				decr_single_subjob_usage(parent);
				preply->brp_un.brp_deletejoblist.tot_rpys++;
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
					reply_ack(preq);
			}
			chk_array_doneness(parent);
			continue;

		} else if (jt == IS_ARRAY_ArrayJob) {
			int del_parent = 1;
			/*
			 * For array jobs the history is stored at the parent array level and also at the subjob level .
			 * If the request is to delete the history of an array job then set  ji_deletehistory to 1 for
			 * the parent array.The function chk_array_doneness() will take care of eventually
			 *  purging the history .
			 */
			if (delhist)
				parent->ji_deletehistory = 1;
			/* The Array Job itself ... */
			/* for each subjob that is running, delete it via req_deletejob2 */

			++preq->rq_refct;
			preply->brp_un.brp_deletejoblist.tot_arr_jobs++;

			/* keep the array from being removed while we are looking at it */
			parent->ji_ajinfo->tkm_flags |= TKMFLG_NO_DELETE;
			for (i = parent->ji_ajinfo->tkm_start; i <= parent->ji_ajinfo->tkm_end; i += parent->ji_ajinfo->tkm_step) {
				pjob = get_subjob_and_state(parent, i, &sjst, NULL);
				if (sjst == JOB_STATE_LTR_UNKNOWN)
					continue;
				if ((sjst == JOB_STATE_LTR_EXITING) && !forcedel)
					continue;
				if (pjob) {
					if (delhist)
						pjob->ji_deletehistory = 1;
					if (check_job_state(pjob, JOB_STATE_LTR_EXPIRED)) {
						log_eventf(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO,
							   pjob->ji_qs.ji_jobid,
							   msg_job_history_delete, preq->rq_user,
							   preq->rq_host);
						job_purge(pjob);
					} else {
						dup_br_for_subjob(preq, pjob, req_deletejob2);
						del_parent = 0;
					}
				} else {
					/* Queued, Waiting, Held, just set to expired */
					if (sjst != JOB_STATE_LTR_EXPIRED) {
						update_sj_parent(parent, NULL, create_subjob_id(parent->ji_qs.ji_jobid, i), sjst, JOB_STATE_LTR_EXPIRED);
						decr_single_subjob_usage(parent);
					}
				}
			}
			parent->ji_ajinfo->tkm_flags &= ~TKMFLG_NO_DELETE;


			/* if deleting running subjobs, then just return;            */
			/* parent will be deleted when last running subjob(s) ends   */
			/* and reply will be sent to client when last delete is done */
			/* If not deleteing running subjobs, delete2 to del parent   */

			if (--preq->rq_refct == 0) {
				if ((parent = find_job(jid)) != NULL)
					req_deletejob2(preq, parent);
				else {
					preply->brp_un.brp_deletejoblist.tot_rpys++;
					if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
						reply_send(preq);
				}
			} else
				acct_del_write(jid, parent, preq, 0);


			if (del_parent == 1) {
				if ((parent = find_job(jid)) != NULL)
					req_deletejob2(preq, parent);
			}

			continue;
		}
		/* what's left to handle is a range of subjobs, foreach subjob 	*/
		/* if running, do full delete, else just update state	        */

		range = get_range_from_jid(jid);
		if (range == NULL) {
			update_deletejob_stat(jid, preq, PBSE_IVALREQ);
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs) {
				req_reject(PBSE_IVALREQ, 0, preq);
				return;
			} else
				continue;
		}

		++preq->rq_refct;
		while (1) {
			int start;
			int end;
			int step;
			int count;

			if ((i = parse_subjob_index(range, &pc, &start, &end, &step, &count)) == -1) {
				update_deletejob_stat(jid, preq, PBSE_IVALREQ);
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
					req_reject(PBSE_IVALREQ, 0, preq);
				break;
			} else if (i == 1)
				break;

			/*
			 * Ensure that the range specified in the delete job request does not exceed the
			 * index of the highest numbered array subjob
			 */
			if (start < parent->ji_ajinfo->tkm_start || start > parent->ji_ajinfo->tkm_end) {
				update_deletejob_stat(jid, preq, PBSE_UNKJOBID);
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
					req_reject(PBSE_UNKJOBID, 0, preq);
				break;
			}
			for (i = start; i <= end; i += step) {
				pjob = get_subjob_and_state(parent, i, &sjst, NULL);
				if (sjst == JOB_STATE_LTR_UNKNOWN)
					continue;

				if ((sjst == JOB_STATE_LTR_EXITING) && !forcedel)
					continue;

				if (pjob) {
					if (delhist)
						pjob->ji_deletehistory = 1;
					if (check_job_state(pjob, JOB_STATE_LTR_EXPIRED)) {
						log_eventf(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_INFO, pjob->ji_qs.ji_jobid, msg_job_history_delete, preq->rq_user, preq->rq_host);
						job_purge(pjob);
					} else
						dup_br_for_subjob(preq, pjob, req_deletejob2);
				} else {
					/* Queued, Waiting, Held, just set to expired */
					if (sjst != JOB_STATE_LTR_EXPIRED) {
						update_sj_parent(parent, NULL, create_subjob_id(parent->ji_qs.ji_jobid, i), sjst, JOB_STATE_LTR_EXPIRED);
						decr_single_subjob_usage(parent);
					}
				}
			}
			range = pc;
		}
		if (i != -1) {
			sprintf(log_buffer, msg_manager, msg_deletejob,
				preq->rq_user, preq->rq_host);
			if (qdel_mail != 0) {
				svr_mailowner_id(jid, parent, MAIL_OTHER, MAIL_FORCE, log_buffer);
			}
		}

		/* if deleting running subjobs, then just return;            */
		/* parent will be deleted when last running subjob(s) ends   */
		/* and reply will be sent to client when last delete is done */

		if (--preq->rq_refct == 0) {
			preply->brp_un.brp_deletejoblist.tot_rpys++;
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
				reply_send(preq);
			chk_array_doneness(parent);
		}
		continue;
	}

}
/**
 * @brief
 * 		req_deletejob2 - service the Delete Job Request
 *
 *		This request deletes a job.
 *
 * @param[in]	preq	- Job Request
 * @param[in,out]	pjob	- Job structure
 */

static void
req_deletejob2(struct batch_request *preq, job *pjob)
{
	int abortjob = 0;
	char *sig;
	int forcedel = 0;
	struct work_task *pwtold;
	struct work_task *pwtnew;
	struct batch_request *temp_preq = NULL;
	int rc;
	int is_mgr = 0;
	int jt;
	struct batch_reply *preply = &preq->rq_reply;

	/* + 2 is for the '@' in user@host and for the null termination byte. */
	char by_user[PBS_MAXUSER + PBS_MAXHOSTNAME + 2] = {'\0'};

	/* active job is being deleted by delete job batch request */
	pjob->ji_terminated = 1;
	if ((preq->rq_user != NULL) && (preq->rq_host != NULL)) {
		sprintf(by_user, "%s@%s", preq->rq_user, preq->rq_host);
	}

	if ((preq->rq_extend && strstr(preq->rq_extend, FORCE)))
		forcedel = 1;

	/* See if the request is coming from a manager */
	if (preq->rq_perm & (ATR_DFLAG_MGRD | ATR_DFLAG_MGWR))
		is_mgr = 1;

	jt = is_job_array(pjob->ji_qs.ji_jobid);

	if (check_job_state(pjob, JOB_STATE_LTR_TRANSIT)) {

		/*
		 * Find pid of router from existing work task entry,
		 * then establish another work task on same child.
		 * Next, signal the router and wait for its completion;
		 */

		pwtold = (struct work_task *) GET_NEXT(pjob->ji_svrtask);
		while (pwtold) {
			if ((pwtold->wt_type == WORK_Deferred_Child) ||
				(pwtold->wt_type == WORK_Deferred_Cmp)) {
				pwtnew = set_task(pwtold->wt_type,
					pwtold->wt_event, post_delete_route,
					preq);
				if (pwtnew) {

					/*
					 * reset type in case the SIGCHLD came
					 * in during the set_task;  it makes
					 * sure that next_task() will find the
					 * new entry.
					 */
					pwtnew->wt_type = pwtold->wt_type;
					pwtnew->wt_aux = pwtold->wt_aux;

					kill((pid_t) pwtold->wt_event, SIGTERM);
					set_job_substate(pjob, JOB_SUBSTATE_ABORT);
					return; /* all done for now */

				} else {
					if (pjob->ji_pmt_preq != NULL)
						reply_preempt_jobs_request(PBSE_SYSTEM, PREEMPT_METHOD_DELETE, pjob);

					update_deletejob_stat(pjob->ji_qs.ji_jobid, preq, PBSE_SYSTEM);
					if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs) {
						req_reject(PBSE_SYSTEM, 0, preq);
						return;
					}
				}
			}
			pwtold = (struct work_task *) GET_NEXT(pwtold->wt_linkobj);
		}
		/* should never get here ...  */
		log_err(-1, "req_delete", "Did not find work task for router");
		if (pjob->ji_pmt_preq != NULL)
			reply_preempt_jobs_request(PBSE_INTERNAL, PREEMPT_METHOD_DELETE, pjob);

		update_deletejob_stat(pjob->ji_qs.ji_jobid, preq, PBSE_INTERNAL);
		if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs) {
			req_reject(PBSE_INTERNAL, 0, preq);
			return;
		}

	} else if ((check_job_substate(pjob, JOB_SUBSTATE_PRERUN)) && (forcedel == 0)) {

		/* being sent to MOM, wait till she gets it going */
		/* retry in one second				  */

		pwtnew = set_task(WORK_Timed, time_now + 1, post_delete_route,
			preq);
		if (pwtnew == 0) {
			if (pjob->ji_pmt_preq != NULL)
				reply_preempt_jobs_request(PBSE_SYSTEM, PREEMPT_METHOD_DELETE, pjob);
			update_deletejob_stat(pjob->ji_qs.ji_jobid, preq, PBSE_SYSTEM);
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
				req_reject(PBSE_SYSTEM, 0, preq);
		}

		return;
	} else if (((jt != IS_ARRAY_Range) && (jt != IS_ARRAY_Single)) &&
		   (check_job_state(pjob, JOB_STATE_LTR_QUEUED) ||
		    check_job_state(pjob, JOB_STATE_LTR_HELD))) {
		struct depend *dp;
		dp = find_depend(JOB_DEPEND_TYPE_RUNONE, &pjob->ji_wattr[(int)JOB_ATR_depend]);
		if (dp != NULL)
			depend_runone_remove_dependency(pjob);
	}

	if (is_mgr && forcedel) {
		/*
		 * Set exit status for the job to SIGKILL as we will not be working with any obit.
		 */
		pjob->ji_qs.ji_un.ji_exect.ji_exitstat = SIGKILL + 0x100;
	}

	if (check_job_state(pjob, JOB_STATE_LTR_RUNNING) ||
		(check_job_substate(pjob, JOB_SUBSTATE_TERM))) {
		if (check_job_substate(pjob, JOB_SUBSTATE_RERUN)) {
			/* rerun just started, clear that substate and */
			/* normal delete will happen when mom replies  */

			set_job_substate(pjob, JOB_SUBSTATE_RUNNING);
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
				  pjob->ji_qs.ji_jobid, "deleting instead of rerunning");
			acct_del_write(pjob->ji_qs.ji_jobid, pjob, preq, 0);
			preply->brp_un.brp_deletejoblist.tot_rpys++;
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
				reply_ack(preq);
			return;
		}

		if (((check_job_substate(pjob, JOB_SUBSTATE_SUSPEND)) ||
			(check_job_substate(pjob, JOB_SUBSTATE_SCHSUSP))) &&
			(is_jattr_set(pjob,  JOB_ATR_resc_released))) {
			set_resc_assigned(pjob, 0, INCR);
			free_jattr(pjob, JOB_ATR_resc_released);
			mark_jattr_not_set(pjob, JOB_ATR_resc_released);
			if (is_jattr_set(pjob,  JOB_ATR_resc_released_list)) {
				free_jattr(pjob, JOB_ATR_resc_released_list);
				mark_jattr_not_set(pjob, JOB_ATR_resc_released_list);
			}
		}


		if (check_job_substate(pjob, JOB_SUBSTATE_PROVISION)) {
			if (forcedel) {
				/*
				 * discard_job not called since job not sent
				 * to MOM
				 */
				log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB,
					LOG_INFO,
					pjob->ji_qs.ji_jobid, "deleting job");
				acct_del_write(pjob->ji_qs.ji_jobid, pjob,
					preq, 0);
				preply->brp_un.brp_deletejoblist.tot_rpys++;
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
					reply_ack(preq);
				rel_resc(pjob);
				job_abt(pjob, NULL);
			} else {
				if (pjob->ji_pmt_preq != NULL)
					reply_preempt_jobs_request(PBSE_BADSTATE, PREEMPT_METHOD_DELETE, pjob);
				update_deletejob_stat(pjob->ji_qs.ji_jobid, preq, PBSE_BADSTATE);
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
					req_reject(PBSE_BADSTATE, 0, preq);
			}
			return;
		}

		/*
		 * Job is in fact running, so we want to terminate it.
		 *
		 * Send signal request to MOM.  The server will automagically
		 * pick up and "finish" off the client request when MOM replies.
		 * If not "force" send special termjob signal,
		 * if "force" send SIGTERM.
		 */
		if (forcedel)
			sig = sigk;
		else
			sig = sigtj;

		if (is_mgr && forcedel)
			temp_preq = NULL;
		else
			temp_preq = preq;


		rc = issue_signal(pjob, sig, post_delete_mom1, temp_preq);

		/*
		 * If forcedel is set and request is from a manager,
		 * job is deleted from server regardless
		 * of issue_signal to MoM was a success or failure.
		 * Eventually, when the mom updates server about the job,
		 * server sends a discard message to mom and job is then
		 * deleted from mom as well.
		 */
		if ((rc || is_mgr) && forcedel) {
			svr_setjobstate(pjob, JOB_STATE_LTR_EXITING, JOB_SUBSTATE_EXITED);
			if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) == 0)
				issue_track(pjob);
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
				pjob->ji_qs.ji_jobid, "Delete forced");
			acct_del_write(pjob->ji_qs.ji_jobid, pjob, preq, 0);
			/*
			 * If we are waiting for preemption to be complete and someone does a qdel -Wforce
			 * we need to reply back to the scheduler.  We need to reply success so we don't
			 * attempt another preemption method.  This leads to a minor race condition
			 * where the moms might not be finished cleaning up when the high priority job runs.
			 */
			if (pjob->ji_pmt_preq != NULL)
				reply_preempt_jobs_request(PBSE_NONE, PREEMPT_METHOD_DELETE, pjob);

			if (preq->rq_parentbr)
				reply_ack(preq);
			else {
				preply->brp_un.brp_deletejoblist.tot_rpys++;
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
					reply_ack(preq);
			}
			discard_job(pjob, "Forced Delete", 1);
			rel_resc(pjob);

			if (is_mgr) {
				/*
				 * Set exit status for the job to SIGKILL as we will not be working with any obit.
				 */
				set_jattr_l_slim(pjob, JOB_ATR_exit_status, pjob->ji_qs.ji_un.ji_exect.ji_exitstat, SET);
			pjob->ji_wattr[(int)JOB_ATR_exit_status].at_flags = ATR_SET_MOD_MCACHE;
			}

			/* see if it has any dependencies */
			if (is_jattr_set(pjob, JOB_ATR_depend))
				depend_on_term(pjob);

			/*
			 * Check if the history of the finished job can be saved or it needs to be purged .
			 */
			svr_saveorpurge_finjobhist(pjob);
			return;
		}
		if (rc) {
			if (pjob->ji_pmt_preq != NULL)
				reply_preempt_jobs_request(rc, PREEMPT_METHOD_DELETE, pjob);
			update_deletejob_stat(pjob->ji_qs.ji_jobid, preq, rc);
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
				req_reject(rc, 0, preq); /* cant send to MOM */
			sprintf(log_buffer, "Delete failed %d", rc);
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_NOTICE,
				pjob->ji_qs.ji_jobid, log_buffer);
			return;
		}
		/* normally will ack reply when mom responds */
		update_job_finish_comment(pjob, JOB_SUBSTATE_TERMINATED, by_user);
		sprintf(log_buffer, msg_delrunjobsig, sig);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
			pjob->ji_qs.ji_jobid, log_buffer);
		return;
	} else if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_CHKPT) != 0) {

		/* job has restart file at mom, do end job processing */

		svr_setjobstate(pjob, JOB_STATE_LTR_EXITING, JOB_SUBSTATE_EXITING);
		pjob->ji_momhandle = -1; /* force new connection */
		pjob->ji_mom_prot = PROT_INVALID;
		set_task(WORK_Immed, 0, on_job_exit, (void *) pjob);

	} else if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_StagedIn) != 0) {

		/* job has staged-in file, should remove them */
		remove_stagein(pjob);
		abortjob = 1; /* set flag to abort job after mail sent */

	} else {

		/*
		 * the job is not transiting (though it may have been) and
		 * is not running, so abort it.
		 */

		abortjob = 1; /* set flag to abort job after mail sent */
	}
	/*
	 * Log delete and if requesting client is not job owner, send mail.
	 */

	acct_del_write(pjob->ji_qs.ji_jobid, pjob, preq, 0);

	if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_ArrayJob) && !forcedel)
		chk_array_doneness(pjob);
	else if (abortjob) {
		if (check_job_state(pjob, JOB_STATE_LTR_EXITING))
			discard_job(pjob, "Forced Delete", 1);
		rel_resc(pjob);
		if (pjob->ji_pmt_preq != NULL)
			reply_preempt_jobs_request(PBSE_NONE, PREEMPT_METHOD_DELETE, pjob);
		job_abt(pjob, NULL);
	}

	if (preq->rq_parentbr)
		reply_send(preq);
	else {
		preply->brp_un.brp_deletejoblist.tot_rpys++;
		if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
			reply_send(preq);
	}
}

/**
 * @brief
 * 		req_reservationOccurrenceEnd - service the PBS_BATCH_ResvOccurEnd Request
 *
 *		This request runs a hook script at the end of the reservation occurrence
 *
 * @param[in]	preq	- Job Request
 *
 */


void req_reservationOccurrenceEnd(struct batch_request *preq)
{
	char hook_msg[HOOK_MSG_SIZE] = {0};

        switch (process_hooks(preq, hook_msg, sizeof(hook_msg), pbs_python_set_interrupt)) {
		case 0:	/* explicit reject */
			reply_text(preq, PBSE_HOOKERROR, hook_msg);
			break;
		case 1: /* no recreate request as there are only read permissions */
		case 2:	/* no hook script executed - go ahead and accept event*/
			reply_ack(preq);
			break;
		default:
			log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_HOOK,	LOG_INFO, __func__, "resv_end event: accept req by default");
			reply_ack(preq);
	}
	return;
}

/**
 * @brief
 * 		req_deleteReservation - service the PBS_BATCH_DeleteResv Request
 *
 *		This request deletes a resources reservation if the requester
 *		is authorized to do this.
 *
 * @param[in]	preq	- Job Request
 *
 * @par	MT-safe: No
 */

void
req_deleteReservation(struct batch_request *preq)
{
	static int lenF = 6; /*strlen ("False") + 1*/

	resc_resv *presv;
	job *pjob;
	struct batch_request *newreq;
	struct work_task *pwt;

	char buf[PBS_MAXHOSTNAME + PBS_MAXUSER + 2]; /* temp, possibly remove in future */
	char user[PBS_MAXUSER + 1];
	char host[PBS_MAXHOSTNAME + 1];
	int perm;
	int relVal;
	int state, sub;
	long futuredr;

	/*Does resc_resv object exist and requester have enough priviledge?*/

	presv = chk_rescResv_request(preq->rq_ind.rq_manager.rq_objname, preq);

	/*Note: on failure, chk_rescResv_request invokes req_reject
	 *Appropriate reply got sent & batch_request got freed
	 */
	if (presv == NULL)
		return;

	/*Know resc_resv struct exists and requester allowed to remove it*/
	futuredr = presv->ri_futuredr;
	presv->ri_futuredr = 0; /*would be non-zero if getting*/
	/*here from task_list_timed*/
	strcpy(user, preq->rq_user); /*need after request is gone*/
	strcpy(host, preq->rq_host);
	perm = preq->rq_perm;

	/*Generate message(s) to reservation owner (listed users) as appropriate
	 *according to what was requested in the mailpoints attribute and who
	 *the submitter of the request happens to be (user, scheduler, or us)
	 */
	resv_mailAction(presv, preq);
	/*ck_submitClient_needs_reply()*/
	if (presv->ri_brp) {
		if (presv->ri_qs.ri_state == RESV_UNCONFIRMED) {
			if ((presv->ri_wattr[RESV_ATR_interactive].at_flags & ATR_VFLAG_SET) &&
				(presv->ri_wattr[RESV_ATR_interactive].at_val.at_long < 0) &&
				(futuredr != 0)) {

				sprintf(buf, "%s delete, wait period expired",
					presv->ri_qs.ri_resvID);
			} else {
				sprintf(buf, "%s DENIED", presv->ri_qs.ri_resvID);
			}

		} else {
			sprintf(buf, "%s BEING DELETED", presv->ri_qs.ri_resvID);
		}

		reply_text(presv->ri_brp, PBSE_NONE, buf);
		presv->ri_brp = NULL;
	}


	sprintf(buf, "%s@%s", preq->rq_user, preq->rq_host);
	sprintf(log_buffer, "requestor=%s", buf);

	if (strcmp(presv->ri_wattr[RESV_ATR_resv_owner].at_val.at_str, buf))
		account_recordResv(PBS_ACCT_DRss, presv, log_buffer);
	else
		account_recordResv(PBS_ACCT_DRclient, presv, log_buffer);

	if (presv->ri_qs.ri_state != RESV_UNCONFIRMED) {
		char hook_msg[HOOK_MSG_SIZE] = {0};
		switch (process_hooks(preq, hook_msg, sizeof(hook_msg), pbs_python_set_interrupt)) {
		case 0: /* explicit reject */
		case 1: /* no recreate request as there are only read permissions */
		case 2: /* no hook script executed - go ahead and accept event*/
			break;
		default:
			log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_HOOK, LOG_INFO, __func__, "resv_end event: accept req by default");
		}
	}

	/*If there are any jobs associated with the reservation, construct and
	 *issue a PBS_BATCH_DeleteJob request for each job.
	 *
	 *General notes on this process:
	 *Use issue_Drequest() to issue a PBS_BATCH_* request - can be to
	 *1) this server, 2) another server, 3) to a pbs_mom.
	 *
	 *In the present situation the server is going to issue the request to
	 *itself (a locally generated request).  The future "event" that's
	 *to occur, and which must be handled, is the reply fom this request.
	 *The handling task is initially placed on the server's "task_list_event"
	 *list as a task of type "WORK_Deferred_Local" and, a call is made to the
	 *general "dispatch" function (dispatch_request) to dispatch the request.
	 *In replying back to itself regarding the request to itself, function
	 *"reply_send" is called.  Since it is passed a pointer to the batch_request
	 *structure for the request that it received, it will note that the request
	 *came from itself (connection set to PBS_LOCAL_CONNECTION).  It finds the
	 *handling task on "task_list_event" by finding the task with task field
	 *"wt_parm1" set equal to the address of the batch request structure in
	 *question.  That task is moved off the "event_task_list" and put on the
	 *"immedite_task_list" where it can be found and invoked the next time that
	 *the server calls function "next_task" from it's main loop.
	 *The work_task function that's going to be invoked will be responding to
	 *the "reply" that comes back from the servers original request to itself.
	 *The handling function, in addition to whatever else it might do, does
	 *have the RESPONSIBILITY of calling free_br() to remove all memory associated
	 *with the batch_request structure.
	 */

	if (presv->ri_qp != NULL && presv->ri_qp->qu_numjobs > 0) {

		/*One or more jobs are attached to this resource reservation
		 *Issue a PBS_BATCH_Manager request to set "enable" to "False"
		 *for the queue (if it is not already so set), set "start" for
		 *the queue to "False" as well- so the scheduler will cease
		 *scheduling the jobs in queue, then issue a PBS_BATCH_DeleteJob
		 *request for each resident job.
		 */

		int deleteProblem = 0;
		job *pnxj;

		if (presv->ri_qp->qu_attr[QA_ATR_Enabled].at_val.at_long) {

			svrattrl *psatl;
			newreq = alloc_br(PBS_BATCH_Manager);
			if (newreq == NULL) {
				req_reject(PBSE_SYSTEM, 0, preq);
				return;
			}
			CLEAR_HEAD(newreq->rq_ind.rq_manager.rq_attr);

			newreq->rq_ind.rq_manager.rq_cmd = MGR_CMD_SET;
			newreq->rq_ind.rq_manager.rq_objtype = MGR_OBJ_QUEUE;
			strcpy(newreq->rq_ind.rq_manager.rq_objname,
				presv->ri_qp->qu_qs.qu_name);
			strcpy(newreq->rq_user, user);
			strcpy(newreq->rq_host, host);
			newreq->rq_perm = perm;

			if ((psatl = attrlist_create(ATTR_enable, NULL, lenF))
				== NULL) {

				req_reject(PBSE_SYSTEM, 0, preq);
				free_br(newreq);
				return;
			}
			psatl->al_flags = que_attr_def[QA_ATR_Enabled].at_flags;
			strcpy(psatl->al_value, "False");
			append_link(&newreq->rq_ind.rq_manager.rq_attr, &psatl->al_link, psatl);

			if ((psatl = attrlist_create(ATTR_start, NULL, lenF))
				== NULL) {

				req_reject(PBSE_SYSTEM, 0, preq);
				free_br(newreq);
				return;
			}
			psatl->al_flags = que_attr_def[QA_ATR_Started].at_flags;
			strcpy(psatl->al_value, "False");
			append_link(&newreq->rq_ind.rq_manager.rq_attr,
				&psatl->al_link, psatl);

			if (issue_Drequest(PBS_LOCAL_CONNECTION, newreq,
				release_req, &pwt, 0) == -1) {
				req_reject(PBSE_SYSTEM, 0, preq);
				free_br(newreq);
				return;
			}
			/* set things so that any removal of the reservation
			 * structure also removes any "yet to be processed"
			 * work tasks that are associated with the reservation
			 */
			append_link(&presv->ri_svrtask, &pwt->wt_linkobj, pwt);

			tickle_for_reply();
		}

		/*Ok, input to the queue is stopped, try and delete jobs in queue*/

		relVal = 1;
		eval_resvState(presv, RESVSTATE_req_deleteReservation,
			relVal, &state, &sub);
		resv_setResvState(presv, state, sub);
		pjob = (job *) GET_NEXT(presv->ri_qp->qu_jobs);
		while (pjob != NULL) {

			pnxj = (job *) GET_NEXT(pjob->ji_jobque);

			/* skip all expired subjobs, expired subjobs are deleted when array parent is
			 * issued delete request
			 */
			for (; pnxj != NULL && (pnxj->ji_qs.ji_svrflags & JOB_SVFLG_SubJob) &&
			     check_job_state(pnxj, JOB_STATE_LTR_EXPIRED); pnxj = (job *) GET_NEXT(pnxj->ji_jobque))
				;
			/*
			 * If a history job (job state is JOB_STATE_LTR_MOVED
			 * or JOB_STATE_LTR_FINISHED, then no need to delete
			 * it again as it is already deleted.
			 */
			if (check_job_state(pjob, JOB_STATE_LTR_MOVED) ||
				(pjob->ji_qs.ji_svrflags & JOB_SVFLG_SubJob) ||
				check_job_state(pjob, JOB_STATE_LTR_FINISHED)) {
				pjob = pnxj;
				continue;
			}

			newreq = alloc_br(PBS_BATCH_DeleteJob);
			if (newreq != NULL) {

				/*when owner of job is not same as owner of resv, */
				/*need extra permission; Also extra info for owner*/

				CLEAR_HEAD(newreq->rq_ind.rq_manager.rq_attr);
				newreq->rq_perm = perm | ATR_DFLAG_MGWR;
				newreq->rq_extend = NULL;

				/*reply processing needs resv*/
				newreq->rq_extra = (void *) presv;

				strcpy(newreq->rq_user, user);
				strcpy(newreq->rq_host, host);
				strcpy(newreq->rq_ind.rq_delete.rq_objname,
					pjob->ji_qs.ji_jobid);

				if (issue_Drequest(PBS_LOCAL_CONNECTION, newreq,
					release_req, &pwt, 0) == -1) {
					deleteProblem++;
					free_br(newreq);
				}
				/* set things so that any removal of the reservation
				 * structure also removes any "yet to be processed"
				 * work tasks that are associated with the reservation
				 */
				append_link(&presv->ri_svrtask, &pwt->wt_linkobj, pwt);

				tickle_for_reply();
			} else
				deleteProblem++;

			pjob = pnxj;
		}

		if (deleteProblem) {
			/*some problems attempting to delete reservation's jobs
			 *shouldn't end up re-calling req_deleteReservation
			 */
			sprintf(log_buffer, "%s %s\n",
				"problem deleting jobs belonging to",
				presv->ri_qs.ri_resvID);
			reply_text(preq, PBSE_RESVMSG, log_buffer);
		} else {
			/*no problems so far, we are attempting to do it
			 *If all job deletions succeed, resv_purge()
			 *should get triggered
			 */
			reply_ack(preq);

			/*
			 * If all the jobs in the RESV are history jobs, then
			 * better to purge the RESV now only without waiting
			 * for next resv delete iteration.
			 */
			pjob = NULL;
			if (presv && presv->ri_qp)
				pjob = (job *) GET_NEXT(presv->ri_qp->qu_jobs);
			while (pjob != NULL) {
				if ((!check_job_state(pjob, JOB_STATE_LTR_MOVED)) &&
					(!check_job_state(pjob, JOB_STATE_LTR_FINISHED)) &&
					(!check_job_state(pjob, JOB_STATE_LTR_EXPIRED)))
					break;
				pjob = (job *) GET_NEXT(pjob->ji_jobque);
			}
			if (pjob == NULL) /* all are history jobs only */
				resv_purge(presv);
			else {
				/* other jobs remain, need to set task to monitor */
				/* when they are dequeued */
				pwt = set_task(WORK_Immed, 0, post_deljobfromresv_req,
					(void *) presv);
				if (pwt)
					append_link(&presv->ri_svrtask,
						&pwt->wt_linkobj, pwt);
			}
		}

		/*This is all we can do for now*/
		return;

	}

	/* Ok, we have no jobs attached so can purge reservation
		If reservation has an attached queue, a request to qmgr
		will get made to delete the queue
		*/
	relVal = 2;
	eval_resvState(presv, RESVSTATE_req_deleteReservation,
		relVal, &state, &sub);
	resv_setResvState(presv, state, sub);
	reply_ack(preq);
	resv_purge(presv);
	return;
}


/**
 * @brief
 * 		post_delete_route - complete the task of deleting a job which was
 *		being routed at the time the delete request was received.
 *
 *		Just recycle the delete request, the job will either be here or not.
 *
 * @param[in]	pwt	- work_task structure
 */

static void
post_delete_route(struct work_task *pwt)
{
	req_deletejob((struct batch_request *) pwt->wt_parm1);
	return;
}

/**
 * @brief
 * 		post_delete_mom1 - first of 2 work task trigger functions to finish the
 *		deleting of a running job.  This first part is invoked when MOM
 *		responds to the SIGTERM signal request.
 *
 * @param[in]	pwt	- work task
 */

static void
post_delete_mom1(struct work_task *pwt)
{
	int auxcode;
	job *pjob;
	struct batch_request *preq_sig; /* signal request to MOM */
	struct batch_request *preq_clt; /* original client request */
	int rc;
	int tries = 0;
	struct batch_reply *preply = NULL;

	preq_sig = pwt->wt_parm1;
	rc = preq_sig->rq_reply.brp_code;
	auxcode = preq_sig->rq_reply.brp_auxcode;
	preq_clt = preq_sig->rq_extra;
	if (preq_clt == NULL) {
		release_req(pwt);
		return;
	}

	preply = &preq_clt->rq_reply;
	pjob = find_job(preq_sig->rq_ind.rq_signal.rq_jid);
	release_req(pwt);
	if (pjob == NULL) {
		/* job has gone away */
		update_deletejob_stat(pjob->ji_qs.ji_jobid, preq_clt, PBSE_UNKJOBID);
		if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
			req_reject(PBSE_UNKJOBID, 0, preq_clt);
		return;
	}

resend:
	if (rc) {
		/* mom rejected request */
		sprintf(log_buffer, "MOM rejected signal during delete (%d)", rc);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
			pjob->ji_qs.ji_jobid, log_buffer);

		if (rc == PBSE_UNKSIG) {
			if (tries++) {
				update_deletejob_stat(pjob->ji_qs.ji_jobid, preq_clt, rc);
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
					req_reject(rc, 0, preq_clt);
				return;
			}
			/* 2nd try, use SIGTERM */
			rc = issue_signal(pjob, sigt, post_delete_mom1, preq_clt);
			if (rc == 0)
				return; /* will be back when replies */
			goto resend;
		} else if (rc == PBSE_UNKJOBID) {
			/* if job was in prerun state, cannot delete it, even if mom does not know
			 * about this job. Going ahead and deleting could result in a
			 * server crash, when post_sendmom completes.
			 */
			if (check_job_substate(pjob, JOB_SUBSTATE_PRERUN)) {
				if (pjob->ji_pmt_preq != NULL)
					reply_preempt_jobs_request(rc, PREEMPT_METHOD_DELETE, pjob);
				update_deletejob_stat(pjob->ji_qs.ji_jobid, preq_clt, rc);
				if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
					req_reject(rc, 0, preq_clt);
				return;
			}

			/* MOM claims no knowledge, so just purge it */
			acct_del_write(pjob->ji_qs.ji_jobid, pjob, preq_clt, 0);
			/* removed the resources assigned to job */
			free_nodes(pjob);
			set_resc_assigned(pjob, 0, DECR);
			preply->brp_un.brp_deletejoblist.tot_rpys++;
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
				reply_ack(preq_clt);
			svr_saveorpurge_finjobhist(pjob);
		} else {
			if (pjob->ji_pmt_preq != NULL)
				reply_preempt_jobs_request(rc, PREEMPT_METHOD_DELETE, pjob);
			update_deletejob_stat(pjob->ji_qs.ji_jobid, preq_clt, rc);
			if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
				req_reject(rc, 0, preq_clt);
		}
		return;
	}

	acct_del_write(pjob->ji_qs.ji_jobid, pjob, preq_clt, 0);

	if (preq_clt->rq_parentbr) {
		reply_ack(preq_clt);
	} else {
		preply->brp_un.brp_deletejoblist.tot_rpys++;
		if (preply->brp_un.brp_deletejoblist.tot_rpys == preply->brp_un.brp_deletejoblist.tot_jobs)
			reply_ack(preq_clt); /* dont need it, reply now */
	}


	if (auxcode == JOB_SUBSTATE_TERM) {
		/* Mom running a site supplied Terminate Job script   */
		/* Put job into special Exiting state and we are done */

		svr_setjobstate(pjob, JOB_STATE_LTR_EXITING, JOB_SUBSTATE_TERM);
		return;
	}
}

/**
 * @brief
 *		post_deljobfromresv_req
 *
 * @par Functionality:
 *
 *		This work_task function is triggered after all jobs in the queue
 *		associated with a reservation have had delete requests issued.
 *		If all jobs are  indeed found to be no longer present,
 *		the down counter in the reservation structure is
 *		decremented.  When the decremented value becomes less
 *		than or equal to zero, issue a request to delete the
 *		reservation.
 *
 *		If SERVER is configured for history jobs...
 *		If the reservation down counter is positive, check if all
 *		the jobs in the resv are history jobs. If yes, purge the
 *		reservation using resv_purge() without waiting.
 *
 *		If there are still non-history jobs, recall itself after 30 seconds.
 *
 * @param[in]	pwt	- pointer to the work task, the reservation structure
 *			  			pointer is contained in wt_parm1
 *
 * @return	void
 *
 */

static void
post_deljobfromresv_req(pwt)
struct work_task *pwt;
{
	resc_resv *presv;
	job *pjob = NULL;

	presv = (resc_resv *)((struct batch_request *) pwt->wt_parm1);

	/* return if presv is not valid */
	if (presv == NULL)
		return;

	presv->ri_downcnt = presv->ri_qp->qu_numjobs;
	if (presv->ri_downcnt != 0) {
		if (presv->ri_qp)
			pjob = (job *) GET_NEXT(presv->ri_qp->qu_jobs);
		while (pjob != NULL) {
			if ((!check_job_state(pjob, JOB_STATE_LTR_MOVED)) &&
				(!check_job_state(pjob, JOB_STATE_LTR_FINISHED)) &&
				(!check_job_state(pjob, JOB_STATE_LTR_EXPIRED)))
				break;
			pjob = (job *) GET_NEXT(pjob->ji_jobque);
		}
		/*
			* If pjob is NULL, then all are history jobs only,
			* make the ri_downcnt to 0, so that resv_purge()
			* can be called down.
			*/
		if (pjob == NULL)
			presv->ri_downcnt = 0;
	}

	if (presv->ri_downcnt == 0) {
		resv_purge(presv);
	} else if (pjob) {
		/* one or more jobs still not able to be deleted; set me up for
		 * another call for 30 seconds into the future.
		 */
		pwt = set_task(WORK_Timed, time_now + 30, post_deljobfromresv_req,
			(void *) presv);
		if (pwt)
			append_link(&presv->ri_svrtask, &pwt->wt_linkobj, pwt);
	}
}
