/* soapC.c
 Generated by gSOAP 2.7.9i from bes-factory.h
 Copyright(C) 2000-2007, Robert van Engelen, Genivia Inc. All Rights Reserved.
 This part of the software is released under one of the following licenses:
 Genivia's license for commercial use.
 */
/**
 * @file	soapC.
 */
#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.9i 2008-12-02 09:56:55 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_putheader(struct soap *soap)
{
	if (soap->header) {
		soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_fault(struct soap *soap)
{
	if (!soap->fault) {
		soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code) {
		soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason) {
		soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4
soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4
soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2) {
		if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode) {
			soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4
soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4
soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4
soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4
soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type) {
		case SOAP_TYPE_byte:
			return soap_in_byte(soap, NULL, NULL, "xsd:byte");
		case SOAP_TYPE_int:
			return soap_in_int(soap, NULL, NULL, "xsd:int");
		case SOAP_TYPE_LONG64:
			return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
		case SOAP_TYPE_double:
			return soap_in_double(soap, NULL, NULL, "xsd:double");
		case SOAP_TYPE_unsignedLONG64:
			return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
		case SOAP_TYPE_time:
			return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
		case SOAP_TYPE_jsdl__CreationFlagEnumeration:
			return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, "jsdl:CreationFlagEnumeration");
		case SOAP_TYPE_jsdl__FileSystemTypeEnumeration:
			return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
		case SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration:
			return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, "jsdl:OperatingSystemTypeEnumeration");
		case SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration:
			return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, "jsdl:ProcessorArchitectureEnumeration");
		case SOAP_TYPE_wsa__FaultCodesType:
			return soap_in_wsa__FaultCodesType(soap, NULL, NULL, "wsa:FaultCodesType");
		case SOAP_TYPE_wsa__RelationshipType:
			return soap_in_wsa__RelationshipType(soap, NULL, NULL, "wsa:RelationshipType");
		case SOAP_TYPE_bes__ActivityStateEnumeration:
			return soap_in_bes__ActivityStateEnumeration(soap, NULL, NULL, "bes:ActivityStateEnumeration");
		case SOAP_TYPE_xsd__boolean:
			return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
		case SOAP_TYPE_wsse__FaultcodeEnum:
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
		case SOAP_TYPE_wsu__tTimestampFault:
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
		case SOAP_TYPE_jsdl_hpcpa__HPCProfileApplication_USCOREType:
			return soap_in_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:HPCProfileApplication_Type");
		case SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType:
			return soap_in_jsdl_hpcpa__UserName_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:UserName_Type");
		case SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType:
			return soap_in_jsdl_hpcpa__DirectoryName_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:DirectoryName_Type");
		case SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType:
			return soap_in_jsdl_hpcpa__FileName_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:FileName_Type");
		case SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType:
			return soap_in_jsdl_hpcpa__Argument_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:Argument_Type");
		case SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType:
			return soap_in_jsdl_hpcpa__Environment_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:Environment_Type");
		case SOAP_TYPE_jsdl_posix__POSIXApplication_USCOREType:
			return soap_in_jsdl_posix__POSIXApplication_USCOREType(soap, NULL, NULL, "jsdl-posix:POSIXApplication_Type");
		case SOAP_TYPE_jsdl_posix__GroupName_USCOREType:
			return soap_in_jsdl_posix__GroupName_USCOREType(soap, NULL, NULL, "jsdl-posix:GroupName_Type");
		case SOAP_TYPE_jsdl_posix__UserName_USCOREType:
			return soap_in_jsdl_posix__UserName_USCOREType(soap, NULL, NULL, "jsdl-posix:UserName_Type");
		case SOAP_TYPE_jsdl_posix__Limits_USCOREType:
			return soap_in_jsdl_posix__Limits_USCOREType(soap, NULL, NULL, "jsdl-posix:Limits_Type");
		case SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType:
			return soap_in_jsdl_posix__DirectoryName_USCOREType(soap, NULL, NULL, "jsdl-posix:DirectoryName_Type");
		case SOAP_TYPE_jsdl_posix__FileName_USCOREType:
			return soap_in_jsdl_posix__FileName_USCOREType(soap, NULL, NULL, "jsdl-posix:FileName_Type");
		case SOAP_TYPE_jsdl_posix__Argument_USCOREType:
			return soap_in_jsdl_posix__Argument_USCOREType(soap, NULL, NULL, "jsdl-posix:Argument_Type");
		case SOAP_TYPE_jsdl_posix__Environment_USCOREType:
			return soap_in_jsdl_posix__Environment_USCOREType(soap, NULL, NULL, "jsdl-posix:Environment_Type");
		case SOAP_TYPE_hpcp_af__DynamicNodeStatusType:
			return soap_in_hpcp_af__DynamicNodeStatusType(soap, NULL, NULL, "hpcp-af:DynamicNodeStatusType");
		case SOAP_TYPE_hpcp_af__ActivityIdType:
			return soap_in_hpcp_af__ActivityIdType(soap, NULL, NULL, "hpcp-af:ActivityIdType");
		case SOAP_TYPE_hpcp_af__CPUType:
			return soap_in_hpcp_af__CPUType(soap, NULL, NULL, "hpcp-af:CPUType");
		case SOAP_TYPE_hpcp_af__MemoryType:
			return soap_in_hpcp_af__MemoryType(soap, NULL, NULL, "hpcp-af:MemoryType");
		case SOAP_TYPE_hpcp_af__NodeStatusType:
			return soap_in_hpcp_af__NodeStatusType(soap, NULL, NULL, "hpcp-af:NodeStatusType");
		case SOAP_TYPE_hpcp_af__ActivityIdRangeType:
			return soap_in_hpcp_af__ActivityIdRangeType(soap, NULL, NULL, "hpcp-af:ActivityIdRangeType");
		case SOAP_TYPE_hpcp_af__DateTimeRangeType:
			return soap_in_hpcp_af__DateTimeRangeType(soap, NULL, NULL, "hpcp-af:DateTimeRangeType");
		case SOAP_TYPE_hpcp_af__AdvancedFilterType:
			return soap_in_hpcp_af__AdvancedFilterType(soap, NULL, NULL, "hpcp-af:AdvancedFilterType");
		case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
			return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
		case SOAP_TYPE_jsdl__DataStaging_USCOREType:
			return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
		case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
			return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
		case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
			return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
		case SOAP_TYPE_jsdl__FileSystem_USCOREType:
			return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
		case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
			return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
		case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
			return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
		case SOAP_TYPE_jsdl__Resources_USCOREType:
			return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
		case SOAP_TYPE_jsdl__Application_USCOREType:
			return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
		case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
			return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
		case SOAP_TYPE_jsdl__JobDescription_USCOREType:
			return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
		case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
			return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
		case SOAP_TYPE_jsdl__RangeValue_USCOREType:
			return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
		case SOAP_TYPE_jsdl__Range_USCOREType:
			return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
		case SOAP_TYPE_jsdl__Exact_USCOREType:
			return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
		case SOAP_TYPE_jsdl__Boundary_USCOREType:
			return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
		case SOAP_TYPE_wsa__ProblemActionType:
			return soap_in_wsa__ProblemActionType(soap, NULL, NULL, "wsa:ProblemActionType");
		case SOAP_TYPE_wsa__AttributedQNameType:
			return soap_in_wsa__AttributedQNameType(soap, NULL, NULL, "wsa:AttributedQNameType");
		case SOAP_TYPE_wsa__AttributedUnsignedLongType:
			return soap_in_wsa__AttributedUnsignedLongType(soap, NULL, NULL, "wsa:AttributedUnsignedLongType");
		case SOAP_TYPE_wsa__AttributedURIType:
			return soap_in_wsa__AttributedURIType(soap, NULL, NULL, "wsa:AttributedURIType");
		case SOAP_TYPE_wsa__RelatesToType:
			return soap_in_wsa__RelatesToType(soap, NULL, NULL, "wsa:RelatesToType");
		case SOAP_TYPE_wsa__MetadataType:
			return soap_in_wsa__MetadataType(soap, NULL, NULL, "wsa:MetadataType");
		case SOAP_TYPE_wsa__ReferenceParametersType:
			return soap_in_wsa__ReferenceParametersType(soap, NULL, NULL, "wsa:ReferenceParametersType");
		case SOAP_TYPE_wsa__EndpointReferenceType:
			return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, "wsa:EndpointReferenceType");
		case SOAP_TYPE_bes__TerminateActivityResponseType:
			return soap_in_bes__TerminateActivityResponseType(soap, NULL, NULL, "bes:TerminateActivityResponseType");
		case SOAP_TYPE_bes__GetActivityDocumentResponseType:
			return soap_in_bes__GetActivityDocumentResponseType(soap, NULL, NULL, "bes:GetActivityDocumentResponseType");
		case SOAP_TYPE_bes__GetActivityStatusResponseType:
			return soap_in_bes__GetActivityStatusResponseType(soap, NULL, NULL, "bes:GetActivityStatusResponseType");
		case SOAP_TYPE_bes__ActivityStatusType:
			return soap_in_bes__ActivityStatusType(soap, NULL, NULL, "bes:ActivityStatusType");
		case SOAP_TYPE_bes__ActivityDocumentType:
			return soap_in_bes__ActivityDocumentType(soap, NULL, NULL, "bes:ActivityDocumentType");
		case SOAP_TYPE_bes__FactoryResourceAttributesDocumentType:
			return soap_in_bes__FactoryResourceAttributesDocumentType(soap, NULL, NULL, "bes:FactoryResourceAttributesDocumentType");
		case SOAP_TYPE_bes__BasicResourceAttributesDocumentType:
			return soap_in_bes__BasicResourceAttributesDocumentType(soap, NULL, NULL, "bes:BasicResourceAttributesDocumentType");
		case SOAP_TYPE_bes__InvalidRequestMessageFaultType:
			return soap_in_bes__InvalidRequestMessageFaultType(soap, NULL, NULL, "bes:InvalidRequestMessageFaultType");
		case SOAP_TYPE_bes__InvalidActivityIdentifierFaultType:
			return soap_in_bes__InvalidActivityIdentifierFaultType(soap, NULL, NULL, "bes:InvalidActivityIdentifierFaultType");
		case SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType:
			return soap_in_bes__OperationWillBeAppliedEventuallyFaultType(soap, NULL, NULL, "bes:OperationWillBeAppliedEventuallyFaultType");
		case SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType:
			return soap_in_bes__CantApplyOperationToCurrentStateFaultType(soap, NULL, NULL, "bes:CantApplyOperationToCurrentStateFaultType");
		case SOAP_TYPE_bes__UnsupportedFeatureFaultType:
			return soap_in_bes__UnsupportedFeatureFaultType(soap, NULL, NULL, "bes:UnsupportedFeatureFaultType");
		case SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType:
			return soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, "bes:NotAcceptingNewActivitiesFaultType");
		case SOAP_TYPE_bes__NotAuthorizedFaultType:
			return soap_in_bes__NotAuthorizedFaultType(soap, NULL, NULL, "bes:NotAuthorizedFaultType");
		case SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType:
			return soap_in_bes__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, "bes:GetFactoryAttributesDocumentResponseType");
		case SOAP_TYPE_bes__GetFactoryAttributesDocumentType:
			return soap_in_bes__GetFactoryAttributesDocumentType(soap, NULL, NULL, "bes:GetFactoryAttributesDocumentType");
		case SOAP_TYPE_bes__GetActivityDocumentsResponseType:
			return soap_in_bes__GetActivityDocumentsResponseType(soap, NULL, NULL, "bes:GetActivityDocumentsResponseType");
		case SOAP_TYPE_bes__GetActivityDocumentsType:
			return soap_in_bes__GetActivityDocumentsType(soap, NULL, NULL, "bes:GetActivityDocumentsType");
		case SOAP_TYPE_bes__TerminateActivitiesResponseType:
			return soap_in_bes__TerminateActivitiesResponseType(soap, NULL, NULL, "bes:TerminateActivitiesResponseType");
		case SOAP_TYPE_bes__TerminateActivitiesType:
			return soap_in_bes__TerminateActivitiesType(soap, NULL, NULL, "bes:TerminateActivitiesType");
		case SOAP_TYPE_bes__GetActivityStatusesResponseType:
			return soap_in_bes__GetActivityStatusesResponseType(soap, NULL, NULL, "bes:GetActivityStatusesResponseType");
		case SOAP_TYPE_bes__GetActivityStatusesType:
			return soap_in_bes__GetActivityStatusesType(soap, NULL, NULL, "bes:GetActivityStatusesType");
		case SOAP_TYPE_bes__CreateActivityResponseType:
			return soap_in_bes__CreateActivityResponseType(soap, NULL, NULL, "bes:CreateActivityResponseType");
		case SOAP_TYPE_bes__CreateActivityType:
			return soap_in_bes__CreateActivityType(soap, NULL, NULL, "bes:CreateActivityType");
		case SOAP_TYPE_xsd__anyType:
			return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
		case SOAP_TYPE_ds__RSAKeyValueType:
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
		case SOAP_TYPE_ds__DSAKeyValueType:
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
		case SOAP_TYPE_ds__X509IssuerSerialType:
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
		case SOAP_TYPE_ds__X509DataType:
			return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
		case SOAP_TYPE_ds__RetrievalMethodType:
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
		case SOAP_TYPE_ds__KeyValueType:
			return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
		case SOAP_TYPE_ds__DigestMethodType:
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
		case SOAP_TYPE_ds__TransformType:
			return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
		case SOAP_TYPE_ds__TransformsType:
			return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
		case SOAP_TYPE_ds__ReferenceType:
			return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
		case SOAP_TYPE_ds__SignatureMethodType:
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
		case SOAP_TYPE_ds__CanonicalizationMethodType:
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
		case SOAP_TYPE_ds__KeyInfoType:
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
		case SOAP_TYPE_ds__SignedInfoType:
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
		case SOAP_TYPE_ds__SignatureType:
			return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
		case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentResponseType:
			return soap_in_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, "bes:GetFactoryAttributesDocumentResponseType");
		case SOAP_TYPE_PointerTobes__GetActivityDocumentsResponseType:
			return soap_in_PointerTobes__GetActivityDocumentsResponseType(soap, NULL, NULL, "bes:GetActivityDocumentsResponseType");
		case SOAP_TYPE_PointerTobes__TerminateActivitiesResponseType:
			return soap_in_PointerTobes__TerminateActivitiesResponseType(soap, NULL, NULL, "bes:TerminateActivitiesResponseType");
		case SOAP_TYPE_PointerTobes__GetActivityStatusesResponseType:
			return soap_in_PointerTobes__GetActivityStatusesResponseType(soap, NULL, NULL, "bes:GetActivityStatusesResponseType");
		case SOAP_TYPE_PointerTobes__CreateActivityResponseType:
			return soap_in_PointerTobes__CreateActivityResponseType(soap, NULL, NULL, "bes:CreateActivityResponseType");
		case SOAP_TYPE_PointerTobes__CreateActivityType:
			return soap_in_PointerTobes__CreateActivityType(soap, NULL, NULL, "bes:CreateActivityType");
		case SOAP_TYPE_PointerTobes__UnsupportedFeatureFaultType:
			return soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, NULL, NULL, "bes:UnsupportedFeatureFaultType");
		case SOAP_TYPE_PointerTobes__NotAuthorizedFaultType:
			return soap_in_PointerTobes__NotAuthorizedFaultType(soap, NULL, NULL, "bes:NotAuthorizedFaultType");
		case SOAP_TYPE_PointerTobes__NotAcceptingNewActivitiesFaultType:
			return soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, "bes:NotAcceptingNewActivitiesFaultType");
		case SOAP_TYPE_PointerTobes__InvalidRequestMessageFaultType:
			return soap_in_PointerTobes__InvalidRequestMessageFaultType(soap, NULL, NULL, "bes:InvalidRequestMessageFaultType");
		case SOAP_TYPE_PointerTo_wsa__FaultTo:
			return soap_in_PointerTo_wsa__FaultTo(soap, NULL, NULL, "wsa:FaultTo");
		case SOAP_TYPE_PointerTo_wsa__ReplyTo:
			return soap_in_PointerTo_wsa__ReplyTo(soap, NULL, NULL, "wsa:ReplyTo");
		case SOAP_TYPE_PointerTo_wsa__From:
			return soap_in_PointerTo_wsa__From(soap, NULL, NULL, "wsa:From");
		case SOAP_TYPE_PointerTo_wsa__RelatesTo:
			return soap_in_PointerTo_wsa__RelatesTo(soap, NULL, NULL, "wsa:RelatesTo");
		case SOAP_TYPE_PointerTo_wsse__Security:
			return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
		case SOAP_TYPE_PointerTojsdl_hpcpa__UserName_USCOREType:
			return soap_in_PointerTojsdl_hpcpa__UserName_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:UserName_Type");
		case SOAP_TYPE_PointerTojsdl_hpcpa__Environment_USCOREType:
			return soap_in_PointerTojsdl_hpcpa__Environment_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:Environment_Type");
		case SOAP_TYPE_PointerTojsdl_hpcpa__DirectoryName_USCOREType:
			return soap_in_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:DirectoryName_Type");
		case SOAP_TYPE_PointerTojsdl_hpcpa__Argument_USCOREType:
			return soap_in_PointerTojsdl_hpcpa__Argument_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:Argument_Type");
		case SOAP_TYPE_PointerTojsdl_hpcpa__FileName_USCOREType:
			return soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, NULL, NULL, "jsdl-hpcpa:FileName_Type");
		case SOAP_TYPE_PointerTojsdl_posix__GroupName_USCOREType:
			return soap_in_PointerTojsdl_posix__GroupName_USCOREType(soap, NULL, NULL, "jsdl-posix:GroupName_Type");
		case SOAP_TYPE_PointerTojsdl_posix__UserName_USCOREType:
			return soap_in_PointerTojsdl_posix__UserName_USCOREType(soap, NULL, NULL, "jsdl-posix:UserName_Type");
		case SOAP_TYPE_PointerTojsdl_posix__Limits_USCOREType:
			return soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, NULL, NULL, "jsdl-posix:Limits_Type");
		case SOAP_TYPE_PointerTojsdl_posix__Environment_USCOREType:
			return soap_in_PointerTojsdl_posix__Environment_USCOREType(soap, NULL, NULL, "jsdl-posix:Environment_Type");
		case SOAP_TYPE_PointerTojsdl_posix__DirectoryName_USCOREType:
			return soap_in_PointerTojsdl_posix__DirectoryName_USCOREType(soap, NULL, NULL, "jsdl-posix:DirectoryName_Type");
		case SOAP_TYPE_PointerTojsdl_posix__Argument_USCOREType:
			return soap_in_PointerTojsdl_posix__Argument_USCOREType(soap, NULL, NULL, "jsdl-posix:Argument_Type");
		case SOAP_TYPE_PointerTojsdl_posix__FileName_USCOREType:
			return soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, NULL, NULL, "jsdl-posix:FileName_Type");
		case SOAP_TYPE_PointerTohpcp_af__NodeStatusType:
			return soap_in_PointerTohpcp_af__NodeStatusType(soap, NULL, NULL, "hpcp-af:NodeStatusType");
		case SOAP_TYPE_PointerTohpcp_af__ActivityIdType:
			return soap_in_PointerTohpcp_af__ActivityIdType(soap, NULL, NULL, "hpcp-af:ActivityIdType");
		case SOAP_TYPE_PointerTohpcp_af__CPUType:
			return soap_in_PointerTohpcp_af__CPUType(soap, NULL, NULL, "hpcp-af:CPUType");
		case SOAP_TYPE_PointerTohpcp_af__MemoryType:
			return soap_in_PointerTohpcp_af__MemoryType(soap, NULL, NULL, "hpcp-af:MemoryType");
		case SOAP_TYPE_PointerTohpcp_af__DateTimeRangeType:
			return soap_in_PointerTohpcp_af__DateTimeRangeType(soap, NULL, NULL, "hpcp-af:DateTimeRangeType");
		case SOAP_TYPE_PointerTohpcp_af__ActivityIdRangeType:
			return soap_in_PointerTohpcp_af__ActivityIdRangeType(soap, NULL, NULL, "hpcp-af:ActivityIdRangeType");
		case SOAP_TYPE_PointerTobes__ActivityStateEnumeration:
			return soap_in_PointerTobes__ActivityStateEnumeration(soap, NULL, NULL, "bes:ActivityStateEnumeration");
		case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
			return soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
		case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
			return soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
		case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
			return soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
		case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
			return soap_in_PointerTojsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
		case SOAP_TYPE_PointerToxsd__boolean:
			return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
		case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
			return soap_in_PointerTojsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
		case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
			return soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
		case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
			return soap_in_PointerTojsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
		case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
			return soap_in_PointerTojsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
		case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
			return soap_in_PointerTojsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
		case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
			return soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
		case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
			return soap_in_PointerTojsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
		case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
			return soap_in_PointerTojsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
		case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
			return soap_in_PointerTojsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
		case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
			return soap_in_PointerTojsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
		case SOAP_TYPE_PointerTowsa__MetadataType:
			return soap_in_PointerTowsa__MetadataType(soap, NULL, NULL, "wsa:MetadataType");
		case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
			return soap_in_PointerTowsa__ReferenceParametersType(soap, NULL, NULL, "wsa:ReferenceParametersType");
		case SOAP_TYPE_PointerTowsa__AttributedURIType:
			return soap_in_PointerTowsa__AttributedURIType(soap, NULL, NULL, "wsa:AttributedURIType");
		case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
			return soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
		case SOAP_TYPE_PointerTohpcp_af__AdvancedFilterType:
			return soap_in_PointerTohpcp_af__AdvancedFilterType(soap, NULL, NULL, "hpcp-af:AdvancedFilterType");
		case SOAP_TYPE_PointerToxsd__anyURI:
			return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
			return soap_in_PointerTowsa__EndpointReferenceType(soap, NULL, NULL, "wsa:EndpointReferenceType");
		case SOAP_TYPE_PointerTobes__BasicResourceAttributesDocumentType:
			return soap_in_PointerTobes__BasicResourceAttributesDocumentType(soap, NULL, NULL, "bes:BasicResourceAttributesDocumentType");
		case SOAP_TYPE_PointerTodouble:
			return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
		case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
			return soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
		case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
			return soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
		case SOAP_TYPE_PointerTobes__ActivityStatusType:
			return soap_in_PointerTobes__ActivityStatusType(soap, NULL, NULL, "bes:ActivityStatusType");
		case SOAP_TYPE_PointerTostring:
			return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
		case SOAP_TYPE_jsdl__Description_USCOREType:
			{	char **s;
				s = soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_wsa__FaultCodesOpenEnumType:
			{	char **s;
				s = soap_in_wsa__FaultCodesOpenEnumType(soap, NULL, NULL, "wsa:FaultCodesOpenEnumType");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_wsa__RelationshipTypeOpenEnum:
			{	char **s;
				s = soap_in_wsa__RelationshipTypeOpenEnum(soap, NULL, NULL, "wsa:RelationshipTypeOpenEnum");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_PointerToxsd__anyType:
			return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
		case SOAP_TYPE_xsd__normalizedString:
			{	char **s;
				s = soap_in_xsd__normalizedString(soap, NULL, NULL, "xsd:normalizedString");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_xsd__nonNegativeInteger:
			{	char **s;
				s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_xsd__anyURI:
			{	char **s;
				s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_xsd__QName:
			{	char **s;
				s = soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_xsd__NCName:
			{	char **s;
				s = soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_xsd__ID:
			{	char **s;
				s = soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_PointerTods__SignatureType:
			return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
		case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
			return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
		case SOAP_TYPE_PointerTo_wsse__UsernameToken:
			return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
		case SOAP_TYPE_PointerTo_wsu__Timestamp:
			return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
		case SOAP_TYPE_PointerTods__X509IssuerSerialType:
			return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
		case SOAP_TYPE_PointerTods__RSAKeyValueType:
			return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
		case SOAP_TYPE_PointerTods__DSAKeyValueType:
			return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
		case SOAP_TYPE_PointerTods__TransformType:
			return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
		case SOAP_TYPE_PointerTods__DigestMethodType:
			return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
		case SOAP_TYPE_PointerTods__TransformsType:
			return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
		case SOAP_TYPE_PointerToint:
			return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
		case SOAP_TYPE_PointerToPointerTods__ReferenceType:
			return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
		case SOAP_TYPE_PointerTods__ReferenceType:
			return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
		case SOAP_TYPE_PointerTods__SignatureMethodType:
			return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
		case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
			return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
		case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
			return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
		case SOAP_TYPE_PointerTods__X509DataType:
			return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
		case SOAP_TYPE_PointerTods__RetrievalMethodType:
			return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
		case SOAP_TYPE_PointerTods__KeyValueType:
			return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
		case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
			return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
		case SOAP_TYPE_PointerTods__KeyInfoType:
			return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
		case SOAP_TYPE_PointerTods__SignedInfoType:
			return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
		case SOAP_TYPE_PointerTo_wsse__Embedded:
			return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
		case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
			return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
		case SOAP_TYPE_PointerTo_wsse__Reference:
			return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
		case SOAP_TYPE_PointerTo_wsse__Password:
			return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
		case SOAP_TYPE_string:
			{	char **s;
				s = soap_in_string(soap, NULL, NULL, "xsd:string");
				return s ? *s : NULL;
			}
		default:
			{	const char *t = soap->type;
				if (!*t)
					t = soap->tag;
				if (!soap_match_tag(soap, t, "xsd:byte")) {
					*type = SOAP_TYPE_byte;
					return soap_in_byte(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "xsd:int")) {
					*type = SOAP_TYPE_int;
					return soap_in_int(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "xsd:long")) {
					*type = SOAP_TYPE_LONG64;
					return soap_in_LONG64(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "xsd:double")) {
					*type = SOAP_TYPE_double;
					return soap_in_double(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "xsd:unsignedLong")) {
					*type = SOAP_TYPE_unsignedLONG64;
					return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "xsd:dateTime")) {
					*type = SOAP_TYPE_time;
					return soap_in_time(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:CreationFlagEnumeration")) {
					*type = SOAP_TYPE_jsdl__CreationFlagEnumeration;
					return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:FileSystemTypeEnumeration")) {
					*type = SOAP_TYPE_jsdl__FileSystemTypeEnumeration;
					return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:OperatingSystemTypeEnumeration")) {
					*type = SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration;
					return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:ProcessorArchitectureEnumeration")) {
					*type = SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration;
					return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:FaultCodesType")) {
					*type = SOAP_TYPE_wsa__FaultCodesType;
					return soap_in_wsa__FaultCodesType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:RelationshipType")) {
					*type = SOAP_TYPE_wsa__RelationshipType;
					return soap_in_wsa__RelationshipType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:ActivityStateEnumeration")) {
					*type = SOAP_TYPE_bes__ActivityStateEnumeration;
					return soap_in_bes__ActivityStateEnumeration(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "xsd:boolean")) {
					*type = SOAP_TYPE_xsd__boolean;
					return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum")) {
					*type = SOAP_TYPE_wsse__FaultcodeEnum;
					return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsu:tTimestampFault")) {
					*type = SOAP_TYPE_wsu__tTimestampFault;
					return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:HPCProfileApplication_Type")) {
					*type = SOAP_TYPE_jsdl_hpcpa__HPCProfileApplication_USCOREType;
					return soap_in_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:UserName_Type")) {
					*type = SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType;
					return soap_in_jsdl_hpcpa__UserName_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:DirectoryName_Type")) {
					*type = SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType;
					return soap_in_jsdl_hpcpa__DirectoryName_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:FileName_Type")) {
					*type = SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType;
					return soap_in_jsdl_hpcpa__FileName_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:Argument_Type")) {
					*type = SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType;
					return soap_in_jsdl_hpcpa__Argument_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:Environment_Type")) {
					*type = SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType;
					return soap_in_jsdl_hpcpa__Environment_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:POSIXApplication_Type")) {
					*type = SOAP_TYPE_jsdl_posix__POSIXApplication_USCOREType;
					return soap_in_jsdl_posix__POSIXApplication_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:GroupName_Type")) {
					*type = SOAP_TYPE_jsdl_posix__GroupName_USCOREType;
					return soap_in_jsdl_posix__GroupName_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:UserName_Type")) {
					*type = SOAP_TYPE_jsdl_posix__UserName_USCOREType;
					return soap_in_jsdl_posix__UserName_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Limits_Type")) {
					*type = SOAP_TYPE_jsdl_posix__Limits_USCOREType;
					return soap_in_jsdl_posix__Limits_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:DirectoryName_Type")) {
					*type = SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType;
					return soap_in_jsdl_posix__DirectoryName_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:FileName_Type")) {
					*type = SOAP_TYPE_jsdl_posix__FileName_USCOREType;
					return soap_in_jsdl_posix__FileName_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Argument_Type")) {
					*type = SOAP_TYPE_jsdl_posix__Argument_USCOREType;
					return soap_in_jsdl_posix__Argument_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Environment_Type")) {
					*type = SOAP_TYPE_jsdl_posix__Environment_USCOREType;
					return soap_in_jsdl_posix__Environment_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:DynamicNodeStatusType")) {
					*type = SOAP_TYPE_hpcp_af__DynamicNodeStatusType;
					return soap_in_hpcp_af__DynamicNodeStatusType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:ActivityIdType")) {
					*type = SOAP_TYPE_hpcp_af__ActivityIdType;
					return soap_in_hpcp_af__ActivityIdType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:CPUType")) {
					*type = SOAP_TYPE_hpcp_af__CPUType;
					return soap_in_hpcp_af__CPUType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:MemoryType")) {
					*type = SOAP_TYPE_hpcp_af__MemoryType;
					return soap_in_hpcp_af__MemoryType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:NodeStatusType")) {
					*type = SOAP_TYPE_hpcp_af__NodeStatusType;
					return soap_in_hpcp_af__NodeStatusType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:ActivityIdRangeType")) {
					*type = SOAP_TYPE_hpcp_af__ActivityIdRangeType;
					return soap_in_hpcp_af__ActivityIdRangeType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:DateTimeRangeType")) {
					*type = SOAP_TYPE_hpcp_af__DateTimeRangeType;
					return soap_in_hpcp_af__DateTimeRangeType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:AdvancedFilterType")) {
					*type = SOAP_TYPE_hpcp_af__AdvancedFilterType;
					return soap_in_hpcp_af__AdvancedFilterType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:SourceTarget_Type")) {
					*type = SOAP_TYPE_jsdl__SourceTarget_USCOREType;
					return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:DataStaging_Type")) {
					*type = SOAP_TYPE_jsdl__DataStaging_USCOREType;
					return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:OperatingSystemType_Type")) {
					*type = SOAP_TYPE_jsdl__OperatingSystemType_USCOREType;
					return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:OperatingSystem_Type")) {
					*type = SOAP_TYPE_jsdl__OperatingSystem_USCOREType;
					return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:FileSystem_Type")) {
					*type = SOAP_TYPE_jsdl__FileSystem_USCOREType;
					return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:CPUArchitecture_Type")) {
					*type = SOAP_TYPE_jsdl__CPUArchitecture_USCOREType;
					return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:CandidateHosts_Type")) {
					*type = SOAP_TYPE_jsdl__CandidateHosts_USCOREType;
					return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Resources_Type")) {
					*type = SOAP_TYPE_jsdl__Resources_USCOREType;
					return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Application_Type")) {
					*type = SOAP_TYPE_jsdl__Application_USCOREType;
					return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:JobIdentification_Type")) {
					*type = SOAP_TYPE_jsdl__JobIdentification_USCOREType;
					return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:JobDescription_Type")) {
					*type = SOAP_TYPE_jsdl__JobDescription_USCOREType;
					return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:JobDefinition_Type")) {
					*type = SOAP_TYPE_jsdl__JobDefinition_USCOREType;
					return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:RangeValue_Type")) {
					*type = SOAP_TYPE_jsdl__RangeValue_USCOREType;
					return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Range_Type")) {
					*type = SOAP_TYPE_jsdl__Range_USCOREType;
					return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Exact_Type")) {
					*type = SOAP_TYPE_jsdl__Exact_USCOREType;
					return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Boundary_Type")) {
					*type = SOAP_TYPE_jsdl__Boundary_USCOREType;
					return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:ProblemActionType")) {
					*type = SOAP_TYPE_wsa__ProblemActionType;
					return soap_in_wsa__ProblemActionType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:AttributedQNameType")) {
					*type = SOAP_TYPE_wsa__AttributedQNameType;
					return soap_in_wsa__AttributedQNameType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:AttributedUnsignedLongType")) {
					*type = SOAP_TYPE_wsa__AttributedUnsignedLongType;
					return soap_in_wsa__AttributedUnsignedLongType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:AttributedURIType")) {
					*type = SOAP_TYPE_wsa__AttributedURIType;
					return soap_in_wsa__AttributedURIType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:RelatesToType")) {
					*type = SOAP_TYPE_wsa__RelatesToType;
					return soap_in_wsa__RelatesToType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:MetadataType")) {
					*type = SOAP_TYPE_wsa__MetadataType;
					return soap_in_wsa__MetadataType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:ReferenceParametersType")) {
					*type = SOAP_TYPE_wsa__ReferenceParametersType;
					return soap_in_wsa__ReferenceParametersType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:EndpointReferenceType")) {
					*type = SOAP_TYPE_wsa__EndpointReferenceType;
					return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:TerminateActivityResponseType")) {
					*type = SOAP_TYPE_bes__TerminateActivityResponseType;
					return soap_in_bes__TerminateActivityResponseType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityDocumentResponseType")) {
					*type = SOAP_TYPE_bes__GetActivityDocumentResponseType;
					return soap_in_bes__GetActivityDocumentResponseType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityStatusResponseType")) {
					*type = SOAP_TYPE_bes__GetActivityStatusResponseType;
					return soap_in_bes__GetActivityStatusResponseType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:ActivityStatusType")) {
					*type = SOAP_TYPE_bes__ActivityStatusType;
					return soap_in_bes__ActivityStatusType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:ActivityDocumentType")) {
					*type = SOAP_TYPE_bes__ActivityDocumentType;
					return soap_in_bes__ActivityDocumentType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:FactoryResourceAttributesDocumentType")) {
					*type = SOAP_TYPE_bes__FactoryResourceAttributesDocumentType;
					return soap_in_bes__FactoryResourceAttributesDocumentType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:BasicResourceAttributesDocumentType")) {
					*type = SOAP_TYPE_bes__BasicResourceAttributesDocumentType;
					return soap_in_bes__BasicResourceAttributesDocumentType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:InvalidRequestMessageFaultType")) {
					*type = SOAP_TYPE_bes__InvalidRequestMessageFaultType;
					return soap_in_bes__InvalidRequestMessageFaultType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:InvalidActivityIdentifierFaultType")) {
					*type = SOAP_TYPE_bes__InvalidActivityIdentifierFaultType;
					return soap_in_bes__InvalidActivityIdentifierFaultType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:OperationWillBeAppliedEventuallyFaultType")) {
					*type = SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType;
					return soap_in_bes__OperationWillBeAppliedEventuallyFaultType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:CantApplyOperationToCurrentStateFaultType")) {
					*type = SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType;
					return soap_in_bes__CantApplyOperationToCurrentStateFaultType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:UnsupportedFeatureFaultType")) {
					*type = SOAP_TYPE_bes__UnsupportedFeatureFaultType;
					return soap_in_bes__UnsupportedFeatureFaultType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:NotAcceptingNewActivitiesFaultType")) {
					*type = SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType;
					return soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:NotAuthorizedFaultType")) {
					*type = SOAP_TYPE_bes__NotAuthorizedFaultType;
					return soap_in_bes__NotAuthorizedFaultType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetFactoryAttributesDocumentResponseType")) {
					*type = SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType;
					return soap_in_bes__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetFactoryAttributesDocumentType")) {
					*type = SOAP_TYPE_bes__GetFactoryAttributesDocumentType;
					return soap_in_bes__GetFactoryAttributesDocumentType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityDocumentsResponseType")) {
					*type = SOAP_TYPE_bes__GetActivityDocumentsResponseType;
					return soap_in_bes__GetActivityDocumentsResponseType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityDocumentsType")) {
					*type = SOAP_TYPE_bes__GetActivityDocumentsType;
					return soap_in_bes__GetActivityDocumentsType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:TerminateActivitiesResponseType")) {
					*type = SOAP_TYPE_bes__TerminateActivitiesResponseType;
					return soap_in_bes__TerminateActivitiesResponseType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:TerminateActivitiesType")) {
					*type = SOAP_TYPE_bes__TerminateActivitiesType;
					return soap_in_bes__TerminateActivitiesType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityStatusesResponseType")) {
					*type = SOAP_TYPE_bes__GetActivityStatusesResponseType;
					return soap_in_bes__GetActivityStatusesResponseType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityStatusesType")) {
					*type = SOAP_TYPE_bes__GetActivityStatusesType;
					return soap_in_bes__GetActivityStatusesType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:CreateActivityResponseType")) {
					*type = SOAP_TYPE_bes__CreateActivityResponseType;
					return soap_in_bes__CreateActivityResponseType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:CreateActivityType")) {
					*type = SOAP_TYPE_bes__CreateActivityType;
					return soap_in_bes__CreateActivityType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "xsd:anyType")) {
					*type = SOAP_TYPE_xsd__anyType;
					return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:RSAKeyValueType")) {
					*type = SOAP_TYPE_ds__RSAKeyValueType;
					return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:DSAKeyValueType")) {
					*type = SOAP_TYPE_ds__DSAKeyValueType;
					return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType")) {
					*type = SOAP_TYPE_ds__X509IssuerSerialType;
					return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:X509DataType")) {
					*type = SOAP_TYPE_ds__X509DataType;
					return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:RetrievalMethodType")) {
					*type = SOAP_TYPE_ds__RetrievalMethodType;
					return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:KeyValueType")) {
					*type = SOAP_TYPE_ds__KeyValueType;
					return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:DigestMethodType")) {
					*type = SOAP_TYPE_ds__DigestMethodType;
					return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:TransformType")) {
					*type = SOAP_TYPE_ds__TransformType;
					return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:TransformsType")) {
					*type = SOAP_TYPE_ds__TransformsType;
					return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:ReferenceType")) {
					*type = SOAP_TYPE_ds__ReferenceType;
					return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:SignatureMethodType")) {
					*type = SOAP_TYPE_ds__SignatureMethodType;
					return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType")) {
					*type = SOAP_TYPE_ds__CanonicalizationMethodType;
					return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:KeyInfoType")) {
					*type = SOAP_TYPE_ds__KeyInfoType;
					return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:SignedInfoType")) {
					*type = SOAP_TYPE_ds__SignedInfoType;
					return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "ds:SignatureType")) {
					*type = SOAP_TYPE_ds__SignatureType;
					return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Description_Type")) {
					char **s;
					*type = SOAP_TYPE_jsdl__Description_USCOREType;
					s = soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "wsa:FaultCodesOpenEnumType")) {
					char **s;
					*type = SOAP_TYPE_wsa__FaultCodesOpenEnumType;
					s = soap_in_wsa__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "wsa:RelationshipTypeOpenEnum")) {
					char **s;
					*type = SOAP_TYPE_wsa__RelationshipTypeOpenEnum;
					s = soap_in_wsa__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "xsd:normalizedString")) {
					char **s;
					*type = SOAP_TYPE_xsd__normalizedString;
					s = soap_in_xsd__normalizedString(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger")) {
					char **s;
					*type = SOAP_TYPE_xsd__nonNegativeInteger;
					s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "xsd:anyURI")) {
					char **s;
					*type = SOAP_TYPE_xsd__anyURI;
					s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "xsd:QName")) {
					char **s;
					*type = SOAP_TYPE_xsd__QName;
					s = soap_in_xsd__QName(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "xsd:NCName")) {
					char **s;
					*type = SOAP_TYPE_xsd__NCName;
					s = soap_in_xsd__NCName(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "xsd:ID")) {
					char **s;
					*type = SOAP_TYPE_xsd__ID;
					s = soap_in_xsd__ID(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "xsd:string")) {
					char **s;
					*type = SOAP_TYPE_string;
					s = soap_in_string(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				t = soap->tag;
				if (!soap_match_tag(soap, t, "jsdl:DeleteOnTermination")) {
					*type = SOAP_TYPE__jsdl__DeleteOnTermination;
					return soap_in__jsdl__DeleteOnTermination(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:CreationFlag")) {
					*type = SOAP_TYPE__jsdl__CreationFlag;
					return soap_in__jsdl__CreationFlag(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:FileSystemType")) {
					*type = SOAP_TYPE__jsdl__FileSystemType;
					return soap_in__jsdl__FileSystemType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:CPUArchitectureName")) {
					*type = SOAP_TYPE__jsdl__CPUArchitectureName;
					return soap_in__jsdl__CPUArchitectureName(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:ExclusiveExecution")) {
					*type = SOAP_TYPE__jsdl__ExclusiveExecution;
					return soap_in__jsdl__ExclusiveExecution(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:OperatingSystemName")) {
					*type = SOAP_TYPE__jsdl__OperatingSystemName;
					return soap_in__jsdl__OperatingSystemName(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:IsReferenceParameter")) {
					*type = SOAP_TYPE__wsa__IsReferenceParameter;
					return soap_in__wsa__IsReferenceParameter(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:UserName")) {
					*type = SOAP_TYPE__jsdl_hpcpa__UserName;
					return soap_in__jsdl_hpcpa__UserName(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:Environment")) {
					*type = SOAP_TYPE__jsdl_hpcpa__Environment;
					return soap_in__jsdl_hpcpa__Environment(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:WorkingDirectory")) {
					*type = SOAP_TYPE__jsdl_hpcpa__WorkingDirectory;
					return soap_in__jsdl_hpcpa__WorkingDirectory(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:Error")) {
					*type = SOAP_TYPE__jsdl_hpcpa__Error;
					return soap_in__jsdl_hpcpa__Error(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:Output")) {
					*type = SOAP_TYPE__jsdl_hpcpa__Output;
					return soap_in__jsdl_hpcpa__Output(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:Input")) {
					*type = SOAP_TYPE__jsdl_hpcpa__Input;
					return soap_in__jsdl_hpcpa__Input(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:Argument")) {
					*type = SOAP_TYPE__jsdl_hpcpa__Argument;
					return soap_in__jsdl_hpcpa__Argument(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:Executable")) {
					*type = SOAP_TYPE__jsdl_hpcpa__Executable;
					return soap_in__jsdl_hpcpa__Executable(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-hpcpa:HPCProfileApplication")) {
					*type = SOAP_TYPE__jsdl_hpcpa__HPCProfileApplication;
					return soap_in__jsdl_hpcpa__HPCProfileApplication(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:GroupName")) {
					*type = SOAP_TYPE__jsdl_posix__GroupName;
					return soap_in__jsdl_posix__GroupName(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:UserName")) {
					*type = SOAP_TYPE__jsdl_posix__UserName;
					return soap_in__jsdl_posix__UserName(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:ThreadCountLimit")) {
					*type = SOAP_TYPE__jsdl_posix__ThreadCountLimit;
					return soap_in__jsdl_posix__ThreadCountLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:VirtualMemoryLimit")) {
					*type = SOAP_TYPE__jsdl_posix__VirtualMemoryLimit;
					return soap_in__jsdl_posix__VirtualMemoryLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:ProcessCountLimit")) {
					*type = SOAP_TYPE__jsdl_posix__ProcessCountLimit;
					return soap_in__jsdl_posix__ProcessCountLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:CPUTimeLimit")) {
					*type = SOAP_TYPE__jsdl_posix__CPUTimeLimit;
					return soap_in__jsdl_posix__CPUTimeLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:StackSizeLimit")) {
					*type = SOAP_TYPE__jsdl_posix__StackSizeLimit;
					return soap_in__jsdl_posix__StackSizeLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:PipeSizeLimit")) {
					*type = SOAP_TYPE__jsdl_posix__PipeSizeLimit;
					return soap_in__jsdl_posix__PipeSizeLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:OpenDescriptorsLimit")) {
					*type = SOAP_TYPE__jsdl_posix__OpenDescriptorsLimit;
					return soap_in__jsdl_posix__OpenDescriptorsLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:MemoryLimit")) {
					*type = SOAP_TYPE__jsdl_posix__MemoryLimit;
					return soap_in__jsdl_posix__MemoryLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:LockedMemoryLimit")) {
					*type = SOAP_TYPE__jsdl_posix__LockedMemoryLimit;
					return soap_in__jsdl_posix__LockedMemoryLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:DataSegmentLimit")) {
					*type = SOAP_TYPE__jsdl_posix__DataSegmentLimit;
					return soap_in__jsdl_posix__DataSegmentLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:CoreDumpLimit")) {
					*type = SOAP_TYPE__jsdl_posix__CoreDumpLimit;
					return soap_in__jsdl_posix__CoreDumpLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:FileSizeLimit")) {
					*type = SOAP_TYPE__jsdl_posix__FileSizeLimit;
					return soap_in__jsdl_posix__FileSizeLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:WallTimeLimit")) {
					*type = SOAP_TYPE__jsdl_posix__WallTimeLimit;
					return soap_in__jsdl_posix__WallTimeLimit(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Environment")) {
					*type = SOAP_TYPE__jsdl_posix__Environment;
					return soap_in__jsdl_posix__Environment(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:WorkingDirectory")) {
					*type = SOAP_TYPE__jsdl_posix__WorkingDirectory;
					return soap_in__jsdl_posix__WorkingDirectory(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Error")) {
					*type = SOAP_TYPE__jsdl_posix__Error;
					return soap_in__jsdl_posix__Error(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Output")) {
					*type = SOAP_TYPE__jsdl_posix__Output;
					return soap_in__jsdl_posix__Output(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Input")) {
					*type = SOAP_TYPE__jsdl_posix__Input;
					return soap_in__jsdl_posix__Input(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Argument")) {
					*type = SOAP_TYPE__jsdl_posix__Argument;
					return soap_in__jsdl_posix__Argument(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:Executable")) {
					*type = SOAP_TYPE__jsdl_posix__Executable;
					return soap_in__jsdl_posix__Executable(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl-posix:POSIXApplication")) {
					*type = SOAP_TYPE__jsdl_posix__POSIXApplication;
					return soap_in__jsdl_posix__POSIXApplication(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "hpcp-af:AdvancedFilter")) {
					*type = SOAP_TYPE__hpcp_af__AdvancedFilter;
					return soap_in__hpcp_af__AdvancedFilter(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Target")) {
					*type = SOAP_TYPE__jsdl__Target;
					return soap_in__jsdl__Target(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Source")) {
					*type = SOAP_TYPE__jsdl__Source;
					return soap_in__jsdl__Source(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:DataStaging")) {
					*type = SOAP_TYPE__jsdl__DataStaging;
					return soap_in__jsdl__DataStaging(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:TotalResourceCount")) {
					*type = SOAP_TYPE__jsdl__TotalResourceCount;
					return soap_in__jsdl__TotalResourceCount(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:TotalDiskSpace")) {
					*type = SOAP_TYPE__jsdl__TotalDiskSpace;
					return soap_in__jsdl__TotalDiskSpace(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:TotalVirtualMemory")) {
					*type = SOAP_TYPE__jsdl__TotalVirtualMemory;
					return soap_in__jsdl__TotalVirtualMemory(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:TotalPhysicalMemory")) {
					*type = SOAP_TYPE__jsdl__TotalPhysicalMemory;
					return soap_in__jsdl__TotalPhysicalMemory(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:TotalCPUCount")) {
					*type = SOAP_TYPE__jsdl__TotalCPUCount;
					return soap_in__jsdl__TotalCPUCount(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:TotalCPUTime")) {
					*type = SOAP_TYPE__jsdl__TotalCPUTime;
					return soap_in__jsdl__TotalCPUTime(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:IndividualDiskSpace")) {
					*type = SOAP_TYPE__jsdl__IndividualDiskSpace;
					return soap_in__jsdl__IndividualDiskSpace(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:IndividualNetworkBandwidth")) {
					*type = SOAP_TYPE__jsdl__IndividualNetworkBandwidth;
					return soap_in__jsdl__IndividualNetworkBandwidth(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:IndividualVirtualMemory")) {
					*type = SOAP_TYPE__jsdl__IndividualVirtualMemory;
					return soap_in__jsdl__IndividualVirtualMemory(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:IndividualPhysicalMemory")) {
					*type = SOAP_TYPE__jsdl__IndividualPhysicalMemory;
					return soap_in__jsdl__IndividualPhysicalMemory(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:IndividualCPUCount")) {
					*type = SOAP_TYPE__jsdl__IndividualCPUCount;
					return soap_in__jsdl__IndividualCPUCount(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:IndividualCPUSpeed")) {
					*type = SOAP_TYPE__jsdl__IndividualCPUSpeed;
					return soap_in__jsdl__IndividualCPUSpeed(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:IndividualCPUTime")) {
					*type = SOAP_TYPE__jsdl__IndividualCPUTime;
					return soap_in__jsdl__IndividualCPUTime(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:DiskSpace")) {
					*type = SOAP_TYPE__jsdl__DiskSpace;
					return soap_in__jsdl__DiskSpace(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:FileSystem")) {
					*type = SOAP_TYPE__jsdl__FileSystem;
					return soap_in__jsdl__FileSystem(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:CPUArchitecture")) {
					*type = SOAP_TYPE__jsdl__CPUArchitecture;
					return soap_in__jsdl__CPUArchitecture(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:OperatingSystemType")) {
					*type = SOAP_TYPE__jsdl__OperatingSystemType;
					return soap_in__jsdl__OperatingSystemType(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:OperatingSystem")) {
					*type = SOAP_TYPE__jsdl__OperatingSystem;
					return soap_in__jsdl__OperatingSystem(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:CandidateHosts")) {
					*type = SOAP_TYPE__jsdl__CandidateHosts;
					return soap_in__jsdl__CandidateHosts(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Resources")) {
					*type = SOAP_TYPE__jsdl__Resources;
					return soap_in__jsdl__Resources(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:Application")) {
					*type = SOAP_TYPE__jsdl__Application;
					return soap_in__jsdl__Application(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:JobIdentification")) {
					*type = SOAP_TYPE__jsdl__JobIdentification;
					return soap_in__jsdl__JobIdentification(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:JobDescription")) {
					*type = SOAP_TYPE__jsdl__JobDescription;
					return soap_in__jsdl__JobDescription(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:JobDefinition")) {
					*type = SOAP_TYPE__jsdl__JobDefinition;
					return soap_in__jsdl__JobDefinition(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:ProblemAction")) {
					*type = SOAP_TYPE__wsa__ProblemAction;
					return soap_in__wsa__ProblemAction(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:ProblemIRI")) {
					*type = SOAP_TYPE__wsa__ProblemIRI;
					return soap_in__wsa__ProblemIRI(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:ProblemHeaderQName")) {
					*type = SOAP_TYPE__wsa__ProblemHeaderQName;
					return soap_in__wsa__ProblemHeaderQName(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:RetryAfter")) {
					*type = SOAP_TYPE__wsa__RetryAfter;
					return soap_in__wsa__RetryAfter(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:Action")) {
					*type = SOAP_TYPE__wsa__Action;
					return soap_in__wsa__Action(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:To")) {
					*type = SOAP_TYPE__wsa__To;
					return soap_in__wsa__To(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:FaultTo")) {
					*type = SOAP_TYPE__wsa__FaultTo;
					return soap_in__wsa__FaultTo(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:From")) {
					*type = SOAP_TYPE__wsa__From;
					return soap_in__wsa__From(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:ReplyTo")) {
					*type = SOAP_TYPE__wsa__ReplyTo;
					return soap_in__wsa__ReplyTo(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:RelatesTo")) {
					*type = SOAP_TYPE__wsa__RelatesTo;
					return soap_in__wsa__RelatesTo(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:MessageID")) {
					*type = SOAP_TYPE__wsa__MessageID;
					return soap_in__wsa__MessageID(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:Metadata")) {
					*type = SOAP_TYPE__wsa__Metadata;
					return soap_in__wsa__Metadata(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:ReferenceParameters")) {
					*type = SOAP_TYPE__wsa__ReferenceParameters;
					return soap_in__wsa__ReferenceParameters(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsa:EndpointReference")) {
					*type = SOAP_TYPE__wsa__EndpointReference;
					return soap_in__wsa__EndpointReference(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:ActivityStatus")) {
					*type = SOAP_TYPE__bes__ActivityStatus;
					return soap_in__bes__ActivityStatus(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:ActivityDocument")) {
					*type = SOAP_TYPE__bes__ActivityDocument;
					return soap_in__bes__ActivityDocument(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:FactoryResourceAttributesDocument")) {
					*type = SOAP_TYPE__bes__FactoryResourceAttributesDocument;
					return soap_in__bes__FactoryResourceAttributesDocument(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:BasicResourceAttributesDocument")) {
					*type = SOAP_TYPE__bes__BasicResourceAttributesDocument;
					return soap_in__bes__BasicResourceAttributesDocument(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:InvalidRequestMessageFault")) {
					*type = SOAP_TYPE__bes__InvalidRequestMessageFault;
					return soap_in__bes__InvalidRequestMessageFault(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:InvalidActivityIdentifierFault")) {
					*type = SOAP_TYPE__bes__InvalidActivityIdentifierFault;
					return soap_in__bes__InvalidActivityIdentifierFault(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:OperationWillBeAppliedEventuallyFault")) {
					*type = SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault;
					return soap_in__bes__OperationWillBeAppliedEventuallyFault(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:CantApplyOperationToCurrentStateFault")) {
					*type = SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault;
					return soap_in__bes__CantApplyOperationToCurrentStateFault(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:UnsupportedFeatureFault")) {
					*type = SOAP_TYPE__bes__UnsupportedFeatureFault;
					return soap_in__bes__UnsupportedFeatureFault(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:NotAcceptingNewActivitiesFault")) {
					*type = SOAP_TYPE__bes__NotAcceptingNewActivitiesFault;
					return soap_in__bes__NotAcceptingNewActivitiesFault(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:NotAuthorizedFault")) {
					*type = SOAP_TYPE__bes__NotAuthorizedFault;
					return soap_in__bes__NotAuthorizedFault(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetFactoryAttributesDocumentResponse")) {
					*type = SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse;
					return soap_in__bes__GetFactoryAttributesDocumentResponse(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetFactoryAttributesDocument")) {
					*type = SOAP_TYPE__bes__GetFactoryAttributesDocument;
					return soap_in__bes__GetFactoryAttributesDocument(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityDocumentsResponse")) {
					*type = SOAP_TYPE__bes__GetActivityDocumentsResponse;
					return soap_in__bes__GetActivityDocumentsResponse(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityDocuments")) {
					*type = SOAP_TYPE__bes__GetActivityDocuments;
					return soap_in__bes__GetActivityDocuments(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:TerminateActivitiesResponse")) {
					*type = SOAP_TYPE__bes__TerminateActivitiesResponse;
					return soap_in__bes__TerminateActivitiesResponse(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:TerminateActivities")) {
					*type = SOAP_TYPE__bes__TerminateActivities;
					return soap_in__bes__TerminateActivities(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityStatusesResponse")) {
					*type = SOAP_TYPE__bes__GetActivityStatusesResponse;
					return soap_in__bes__GetActivityStatusesResponse(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:GetActivityStatuses")) {
					*type = SOAP_TYPE__bes__GetActivityStatuses;
					return soap_in__bes__GetActivityStatuses(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:CreateActivityResponse")) {
					*type = SOAP_TYPE__bes__CreateActivityResponse;
					return soap_in__bes__CreateActivityResponse(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "bes:CreateActivity")) {
					*type = SOAP_TYPE__bes__CreateActivity;
					return soap_in__bes__CreateActivity(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:Security")) {
					*type = SOAP_TYPE__wsse__Security;
					return soap_in__wsse__Security(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces")) {
					*type = SOAP_TYPE__c14n__InclusiveNamespaces;
					return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference")) {
					*type = SOAP_TYPE__wsse__SecurityTokenReference;
					return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:KeyIdentifier")) {
					*type = SOAP_TYPE__wsse__KeyIdentifier;
					return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:Embedded")) {
					*type = SOAP_TYPE__wsse__Embedded;
					return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:Reference")) {
					*type = SOAP_TYPE__wsse__Reference;
					return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken")) {
					*type = SOAP_TYPE__wsse__BinarySecurityToken;
					return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:Password")) {
					*type = SOAP_TYPE__wsse__Password;
					return soap_in__wsse__Password(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsse:UsernameToken")) {
					*type = SOAP_TYPE__wsse__UsernameToken;
					return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "wsu:Timestamp")) {
					*type = SOAP_TYPE__wsu__Timestamp;
					return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soap, t, "jsdl:URI")) {
					char **s;
					*type = SOAP_TYPE__jsdl__URI;
					s = soap_in__jsdl__URI(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:FilesystemName")) {
					char **s;
					*type = SOAP_TYPE__jsdl__FilesystemName;
					s = soap_in__jsdl__FilesystemName(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:FileName")) {
					char **s;
					*type = SOAP_TYPE__jsdl__FileName;
					s = soap_in__jsdl__FileName(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:MountPoint")) {
					char **s;
					*type = SOAP_TYPE__jsdl__MountPoint;
					s = soap_in__jsdl__MountPoint(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:OperatingSystemVersion")) {
					char **s;
					*type = SOAP_TYPE__jsdl__OperatingSystemVersion;
					s = soap_in__jsdl__OperatingSystemVersion(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:HostName")) {
					char **s;
					*type = SOAP_TYPE__jsdl__HostName;
					s = soap_in__jsdl__HostName(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:ApplicationVersion")) {
					char **s;
					*type = SOAP_TYPE__jsdl__ApplicationVersion;
					s = soap_in__jsdl__ApplicationVersion(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:ApplicationName")) {
					char **s;
					*type = SOAP_TYPE__jsdl__ApplicationName;
					s = soap_in__jsdl__ApplicationName(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:JobProject")) {
					char **s;
					*type = SOAP_TYPE__jsdl__JobProject;
					s = soap_in__jsdl__JobProject(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:JobAnnotation")) {
					char **s;
					*type = SOAP_TYPE__jsdl__JobAnnotation;
					s = soap_in__jsdl__JobAnnotation(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:Description")) {
					char **s;
					*type = SOAP_TYPE__jsdl__Description;
					s = soap_in__jsdl__Description(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "jsdl:JobName")) {
					char **s;
					*type = SOAP_TYPE__jsdl__JobName;
					s = soap_in__jsdl__JobName(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soap, t, "xsd:QName")) {
					char **s;
					*type = SOAP_TYPE__QName;
					s = soap_in__QName(soap, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
			}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4
soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap)) {
		int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:")) {
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t)) {
			soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body) {
				soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4
soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4
soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type) {
		case SOAP_TYPE_byte:
			return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
		case SOAP_TYPE_int:
			return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
		case SOAP_TYPE_LONG64:
			return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
		case SOAP_TYPE_double:
			return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
		case SOAP_TYPE_unsignedLONG64:
			return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
		case SOAP_TYPE_time:
			return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
		case SOAP_TYPE__jsdl__DeleteOnTermination:
			return soap_out__jsdl__DeleteOnTermination(soap, "jsdl:DeleteOnTermination", id, (const enum xsd__boolean *)ptr, NULL);
		case SOAP_TYPE__jsdl__CreationFlag:
			return soap_out__jsdl__CreationFlag(soap, "jsdl:CreationFlag", id, (const enum jsdl__CreationFlagEnumeration *)ptr, NULL);
		case SOAP_TYPE__jsdl__FileSystemType:
			return soap_out__jsdl__FileSystemType(soap, "jsdl:FileSystemType", id, (const enum jsdl__FileSystemTypeEnumeration *)ptr, NULL);
		case SOAP_TYPE__jsdl__CPUArchitectureName:
			return soap_out__jsdl__CPUArchitectureName(soap, "jsdl:CPUArchitectureName", id, (const enum jsdl__ProcessorArchitectureEnumeration *)ptr, NULL);
		case SOAP_TYPE__jsdl__ExclusiveExecution:
			return soap_out__jsdl__ExclusiveExecution(soap, "jsdl:ExclusiveExecution", id, (const enum xsd__boolean *)ptr, NULL);
		case SOAP_TYPE__jsdl__OperatingSystemName:
			return soap_out__jsdl__OperatingSystemName(soap, "jsdl:OperatingSystemName", id, (const enum jsdl__OperatingSystemTypeEnumeration *)ptr, NULL);
		case SOAP_TYPE__wsa__IsReferenceParameter:
			return soap_out__wsa__IsReferenceParameter(soap, "wsa:IsReferenceParameter", id, (const enum xsd__boolean *)ptr, NULL);
		case SOAP_TYPE_jsdl__CreationFlagEnumeration:
			return soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, (const enum jsdl__CreationFlagEnumeration *)ptr, "jsdl:CreationFlagEnumeration");
		case SOAP_TYPE_jsdl__FileSystemTypeEnumeration:
			return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, (const enum jsdl__FileSystemTypeEnumeration *)ptr, "jsdl:FileSystemTypeEnumeration");
		case SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration:
			return soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, (const enum jsdl__OperatingSystemTypeEnumeration *)ptr, "jsdl:OperatingSystemTypeEnumeration");
		case SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration:
			return soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, (const enum jsdl__ProcessorArchitectureEnumeration *)ptr, "jsdl:ProcessorArchitectureEnumeration");
		case SOAP_TYPE_wsa__FaultCodesType:
			return soap_out_wsa__FaultCodesType(soap, tag, id, (const enum wsa__FaultCodesType *)ptr, "wsa:FaultCodesType");
		case SOAP_TYPE_wsa__RelationshipType:
			return soap_out_wsa__RelationshipType(soap, tag, id, (const enum wsa__RelationshipType *)ptr, "wsa:RelationshipType");
		case SOAP_TYPE_bes__ActivityStateEnumeration:
			return soap_out_bes__ActivityStateEnumeration(soap, tag, id, (const enum bes__ActivityStateEnumeration *)ptr, "bes:ActivityStateEnumeration");
		case SOAP_TYPE_xsd__boolean:
			return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
		case SOAP_TYPE_wsse__FaultcodeEnum:
			return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
		case SOAP_TYPE_wsu__tTimestampFault:
			return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
		case SOAP_TYPE__jsdl_hpcpa__UserName:
			return soap_out__jsdl_hpcpa__UserName(soap, "jsdl-hpcpa:UserName", id, (const struct jsdl_hpcpa__UserName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_hpcpa__Environment:
			return soap_out__jsdl_hpcpa__Environment(soap, "jsdl-hpcpa:Environment", id, (const struct jsdl_hpcpa__Environment_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_hpcpa__WorkingDirectory:
			return soap_out__jsdl_hpcpa__WorkingDirectory(soap, "jsdl-hpcpa:WorkingDirectory", id, (const struct jsdl_hpcpa__DirectoryName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_hpcpa__Error:
			return soap_out__jsdl_hpcpa__Error(soap, "jsdl-hpcpa:Error", id, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_hpcpa__Output:
			return soap_out__jsdl_hpcpa__Output(soap, "jsdl-hpcpa:Output", id, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_hpcpa__Input:
			return soap_out__jsdl_hpcpa__Input(soap, "jsdl-hpcpa:Input", id, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_hpcpa__Argument:
			return soap_out__jsdl_hpcpa__Argument(soap, "jsdl-hpcpa:Argument", id, (const struct jsdl_hpcpa__Argument_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_hpcpa__Executable:
			return soap_out__jsdl_hpcpa__Executable(soap, "jsdl-hpcpa:Executable", id, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_hpcpa__HPCProfileApplication:
			return soap_out__jsdl_hpcpa__HPCProfileApplication(soap, "jsdl-hpcpa:HPCProfileApplication", id, (const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__GroupName:
			return soap_out__jsdl_posix__GroupName(soap, "jsdl-posix:GroupName", id, (const struct jsdl_posix__GroupName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__UserName:
			return soap_out__jsdl_posix__UserName(soap, "jsdl-posix:UserName", id, (const struct jsdl_posix__UserName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__ThreadCountLimit:
			return soap_out__jsdl_posix__ThreadCountLimit(soap, "jsdl-posix:ThreadCountLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__VirtualMemoryLimit:
			return soap_out__jsdl_posix__VirtualMemoryLimit(soap, "jsdl-posix:VirtualMemoryLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__ProcessCountLimit:
			return soap_out__jsdl_posix__ProcessCountLimit(soap, "jsdl-posix:ProcessCountLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__CPUTimeLimit:
			return soap_out__jsdl_posix__CPUTimeLimit(soap, "jsdl-posix:CPUTimeLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__StackSizeLimit:
			return soap_out__jsdl_posix__StackSizeLimit(soap, "jsdl-posix:StackSizeLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__PipeSizeLimit:
			return soap_out__jsdl_posix__PipeSizeLimit(soap, "jsdl-posix:PipeSizeLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__OpenDescriptorsLimit:
			return soap_out__jsdl_posix__OpenDescriptorsLimit(soap, "jsdl-posix:OpenDescriptorsLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__MemoryLimit:
			return soap_out__jsdl_posix__MemoryLimit(soap, "jsdl-posix:MemoryLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__LockedMemoryLimit:
			return soap_out__jsdl_posix__LockedMemoryLimit(soap, "jsdl-posix:LockedMemoryLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__DataSegmentLimit:
			return soap_out__jsdl_posix__DataSegmentLimit(soap, "jsdl-posix:DataSegmentLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__CoreDumpLimit:
			return soap_out__jsdl_posix__CoreDumpLimit(soap, "jsdl-posix:CoreDumpLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__FileSizeLimit:
			return soap_out__jsdl_posix__FileSizeLimit(soap, "jsdl-posix:FileSizeLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__WallTimeLimit:
			return soap_out__jsdl_posix__WallTimeLimit(soap, "jsdl-posix:WallTimeLimit", id, (const struct jsdl_posix__Limits_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__Environment:
			return soap_out__jsdl_posix__Environment(soap, "jsdl-posix:Environment", id, (const struct jsdl_posix__Environment_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__WorkingDirectory:
			return soap_out__jsdl_posix__WorkingDirectory(soap, "jsdl-posix:WorkingDirectory", id, (const struct jsdl_posix__DirectoryName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__Error:
			return soap_out__jsdl_posix__Error(soap, "jsdl-posix:Error", id, (const struct jsdl_posix__FileName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__Output:
			return soap_out__jsdl_posix__Output(soap, "jsdl-posix:Output", id, (const struct jsdl_posix__FileName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__Input:
			return soap_out__jsdl_posix__Input(soap, "jsdl-posix:Input", id, (const struct jsdl_posix__FileName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__Argument:
			return soap_out__jsdl_posix__Argument(soap, "jsdl-posix:Argument", id, (const struct jsdl_posix__Argument_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__Executable:
			return soap_out__jsdl_posix__Executable(soap, "jsdl-posix:Executable", id, (const struct jsdl_posix__FileName_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl_posix__POSIXApplication:
			return soap_out__jsdl_posix__POSIXApplication(soap, "jsdl-posix:POSIXApplication", id, (const struct jsdl_posix__POSIXApplication_USCOREType *)ptr, NULL);
		case SOAP_TYPE__hpcp_af__AdvancedFilter:
			return soap_out__hpcp_af__AdvancedFilter(soap, "hpcp-af:AdvancedFilter", id, (const struct hpcp_af__AdvancedFilterType *)ptr, NULL);
		case SOAP_TYPE__jsdl__Target:
			return soap_out__jsdl__Target(soap, "jsdl:Target", id, (const struct jsdl__SourceTarget_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__Source:
			return soap_out__jsdl__Source(soap, "jsdl:Source", id, (const struct jsdl__SourceTarget_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__DataStaging:
			return soap_out__jsdl__DataStaging(soap, "jsdl:DataStaging", id, (const struct jsdl__DataStaging_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__TotalResourceCount:
			return soap_out__jsdl__TotalResourceCount(soap, "jsdl:TotalResourceCount", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__TotalDiskSpace:
			return soap_out__jsdl__TotalDiskSpace(soap, "jsdl:TotalDiskSpace", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__TotalVirtualMemory:
			return soap_out__jsdl__TotalVirtualMemory(soap, "jsdl:TotalVirtualMemory", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__TotalPhysicalMemory:
			return soap_out__jsdl__TotalPhysicalMemory(soap, "jsdl:TotalPhysicalMemory", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__TotalCPUCount:
			return soap_out__jsdl__TotalCPUCount(soap, "jsdl:TotalCPUCount", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__TotalCPUTime:
			return soap_out__jsdl__TotalCPUTime(soap, "jsdl:TotalCPUTime", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__IndividualDiskSpace:
			return soap_out__jsdl__IndividualDiskSpace(soap, "jsdl:IndividualDiskSpace", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__IndividualNetworkBandwidth:
			return soap_out__jsdl__IndividualNetworkBandwidth(soap, "jsdl:IndividualNetworkBandwidth", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__IndividualVirtualMemory:
			return soap_out__jsdl__IndividualVirtualMemory(soap, "jsdl:IndividualVirtualMemory", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__IndividualPhysicalMemory:
			return soap_out__jsdl__IndividualPhysicalMemory(soap, "jsdl:IndividualPhysicalMemory", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__IndividualCPUCount:
			return soap_out__jsdl__IndividualCPUCount(soap, "jsdl:IndividualCPUCount", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__IndividualCPUSpeed:
			return soap_out__jsdl__IndividualCPUSpeed(soap, "jsdl:IndividualCPUSpeed", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__IndividualCPUTime:
			return soap_out__jsdl__IndividualCPUTime(soap, "jsdl:IndividualCPUTime", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__DiskSpace:
			return soap_out__jsdl__DiskSpace(soap, "jsdl:DiskSpace", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__FileSystem:
			return soap_out__jsdl__FileSystem(soap, "jsdl:FileSystem", id, (const struct jsdl__FileSystem_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__CPUArchitecture:
			return soap_out__jsdl__CPUArchitecture(soap, "jsdl:CPUArchitecture", id, (const struct jsdl__CPUArchitecture_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__OperatingSystemType:
			return soap_out__jsdl__OperatingSystemType(soap, "jsdl:OperatingSystemType", id, (const struct jsdl__OperatingSystemType_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__OperatingSystem:
			return soap_out__jsdl__OperatingSystem(soap, "jsdl:OperatingSystem", id, (const struct jsdl__OperatingSystem_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__CandidateHosts:
			return soap_out__jsdl__CandidateHosts(soap, "jsdl:CandidateHosts", id, (const struct jsdl__CandidateHosts_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__Resources:
			return soap_out__jsdl__Resources(soap, "jsdl:Resources", id, (const struct jsdl__Resources_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__Application:
			return soap_out__jsdl__Application(soap, "jsdl:Application", id, (const struct jsdl__Application_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__JobIdentification:
			return soap_out__jsdl__JobIdentification(soap, "jsdl:JobIdentification", id, (const struct jsdl__JobIdentification_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__JobDescription:
			return soap_out__jsdl__JobDescription(soap, "jsdl:JobDescription", id, (const struct jsdl__JobDescription_USCOREType *)ptr, NULL);
		case SOAP_TYPE__jsdl__JobDefinition:
			return soap_out__jsdl__JobDefinition(soap, "jsdl:JobDefinition", id, (const struct jsdl__JobDefinition_USCOREType *)ptr, NULL);
		case SOAP_TYPE__wsa__ProblemAction:
			return soap_out__wsa__ProblemAction(soap, "wsa:ProblemAction", id, (const struct wsa__ProblemActionType *)ptr, NULL);
		case SOAP_TYPE__wsa__ProblemIRI:
			return soap_out__wsa__ProblemIRI(soap, "wsa:ProblemIRI", id, (const struct wsa__AttributedURIType *)ptr, NULL);
		case SOAP_TYPE__wsa__ProblemHeaderQName:
			return soap_out__wsa__ProblemHeaderQName(soap, "wsa:ProblemHeaderQName", id, (const struct wsa__AttributedQNameType *)ptr, NULL);
		case SOAP_TYPE__wsa__RetryAfter:
			return soap_out__wsa__RetryAfter(soap, "wsa:RetryAfter", id, (const struct wsa__AttributedUnsignedLongType *)ptr, NULL);
		case SOAP_TYPE__wsa__Action:
			return soap_out__wsa__Action(soap, "wsa:Action", id, (const struct wsa__AttributedURIType *)ptr, NULL);
		case SOAP_TYPE__wsa__To:
			return soap_out__wsa__To(soap, "wsa:To", id, (const struct wsa__AttributedURIType *)ptr, NULL);
		case SOAP_TYPE__wsa__FaultTo:
			return soap_out__wsa__FaultTo(soap, "wsa:FaultTo", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
		case SOAP_TYPE__wsa__From:
			return soap_out__wsa__From(soap, "wsa:From", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
		case SOAP_TYPE__wsa__ReplyTo:
			return soap_out__wsa__ReplyTo(soap, "wsa:ReplyTo", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
		case SOAP_TYPE__wsa__RelatesTo:
			return soap_out__wsa__RelatesTo(soap, "wsa:RelatesTo", id, (const struct wsa__RelatesToType *)ptr, NULL);
		case SOAP_TYPE__wsa__MessageID:
			return soap_out__wsa__MessageID(soap, "wsa:MessageID", id, (const struct wsa__AttributedURIType *)ptr, NULL);
		case SOAP_TYPE__wsa__Metadata:
			return soap_out__wsa__Metadata(soap, "wsa:Metadata", id, (const struct wsa__MetadataType *)ptr, NULL);
		case SOAP_TYPE__wsa__ReferenceParameters:
			return soap_out__wsa__ReferenceParameters(soap, "wsa:ReferenceParameters", id, (const struct wsa__ReferenceParametersType *)ptr, NULL);
		case SOAP_TYPE__wsa__EndpointReference:
			return soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
		case SOAP_TYPE__bes__ActivityStatus:
			return soap_out__bes__ActivityStatus(soap, "bes:ActivityStatus", id, (const struct bes__ActivityStatusType *)ptr, NULL);
		case SOAP_TYPE__bes__ActivityDocument:
			return soap_out__bes__ActivityDocument(soap, "bes:ActivityDocument", id, (const struct bes__ActivityDocumentType *)ptr, NULL);
		case SOAP_TYPE__bes__FactoryResourceAttributesDocument:
			return soap_out__bes__FactoryResourceAttributesDocument(soap, "bes:FactoryResourceAttributesDocument", id, (const struct bes__FactoryResourceAttributesDocumentType *)ptr, NULL);
		case SOAP_TYPE__bes__BasicResourceAttributesDocument:
			return soap_out__bes__BasicResourceAttributesDocument(soap, "bes:BasicResourceAttributesDocument", id, (const struct bes__BasicResourceAttributesDocumentType *)ptr, NULL);
		case SOAP_TYPE__bes__InvalidRequestMessageFault:
			return soap_out__bes__InvalidRequestMessageFault(soap, "bes:InvalidRequestMessageFault", id, (const struct bes__InvalidRequestMessageFaultType *)ptr, NULL);
		case SOAP_TYPE__bes__InvalidActivityIdentifierFault:
			return soap_out__bes__InvalidActivityIdentifierFault(soap, "bes:InvalidActivityIdentifierFault", id, (const struct bes__InvalidActivityIdentifierFaultType *)ptr, NULL);
		case SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault:
			return soap_out__bes__OperationWillBeAppliedEventuallyFault(soap, "bes:OperationWillBeAppliedEventuallyFault", id, (const struct bes__OperationWillBeAppliedEventuallyFaultType *)ptr, NULL);
		case SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault:
			return soap_out__bes__CantApplyOperationToCurrentStateFault(soap, "bes:CantApplyOperationToCurrentStateFault", id, (const struct bes__CantApplyOperationToCurrentStateFaultType *)ptr, NULL);
		case SOAP_TYPE__bes__UnsupportedFeatureFault:
			return soap_out__bes__UnsupportedFeatureFault(soap, "bes:UnsupportedFeatureFault", id, (const struct bes__UnsupportedFeatureFaultType *)ptr, NULL);
		case SOAP_TYPE__bes__NotAcceptingNewActivitiesFault:
			return soap_out__bes__NotAcceptingNewActivitiesFault(soap, "bes:NotAcceptingNewActivitiesFault", id, (const struct bes__NotAcceptingNewActivitiesFaultType *)ptr, NULL);
		case SOAP_TYPE__bes__NotAuthorizedFault:
			return soap_out__bes__NotAuthorizedFault(soap, "bes:NotAuthorizedFault", id, (const struct bes__NotAuthorizedFaultType *)ptr, NULL);
		case SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse:
			return soap_out__bes__GetFactoryAttributesDocumentResponse(soap, "bes:GetFactoryAttributesDocumentResponse", id, (const struct bes__GetFactoryAttributesDocumentResponseType *)ptr, NULL);
		case SOAP_TYPE__bes__GetFactoryAttributesDocument:
			return soap_out__bes__GetFactoryAttributesDocument(soap, "bes:GetFactoryAttributesDocument", id, (const struct bes__GetFactoryAttributesDocumentType *)ptr, NULL);
		case SOAP_TYPE__bes__GetActivityDocumentsResponse:
			return soap_out__bes__GetActivityDocumentsResponse(soap, "bes:GetActivityDocumentsResponse", id, (const struct bes__GetActivityDocumentsResponseType *)ptr, NULL);
		case SOAP_TYPE__bes__GetActivityDocuments:
			return soap_out__bes__GetActivityDocuments(soap, "bes:GetActivityDocuments", id, (const struct bes__GetActivityDocumentsType *)ptr, NULL);
		case SOAP_TYPE__bes__TerminateActivitiesResponse:
			return soap_out__bes__TerminateActivitiesResponse(soap, "bes:TerminateActivitiesResponse", id, (const struct bes__TerminateActivitiesResponseType *)ptr, NULL);
		case SOAP_TYPE__bes__TerminateActivities:
			return soap_out__bes__TerminateActivities(soap, "bes:TerminateActivities", id, (const struct bes__TerminateActivitiesType *)ptr, NULL);
		case SOAP_TYPE__bes__GetActivityStatusesResponse:
			return soap_out__bes__GetActivityStatusesResponse(soap, "bes:GetActivityStatusesResponse", id, (const struct bes__GetActivityStatusesResponseType *)ptr, NULL);
		case SOAP_TYPE__bes__GetActivityStatuses:
			return soap_out__bes__GetActivityStatuses(soap, "bes:GetActivityStatuses", id, (const struct bes__GetActivityStatusesType *)ptr, NULL);
		case SOAP_TYPE__bes__CreateActivityResponse:
			return soap_out__bes__CreateActivityResponse(soap, "bes:CreateActivityResponse", id, (const struct bes__CreateActivityResponseType *)ptr, NULL);
		case SOAP_TYPE__bes__CreateActivity:
			return soap_out__bes__CreateActivity(soap, "bes:CreateActivity", id, (const struct bes__CreateActivityType *)ptr, NULL);
		case SOAP_TYPE_jsdl_hpcpa__HPCProfileApplication_USCOREType:
			return soap_out_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, tag, id, (const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *)ptr, "jsdl-hpcpa:HPCProfileApplication_Type");
		case SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType:
			return soap_out_jsdl_hpcpa__UserName_USCOREType(soap, tag, id, (const struct jsdl_hpcpa__UserName_USCOREType *)ptr, "jsdl-hpcpa:UserName_Type");
		case SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType:
			return soap_out_jsdl_hpcpa__DirectoryName_USCOREType(soap, tag, id, (const struct jsdl_hpcpa__DirectoryName_USCOREType *)ptr, "jsdl-hpcpa:DirectoryName_Type");
		case SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType:
			return soap_out_jsdl_hpcpa__FileName_USCOREType(soap, tag, id, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr, "jsdl-hpcpa:FileName_Type");
		case SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType:
			return soap_out_jsdl_hpcpa__Argument_USCOREType(soap, tag, id, (const struct jsdl_hpcpa__Argument_USCOREType *)ptr, "jsdl-hpcpa:Argument_Type");
		case SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType:
			return soap_out_jsdl_hpcpa__Environment_USCOREType(soap, tag, id, (const struct jsdl_hpcpa__Environment_USCOREType *)ptr, "jsdl-hpcpa:Environment_Type");
		case SOAP_TYPE_jsdl_posix__POSIXApplication_USCOREType:
			return soap_out_jsdl_posix__POSIXApplication_USCOREType(soap, tag, id, (const struct jsdl_posix__POSIXApplication_USCOREType *)ptr, "jsdl-posix:POSIXApplication_Type");
		case SOAP_TYPE_jsdl_posix__GroupName_USCOREType:
			return soap_out_jsdl_posix__GroupName_USCOREType(soap, tag, id, (const struct jsdl_posix__GroupName_USCOREType *)ptr, "jsdl-posix:GroupName_Type");
		case SOAP_TYPE_jsdl_posix__UserName_USCOREType:
			return soap_out_jsdl_posix__UserName_USCOREType(soap, tag, id, (const struct jsdl_posix__UserName_USCOREType *)ptr, "jsdl-posix:UserName_Type");
		case SOAP_TYPE_jsdl_posix__Limits_USCOREType:
			return soap_out_jsdl_posix__Limits_USCOREType(soap, tag, id, (const struct jsdl_posix__Limits_USCOREType *)ptr, "jsdl-posix:Limits_Type");
		case SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType:
			return soap_out_jsdl_posix__DirectoryName_USCOREType(soap, tag, id, (const struct jsdl_posix__DirectoryName_USCOREType *)ptr, "jsdl-posix:DirectoryName_Type");
		case SOAP_TYPE_jsdl_posix__FileName_USCOREType:
			return soap_out_jsdl_posix__FileName_USCOREType(soap, tag, id, (const struct jsdl_posix__FileName_USCOREType *)ptr, "jsdl-posix:FileName_Type");
		case SOAP_TYPE_jsdl_posix__Argument_USCOREType:
			return soap_out_jsdl_posix__Argument_USCOREType(soap, tag, id, (const struct jsdl_posix__Argument_USCOREType *)ptr, "jsdl-posix:Argument_Type");
		case SOAP_TYPE_jsdl_posix__Environment_USCOREType:
			return soap_out_jsdl_posix__Environment_USCOREType(soap, tag, id, (const struct jsdl_posix__Environment_USCOREType *)ptr, "jsdl-posix:Environment_Type");
		case SOAP_TYPE_hpcp_af__DynamicNodeStatusType:
			return soap_out_hpcp_af__DynamicNodeStatusType(soap, tag, id, (const struct hpcp_af__DynamicNodeStatusType *)ptr, "hpcp-af:DynamicNodeStatusType");
		case SOAP_TYPE_hpcp_af__ActivityIdType:
			return soap_out_hpcp_af__ActivityIdType(soap, tag, id, (const struct hpcp_af__ActivityIdType *)ptr, "hpcp-af:ActivityIdType");
		case SOAP_TYPE_hpcp_af__CPUType:
			return soap_out_hpcp_af__CPUType(soap, tag, id, (const struct hpcp_af__CPUType *)ptr, "hpcp-af:CPUType");
		case SOAP_TYPE_hpcp_af__MemoryType:
			return soap_out_hpcp_af__MemoryType(soap, tag, id, (const struct hpcp_af__MemoryType *)ptr, "hpcp-af:MemoryType");
		case SOAP_TYPE_hpcp_af__NodeStatusType:
			return soap_out_hpcp_af__NodeStatusType(soap, tag, id, (const struct hpcp_af__NodeStatusType *)ptr, "hpcp-af:NodeStatusType");
		case SOAP_TYPE_hpcp_af__ActivityIdRangeType:
			return soap_out_hpcp_af__ActivityIdRangeType(soap, tag, id, (const struct hpcp_af__ActivityIdRangeType *)ptr, "hpcp-af:ActivityIdRangeType");
		case SOAP_TYPE_hpcp_af__DateTimeRangeType:
			return soap_out_hpcp_af__DateTimeRangeType(soap, tag, id, (const struct hpcp_af__DateTimeRangeType *)ptr, "hpcp-af:DateTimeRangeType");
		case SOAP_TYPE_hpcp_af__AdvancedFilterType:
			return soap_out_hpcp_af__AdvancedFilterType(soap, tag, id, (const struct hpcp_af__AdvancedFilterType *)ptr, "hpcp-af:AdvancedFilterType");
		case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
			return soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, (const struct jsdl__SourceTarget_USCOREType *)ptr, "jsdl:SourceTarget_Type");
		case SOAP_TYPE_jsdl__DataStaging_USCOREType:
			return soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, (const struct jsdl__DataStaging_USCOREType *)ptr, "jsdl:DataStaging_Type");
		case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
			return soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, (const struct jsdl__OperatingSystemType_USCOREType *)ptr, "jsdl:OperatingSystemType_Type");
		case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
			return soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, (const struct jsdl__OperatingSystem_USCOREType *)ptr, "jsdl:OperatingSystem_Type");
		case SOAP_TYPE_jsdl__FileSystem_USCOREType:
			return soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, (const struct jsdl__FileSystem_USCOREType *)ptr, "jsdl:FileSystem_Type");
		case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
			return soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, (const struct jsdl__CPUArchitecture_USCOREType *)ptr, "jsdl:CPUArchitecture_Type");
		case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
			return soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, (const struct jsdl__CandidateHosts_USCOREType *)ptr, "jsdl:CandidateHosts_Type");
		case SOAP_TYPE_jsdl__Resources_USCOREType:
			return soap_out_jsdl__Resources_USCOREType(soap, tag, id, (const struct jsdl__Resources_USCOREType *)ptr, "jsdl:Resources_Type");
		case SOAP_TYPE_jsdl__Application_USCOREType:
			return soap_out_jsdl__Application_USCOREType(soap, tag, id, (const struct jsdl__Application_USCOREType *)ptr, "jsdl:Application_Type");
		case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
			return soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, (const struct jsdl__JobIdentification_USCOREType *)ptr, "jsdl:JobIdentification_Type");
		case SOAP_TYPE_jsdl__JobDescription_USCOREType:
			return soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, (const struct jsdl__JobDescription_USCOREType *)ptr, "jsdl:JobDescription_Type");
		case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
			return soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, (const struct jsdl__JobDefinition_USCOREType *)ptr, "jsdl:JobDefinition_Type");
		case SOAP_TYPE_jsdl__RangeValue_USCOREType:
			return soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, (const struct jsdl__RangeValue_USCOREType *)ptr, "jsdl:RangeValue_Type");
		case SOAP_TYPE_jsdl__Range_USCOREType:
			return soap_out_jsdl__Range_USCOREType(soap, tag, id, (const struct jsdl__Range_USCOREType *)ptr, "jsdl:Range_Type");
		case SOAP_TYPE_jsdl__Exact_USCOREType:
			return soap_out_jsdl__Exact_USCOREType(soap, tag, id, (const struct jsdl__Exact_USCOREType *)ptr, "jsdl:Exact_Type");
		case SOAP_TYPE_jsdl__Boundary_USCOREType:
			return soap_out_jsdl__Boundary_USCOREType(soap, tag, id, (const struct jsdl__Boundary_USCOREType *)ptr, "jsdl:Boundary_Type");
		case SOAP_TYPE_wsa__ProblemActionType:
			return soap_out_wsa__ProblemActionType(soap, tag, id, (const struct wsa__ProblemActionType *)ptr, "wsa:ProblemActionType");
		case SOAP_TYPE_wsa__AttributedQNameType:
			return soap_out_wsa__AttributedQNameType(soap, tag, id, (const struct wsa__AttributedQNameType *)ptr, "wsa:AttributedQNameType");
		case SOAP_TYPE_wsa__AttributedUnsignedLongType:
			return soap_out_wsa__AttributedUnsignedLongType(soap, tag, id, (const struct wsa__AttributedUnsignedLongType *)ptr, "wsa:AttributedUnsignedLongType");
		case SOAP_TYPE_wsa__AttributedURIType:
			return soap_out_wsa__AttributedURIType(soap, tag, id, (const struct wsa__AttributedURIType *)ptr, "wsa:AttributedURIType");
		case SOAP_TYPE_wsa__RelatesToType:
			return soap_out_wsa__RelatesToType(soap, tag, id, (const struct wsa__RelatesToType *)ptr, "wsa:RelatesToType");
		case SOAP_TYPE_wsa__MetadataType:
			return soap_out_wsa__MetadataType(soap, tag, id, (const struct wsa__MetadataType *)ptr, "wsa:MetadataType");
		case SOAP_TYPE_wsa__ReferenceParametersType:
			return soap_out_wsa__ReferenceParametersType(soap, tag, id, (const struct wsa__ReferenceParametersType *)ptr, "wsa:ReferenceParametersType");
		case SOAP_TYPE_wsa__EndpointReferenceType:
			return soap_out_wsa__EndpointReferenceType(soap, tag, id, (const struct wsa__EndpointReferenceType *)ptr, "wsa:EndpointReferenceType");
		case SOAP_TYPE_bes__TerminateActivityResponseType:
			return soap_out_bes__TerminateActivityResponseType(soap, tag, id, (const struct bes__TerminateActivityResponseType *)ptr, "bes:TerminateActivityResponseType");
		case SOAP_TYPE_bes__GetActivityDocumentResponseType:
			return soap_out_bes__GetActivityDocumentResponseType(soap, tag, id, (const struct bes__GetActivityDocumentResponseType *)ptr, "bes:GetActivityDocumentResponseType");
		case SOAP_TYPE_bes__GetActivityStatusResponseType:
			return soap_out_bes__GetActivityStatusResponseType(soap, tag, id, (const struct bes__GetActivityStatusResponseType *)ptr, "bes:GetActivityStatusResponseType");
		case SOAP_TYPE_bes__ActivityStatusType:
			return soap_out_bes__ActivityStatusType(soap, tag, id, (const struct bes__ActivityStatusType *)ptr, "bes:ActivityStatusType");
		case SOAP_TYPE_bes__ActivityDocumentType:
			return soap_out_bes__ActivityDocumentType(soap, tag, id, (const struct bes__ActivityDocumentType *)ptr, "bes:ActivityDocumentType");
		case SOAP_TYPE_bes__FactoryResourceAttributesDocumentType:
			return soap_out_bes__FactoryResourceAttributesDocumentType(soap, tag, id, (const struct bes__FactoryResourceAttributesDocumentType *)ptr, "bes:FactoryResourceAttributesDocumentType");
		case SOAP_TYPE_bes__BasicResourceAttributesDocumentType:
			return soap_out_bes__BasicResourceAttributesDocumentType(soap, tag, id, (const struct bes__BasicResourceAttributesDocumentType *)ptr, "bes:BasicResourceAttributesDocumentType");
		case SOAP_TYPE_bes__InvalidRequestMessageFaultType:
			return soap_out_bes__InvalidRequestMessageFaultType(soap, tag, id, (const struct bes__InvalidRequestMessageFaultType *)ptr, "bes:InvalidRequestMessageFaultType");
		case SOAP_TYPE_bes__InvalidActivityIdentifierFaultType:
			return soap_out_bes__InvalidActivityIdentifierFaultType(soap, tag, id, (const struct bes__InvalidActivityIdentifierFaultType *)ptr, "bes:InvalidActivityIdentifierFaultType");
		case SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType:
			return soap_out_bes__OperationWillBeAppliedEventuallyFaultType(soap, tag, id, (const struct bes__OperationWillBeAppliedEventuallyFaultType *)ptr, "bes:OperationWillBeAppliedEventuallyFaultType");
		case SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType:
			return soap_out_bes__CantApplyOperationToCurrentStateFaultType(soap, tag, id, (const struct bes__CantApplyOperationToCurrentStateFaultType *)ptr, "bes:CantApplyOperationToCurrentStateFaultType");
		case SOAP_TYPE_bes__UnsupportedFeatureFaultType:
			return soap_out_bes__UnsupportedFeatureFaultType(soap, tag, id, (const struct bes__UnsupportedFeatureFaultType *)ptr, "bes:UnsupportedFeatureFaultType");
		case SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType:
			return soap_out_bes__NotAcceptingNewActivitiesFaultType(soap, tag, id, (const struct bes__NotAcceptingNewActivitiesFaultType *)ptr, "bes:NotAcceptingNewActivitiesFaultType");
		case SOAP_TYPE_bes__NotAuthorizedFaultType:
			return soap_out_bes__NotAuthorizedFaultType(soap, tag, id, (const struct bes__NotAuthorizedFaultType *)ptr, "bes:NotAuthorizedFaultType");
		case SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType:
			return soap_out_bes__GetFactoryAttributesDocumentResponseType(soap, tag, id, (const struct bes__GetFactoryAttributesDocumentResponseType *)ptr, "bes:GetFactoryAttributesDocumentResponseType");
		case SOAP_TYPE_bes__GetFactoryAttributesDocumentType:
			return soap_out_bes__GetFactoryAttributesDocumentType(soap, tag, id, (const struct bes__GetFactoryAttributesDocumentType *)ptr, "bes:GetFactoryAttributesDocumentType");
		case SOAP_TYPE_bes__GetActivityDocumentsResponseType:
			return soap_out_bes__GetActivityDocumentsResponseType(soap, tag, id, (const struct bes__GetActivityDocumentsResponseType *)ptr, "bes:GetActivityDocumentsResponseType");
		case SOAP_TYPE_bes__GetActivityDocumentsType:
			return soap_out_bes__GetActivityDocumentsType(soap, tag, id, (const struct bes__GetActivityDocumentsType *)ptr, "bes:GetActivityDocumentsType");
		case SOAP_TYPE_bes__TerminateActivitiesResponseType:
			return soap_out_bes__TerminateActivitiesResponseType(soap, tag, id, (const struct bes__TerminateActivitiesResponseType *)ptr, "bes:TerminateActivitiesResponseType");
		case SOAP_TYPE_bes__TerminateActivitiesType:
			return soap_out_bes__TerminateActivitiesType(soap, tag, id, (const struct bes__TerminateActivitiesType *)ptr, "bes:TerminateActivitiesType");
		case SOAP_TYPE_bes__GetActivityStatusesResponseType:
			return soap_out_bes__GetActivityStatusesResponseType(soap, tag, id, (const struct bes__GetActivityStatusesResponseType *)ptr, "bes:GetActivityStatusesResponseType");
		case SOAP_TYPE_bes__GetActivityStatusesType:
			return soap_out_bes__GetActivityStatusesType(soap, tag, id, (const struct bes__GetActivityStatusesType *)ptr, "bes:GetActivityStatusesType");
		case SOAP_TYPE_bes__CreateActivityResponseType:
			return soap_out_bes__CreateActivityResponseType(soap, tag, id, (const struct bes__CreateActivityResponseType *)ptr, "bes:CreateActivityResponseType");
		case SOAP_TYPE_bes__CreateActivityType:
			return soap_out_bes__CreateActivityType(soap, tag, id, (const struct bes__CreateActivityType *)ptr, "bes:CreateActivityType");
		case SOAP_TYPE_xsd__anyType:
			return soap_out_xsd__anyType(soap, tag, id, (const struct soap_dom_element *)ptr, "xsd:anyType");
		case SOAP_TYPE__wsse__Security:
			return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
		case SOAP_TYPE_ds__RSAKeyValueType:
			return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
		case SOAP_TYPE_ds__DSAKeyValueType:
			return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
		case SOAP_TYPE_ds__X509IssuerSerialType:
			return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
		case SOAP_TYPE_ds__X509DataType:
			return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
		case SOAP_TYPE_ds__RetrievalMethodType:
			return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
		case SOAP_TYPE_ds__KeyValueType:
			return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
		case SOAP_TYPE_ds__DigestMethodType:
			return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
		case SOAP_TYPE_ds__TransformType:
			return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
		case SOAP_TYPE__c14n__InclusiveNamespaces:
			return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
		case SOAP_TYPE_ds__TransformsType:
			return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
		case SOAP_TYPE_ds__ReferenceType:
			return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
		case SOAP_TYPE_ds__SignatureMethodType:
			return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
		case SOAP_TYPE_ds__CanonicalizationMethodType:
			return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
		case SOAP_TYPE_ds__KeyInfoType:
			return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
		case SOAP_TYPE_ds__SignedInfoType:
			return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
		case SOAP_TYPE_ds__SignatureType:
			return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
		case SOAP_TYPE__wsse__SecurityTokenReference:
			return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
		case SOAP_TYPE__wsse__KeyIdentifier:
			return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
		case SOAP_TYPE__wsse__Embedded:
			return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
		case SOAP_TYPE__wsse__Reference:
			return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
		case SOAP_TYPE__wsse__BinarySecurityToken:
			return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
		case SOAP_TYPE__wsse__Password:
			return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
		case SOAP_TYPE__wsse__UsernameToken:
			return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
		case SOAP_TYPE__wsu__Timestamp:
			return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
		case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentResponseType:
			return soap_out_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, tag, id, (struct bes__GetFactoryAttributesDocumentResponseType *const*)ptr, "bes:GetFactoryAttributesDocumentResponseType");
		case SOAP_TYPE_PointerTobes__GetActivityDocumentsResponseType:
			return soap_out_PointerTobes__GetActivityDocumentsResponseType(soap, tag, id, (struct bes__GetActivityDocumentsResponseType *const*)ptr, "bes:GetActivityDocumentsResponseType");
		case SOAP_TYPE_PointerTobes__TerminateActivitiesResponseType:
			return soap_out_PointerTobes__TerminateActivitiesResponseType(soap, tag, id, (struct bes__TerminateActivitiesResponseType *const*)ptr, "bes:TerminateActivitiesResponseType");
		case SOAP_TYPE_PointerTobes__GetActivityStatusesResponseType:
			return soap_out_PointerTobes__GetActivityStatusesResponseType(soap, tag, id, (struct bes__GetActivityStatusesResponseType *const*)ptr, "bes:GetActivityStatusesResponseType");
		case SOAP_TYPE_PointerTobes__CreateActivityResponseType:
			return soap_out_PointerTobes__CreateActivityResponseType(soap, tag, id, (struct bes__CreateActivityResponseType *const*)ptr, "bes:CreateActivityResponseType");
		case SOAP_TYPE_PointerTobes__CreateActivityType:
			return soap_out_PointerTobes__CreateActivityType(soap, tag, id, (struct bes__CreateActivityType *const*)ptr, "bes:CreateActivityType");
		case SOAP_TYPE_PointerTobes__UnsupportedFeatureFaultType:
			return soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, tag, id, (struct bes__UnsupportedFeatureFaultType *const*)ptr, "bes:UnsupportedFeatureFaultType");
		case SOAP_TYPE_PointerTobes__NotAuthorizedFaultType:
			return soap_out_PointerTobes__NotAuthorizedFaultType(soap, tag, id, (struct bes__NotAuthorizedFaultType *const*)ptr, "bes:NotAuthorizedFaultType");
		case SOAP_TYPE_PointerTobes__NotAcceptingNewActivitiesFaultType:
			return soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, id, (struct bes__NotAcceptingNewActivitiesFaultType *const*)ptr, "bes:NotAcceptingNewActivitiesFaultType");
		case SOAP_TYPE_PointerTobes__InvalidRequestMessageFaultType:
			return soap_out_PointerTobes__InvalidRequestMessageFaultType(soap, tag, id, (struct bes__InvalidRequestMessageFaultType *const*)ptr, "bes:InvalidRequestMessageFaultType");
		case SOAP_TYPE_PointerTo_wsa__FaultTo:
			return soap_out_PointerTo_wsa__FaultTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:FaultTo");
		case SOAP_TYPE_PointerTo_wsa__ReplyTo:
			return soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:ReplyTo");
		case SOAP_TYPE_PointerTo_wsa__From:
			return soap_out_PointerTo_wsa__From(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:From");
		case SOAP_TYPE_PointerTo_wsa__RelatesTo:
			return soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, (struct wsa__RelatesToType *const*)ptr, "wsa:RelatesTo");
		case SOAP_TYPE_PointerTo_wsse__Security:
			return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
		case SOAP_TYPE__jsdl__URI:
			return soap_out_string(soap, "jsdl:URI", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__FilesystemName:
			return soap_out_string(soap, "jsdl:FilesystemName", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__FileName:
			return soap_out_string(soap, "jsdl:FileName", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__MountPoint:
			return soap_out_string(soap, "jsdl:MountPoint", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__OperatingSystemVersion:
			return soap_out_string(soap, "jsdl:OperatingSystemVersion", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__HostName:
			return soap_out_string(soap, "jsdl:HostName", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__ApplicationVersion:
			return soap_out_string(soap, "jsdl:ApplicationVersion", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__ApplicationName:
			return soap_out_string(soap, "jsdl:ApplicationName", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__JobProject:
			return soap_out_string(soap, "jsdl:JobProject", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__JobAnnotation:
			return soap_out_string(soap, "jsdl:JobAnnotation", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__Description:
			return soap_out_string(soap, "jsdl:Description", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE__jsdl__JobName:
			return soap_out_string(soap, "jsdl:JobName", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE_PointerTojsdl_hpcpa__UserName_USCOREType:
			return soap_out_PointerTojsdl_hpcpa__UserName_USCOREType(soap, tag, id, (struct jsdl_hpcpa__UserName_USCOREType *const*)ptr, "jsdl-hpcpa:UserName_Type");
		case SOAP_TYPE_PointerTojsdl_hpcpa__Environment_USCOREType:
			return soap_out_PointerTojsdl_hpcpa__Environment_USCOREType(soap, tag, id, (struct jsdl_hpcpa__Environment_USCOREType *const*)ptr, "jsdl-hpcpa:Environment_Type");
		case SOAP_TYPE_PointerTojsdl_hpcpa__DirectoryName_USCOREType:
			return soap_out_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, tag, id, (struct jsdl_hpcpa__DirectoryName_USCOREType *const*)ptr, "jsdl-hpcpa:DirectoryName_Type");
		case SOAP_TYPE_PointerTojsdl_hpcpa__Argument_USCOREType:
			return soap_out_PointerTojsdl_hpcpa__Argument_USCOREType(soap, tag, id, (struct jsdl_hpcpa__Argument_USCOREType *const*)ptr, "jsdl-hpcpa:Argument_Type");
		case SOAP_TYPE_PointerTojsdl_hpcpa__FileName_USCOREType:
			return soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, tag, id, (struct jsdl_hpcpa__FileName_USCOREType *const*)ptr, "jsdl-hpcpa:FileName_Type");
		case SOAP_TYPE_PointerTojsdl_posix__GroupName_USCOREType:
			return soap_out_PointerTojsdl_posix__GroupName_USCOREType(soap, tag, id, (struct jsdl_posix__GroupName_USCOREType *const*)ptr, "jsdl-posix:GroupName_Type");
		case SOAP_TYPE_PointerTojsdl_posix__UserName_USCOREType:
			return soap_out_PointerTojsdl_posix__UserName_USCOREType(soap, tag, id, (struct jsdl_posix__UserName_USCOREType *const*)ptr, "jsdl-posix:UserName_Type");
		case SOAP_TYPE_PointerTojsdl_posix__Limits_USCOREType:
			return soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, tag, id, (struct jsdl_posix__Limits_USCOREType *const*)ptr, "jsdl-posix:Limits_Type");
		case SOAP_TYPE_PointerTojsdl_posix__Environment_USCOREType:
			return soap_out_PointerTojsdl_posix__Environment_USCOREType(soap, tag, id, (struct jsdl_posix__Environment_USCOREType *const*)ptr, "jsdl-posix:Environment_Type");
		case SOAP_TYPE_PointerTojsdl_posix__DirectoryName_USCOREType:
			return soap_out_PointerTojsdl_posix__DirectoryName_USCOREType(soap, tag, id, (struct jsdl_posix__DirectoryName_USCOREType *const*)ptr, "jsdl-posix:DirectoryName_Type");
		case SOAP_TYPE_PointerTojsdl_posix__Argument_USCOREType:
			return soap_out_PointerTojsdl_posix__Argument_USCOREType(soap, tag, id, (struct jsdl_posix__Argument_USCOREType *const*)ptr, "jsdl-posix:Argument_Type");
		case SOAP_TYPE_PointerTojsdl_posix__FileName_USCOREType:
			return soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, tag, id, (struct jsdl_posix__FileName_USCOREType *const*)ptr, "jsdl-posix:FileName_Type");
		case SOAP_TYPE_PointerTohpcp_af__NodeStatusType:
			return soap_out_PointerTohpcp_af__NodeStatusType(soap, tag, id, (struct hpcp_af__NodeStatusType *const*)ptr, "hpcp-af:NodeStatusType");
		case SOAP_TYPE_PointerTohpcp_af__ActivityIdType:
			return soap_out_PointerTohpcp_af__ActivityIdType(soap, tag, id, (struct hpcp_af__ActivityIdType *const*)ptr, "hpcp-af:ActivityIdType");
		case SOAP_TYPE_PointerTohpcp_af__CPUType:
			return soap_out_PointerTohpcp_af__CPUType(soap, tag, id, (struct hpcp_af__CPUType *const*)ptr, "hpcp-af:CPUType");
		case SOAP_TYPE_PointerTohpcp_af__MemoryType:
			return soap_out_PointerTohpcp_af__MemoryType(soap, tag, id, (struct hpcp_af__MemoryType *const*)ptr, "hpcp-af:MemoryType");
		case SOAP_TYPE_PointerTohpcp_af__DateTimeRangeType:
			return soap_out_PointerTohpcp_af__DateTimeRangeType(soap, tag, id, (struct hpcp_af__DateTimeRangeType *const*)ptr, "hpcp-af:DateTimeRangeType");
		case SOAP_TYPE_PointerTohpcp_af__ActivityIdRangeType:
			return soap_out_PointerTohpcp_af__ActivityIdRangeType(soap, tag, id, (struct hpcp_af__ActivityIdRangeType *const*)ptr, "hpcp-af:ActivityIdRangeType");
		case SOAP_TYPE_PointerTobes__ActivityStateEnumeration:
			return soap_out_PointerTobes__ActivityStateEnumeration(soap, tag, id, (enum bes__ActivityStateEnumeration *const*)ptr, "bes:ActivityStateEnumeration");
		case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
			return soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, (struct jsdl__SourceTarget_USCOREType *const*)ptr, "jsdl:SourceTarget_Type");
		case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
			return soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, (struct jsdl__OperatingSystemType_USCOREType *const*)ptr, "jsdl:OperatingSystemType_Type");
		case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
			return soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, (enum jsdl__FileSystemTypeEnumeration *const*)ptr, "jsdl:FileSystemTypeEnumeration");
		case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
			return soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, (struct jsdl__RangeValue_USCOREType *const*)ptr, "jsdl:RangeValue_Type");
		case SOAP_TYPE_PointerToxsd__boolean:
			return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
		case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
			return soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, (struct jsdl__FileSystem_USCOREType *const*)ptr, "jsdl:FileSystem_Type");
		case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
			return soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, (struct jsdl__CandidateHosts_USCOREType *const*)ptr, "jsdl:CandidateHosts_Type");
		case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
			return soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, (struct jsdl__DataStaging_USCOREType *const*)ptr, "jsdl:DataStaging_Type");
		case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
			return soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, (struct jsdl__Resources_USCOREType *const*)ptr, "jsdl:Resources_Type");
		case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
			return soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, (struct jsdl__Application_USCOREType *const*)ptr, "jsdl:Application_Type");
		case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
			return soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, (struct jsdl__JobIdentification_USCOREType *const*)ptr, "jsdl:JobIdentification_Type");
		case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
			return soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, (struct jsdl__JobDescription_USCOREType *const*)ptr, "jsdl:JobDescription_Type");
		case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
			return soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, (struct jsdl__Range_USCOREType *const*)ptr, "jsdl:Range_Type");
		case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
			return soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, (struct jsdl__Exact_USCOREType *const*)ptr, "jsdl:Exact_Type");
		case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
			return soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, (struct jsdl__Boundary_USCOREType *const*)ptr, "jsdl:Boundary_Type");
		case SOAP_TYPE_PointerTowsa__MetadataType:
			return soap_out_PointerTowsa__MetadataType(soap, tag, id, (struct wsa__MetadataType *const*)ptr, "wsa:MetadataType");
		case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
			return soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, (struct wsa__ReferenceParametersType *const*)ptr, "wsa:ReferenceParametersType");
		case SOAP_TYPE_PointerTowsa__AttributedURIType:
			return soap_out_PointerTowsa__AttributedURIType(soap, tag, id, (struct wsa__AttributedURIType *const*)ptr, "wsa:AttributedURIType");
		case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
			return soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, (struct jsdl__JobDefinition_USCOREType *const*)ptr, "jsdl:JobDefinition_Type");
		case SOAP_TYPE_PointerTohpcp_af__AdvancedFilterType:
			return soap_out_PointerTohpcp_af__AdvancedFilterType(soap, tag, id, (struct hpcp_af__AdvancedFilterType *const*)ptr, "hpcp-af:AdvancedFilterType");
		case SOAP_TYPE_PointerToxsd__anyURI:
			return soap_out_PointerToxsd__anyURI(soap, tag, id, (char **const*)ptr, "xsd:anyURI");
		case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
			return soap_out_PointerTowsa__EndpointReferenceType(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:EndpointReferenceType");
		case SOAP_TYPE_PointerTobes__BasicResourceAttributesDocumentType:
			return soap_out_PointerTobes__BasicResourceAttributesDocumentType(soap, tag, id, (struct bes__BasicResourceAttributesDocumentType *const*)ptr, "bes:BasicResourceAttributesDocumentType");
		case SOAP_TYPE_PointerTodouble:
			return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
		case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
			return soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, (struct jsdl__CPUArchitecture_USCOREType *const*)ptr, "jsdl:CPUArchitecture_Type");
		case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
			return soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, (struct jsdl__OperatingSystem_USCOREType *const*)ptr, "jsdl:OperatingSystem_Type");
		case SOAP_TYPE_PointerTobes__ActivityStatusType:
			return soap_out_PointerTobes__ActivityStatusType(soap, tag, id, (struct bes__ActivityStatusType *const*)ptr, "bes:ActivityStatusType");
		case SOAP_TYPE_PointerTostring:
			return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
		case SOAP_TYPE_jsdl__Description_USCOREType:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "jsdl:Description_Type");
		case SOAP_TYPE_wsa__FaultCodesOpenEnumType:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa:FaultCodesOpenEnumType");
		case SOAP_TYPE_wsa__RelationshipTypeOpenEnum:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa:RelationshipTypeOpenEnum");
		case SOAP_TYPE_PointerToxsd__anyType:
			return soap_out_PointerToxsd__anyType(soap, tag, id, (struct soap_dom_element *const*)ptr, "xsd:anyType");
		case SOAP_TYPE_xsd__normalizedString:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:normalizedString");
		case SOAP_TYPE_xsd__nonNegativeInteger:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:nonNegativeInteger");
		case SOAP_TYPE_xsd__anyURI:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
		case SOAP_TYPE_xsd__QName:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
		case SOAP_TYPE_xsd__NCName:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:NCName");
		case SOAP_TYPE_xsd__ID:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:ID");
		case SOAP_TYPE_PointerTods__SignatureType:
			return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
		case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
			return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
		case SOAP_TYPE_PointerTo_wsse__UsernameToken:
			return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
		case SOAP_TYPE_PointerTo_wsu__Timestamp:
			return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
		case SOAP_TYPE_PointerTods__X509IssuerSerialType:
			return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
		case SOAP_TYPE_PointerTods__RSAKeyValueType:
			return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
		case SOAP_TYPE_PointerTods__DSAKeyValueType:
			return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
		case SOAP_TYPE_PointerTods__TransformType:
			return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
		case SOAP_TYPE_PointerTods__DigestMethodType:
			return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
		case SOAP_TYPE_PointerTods__TransformsType:
			return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
		case SOAP_TYPE_PointerToint:
			return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
		case SOAP_TYPE_PointerToPointerTods__ReferenceType:
			return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
		case SOAP_TYPE_PointerTods__ReferenceType:
			return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
		case SOAP_TYPE_PointerTods__SignatureMethodType:
			return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
		case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
			return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
		case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
			return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
		case SOAP_TYPE_PointerTods__X509DataType:
			return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
		case SOAP_TYPE_PointerTods__RetrievalMethodType:
			return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
		case SOAP_TYPE_PointerTods__KeyValueType:
			return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
		case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
			return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
		case SOAP_TYPE_PointerTods__KeyInfoType:
			return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
		case SOAP_TYPE_PointerTods__SignedInfoType:
			return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
		case SOAP_TYPE_PointerTo_wsse__Embedded:
			return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
		case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
			return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
		case SOAP_TYPE_PointerTo_wsse__Reference:
			return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
		case SOAP_TYPE_PointerTo_wsse__Password:
			return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
		case SOAP_TYPE__QName:
			return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
		case SOAP_TYPE_string:
			return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4
soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type) {
		case SOAP_TYPE___bes__GetFactoryAttributesDocument:
			soap_serialize___bes__GetFactoryAttributesDocument(soap, (const struct __bes__GetFactoryAttributesDocument *)ptr);
			break;
		case SOAP_TYPE___bes__GetActivityDocuments:
			soap_serialize___bes__GetActivityDocuments(soap, (const struct __bes__GetActivityDocuments *)ptr);
			break;
		case SOAP_TYPE___bes__TerminateActivities:
			soap_serialize___bes__TerminateActivities(soap, (const struct __bes__TerminateActivities *)ptr);
			break;
		case SOAP_TYPE___bes__GetActivityStatuses:
			soap_serialize___bes__GetActivityStatuses(soap, (const struct __bes__GetActivityStatuses *)ptr);
			break;
		case SOAP_TYPE___bes__CreateActivity:
			soap_serialize___bes__CreateActivity(soap, (const struct __bes__CreateActivity *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__UserName:
			soap_serialize__jsdl_hpcpa__UserName(soap, (const struct jsdl_hpcpa__UserName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__Environment:
			soap_serialize__jsdl_hpcpa__Environment(soap, (const struct jsdl_hpcpa__Environment_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__WorkingDirectory:
			soap_serialize__jsdl_hpcpa__WorkingDirectory(soap, (const struct jsdl_hpcpa__DirectoryName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__Error:
			soap_serialize__jsdl_hpcpa__Error(soap, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__Output:
			soap_serialize__jsdl_hpcpa__Output(soap, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__Input:
			soap_serialize__jsdl_hpcpa__Input(soap, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__Argument:
			soap_serialize__jsdl_hpcpa__Argument(soap, (const struct jsdl_hpcpa__Argument_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__Executable:
			soap_serialize__jsdl_hpcpa__Executable(soap, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_hpcpa__HPCProfileApplication:
			soap_serialize__jsdl_hpcpa__HPCProfileApplication(soap, (const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__GroupName:
			soap_serialize__jsdl_posix__GroupName(soap, (const struct jsdl_posix__GroupName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__UserName:
			soap_serialize__jsdl_posix__UserName(soap, (const struct jsdl_posix__UserName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__ThreadCountLimit:
			soap_serialize__jsdl_posix__ThreadCountLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__VirtualMemoryLimit:
			soap_serialize__jsdl_posix__VirtualMemoryLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__ProcessCountLimit:
			soap_serialize__jsdl_posix__ProcessCountLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__CPUTimeLimit:
			soap_serialize__jsdl_posix__CPUTimeLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__StackSizeLimit:
			soap_serialize__jsdl_posix__StackSizeLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__PipeSizeLimit:
			soap_serialize__jsdl_posix__PipeSizeLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__OpenDescriptorsLimit:
			soap_serialize__jsdl_posix__OpenDescriptorsLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__MemoryLimit:
			soap_serialize__jsdl_posix__MemoryLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__LockedMemoryLimit:
			soap_serialize__jsdl_posix__LockedMemoryLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__DataSegmentLimit:
			soap_serialize__jsdl_posix__DataSegmentLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__CoreDumpLimit:
			soap_serialize__jsdl_posix__CoreDumpLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__FileSizeLimit:
			soap_serialize__jsdl_posix__FileSizeLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__WallTimeLimit:
			soap_serialize__jsdl_posix__WallTimeLimit(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__Environment:
			soap_serialize__jsdl_posix__Environment(soap, (const struct jsdl_posix__Environment_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__WorkingDirectory:
			soap_serialize__jsdl_posix__WorkingDirectory(soap, (const struct jsdl_posix__DirectoryName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__Error:
			soap_serialize__jsdl_posix__Error(soap, (const struct jsdl_posix__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__Output:
			soap_serialize__jsdl_posix__Output(soap, (const struct jsdl_posix__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__Input:
			soap_serialize__jsdl_posix__Input(soap, (const struct jsdl_posix__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__Argument:
			soap_serialize__jsdl_posix__Argument(soap, (const struct jsdl_posix__Argument_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__Executable:
			soap_serialize__jsdl_posix__Executable(soap, (const struct jsdl_posix__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl_posix__POSIXApplication:
			soap_serialize__jsdl_posix__POSIXApplication(soap, (const struct jsdl_posix__POSIXApplication_USCOREType *)ptr);
			break;
		case SOAP_TYPE__hpcp_af__AdvancedFilter:
			soap_serialize__hpcp_af__AdvancedFilter(soap, (const struct hpcp_af__AdvancedFilterType *)ptr);
			break;
		case SOAP_TYPE__jsdl__Target:
			soap_serialize__jsdl__Target(soap, (const struct jsdl__SourceTarget_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__Source:
			soap_serialize__jsdl__Source(soap, (const struct jsdl__SourceTarget_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__DataStaging:
			soap_serialize__jsdl__DataStaging(soap, (const struct jsdl__DataStaging_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__TotalResourceCount:
			soap_serialize__jsdl__TotalResourceCount(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__TotalDiskSpace:
			soap_serialize__jsdl__TotalDiskSpace(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__TotalVirtualMemory:
			soap_serialize__jsdl__TotalVirtualMemory(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__TotalPhysicalMemory:
			soap_serialize__jsdl__TotalPhysicalMemory(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__TotalCPUCount:
			soap_serialize__jsdl__TotalCPUCount(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__TotalCPUTime:
			soap_serialize__jsdl__TotalCPUTime(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__IndividualDiskSpace:
			soap_serialize__jsdl__IndividualDiskSpace(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__IndividualNetworkBandwidth:
			soap_serialize__jsdl__IndividualNetworkBandwidth(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__IndividualVirtualMemory:
			soap_serialize__jsdl__IndividualVirtualMemory(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__IndividualPhysicalMemory:
			soap_serialize__jsdl__IndividualPhysicalMemory(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__IndividualCPUCount:
			soap_serialize__jsdl__IndividualCPUCount(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__IndividualCPUSpeed:
			soap_serialize__jsdl__IndividualCPUSpeed(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__IndividualCPUTime:
			soap_serialize__jsdl__IndividualCPUTime(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__DiskSpace:
			soap_serialize__jsdl__DiskSpace(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__FileSystem:
			soap_serialize__jsdl__FileSystem(soap, (const struct jsdl__FileSystem_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__CPUArchitecture:
			soap_serialize__jsdl__CPUArchitecture(soap, (const struct jsdl__CPUArchitecture_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__OperatingSystemType:
			soap_serialize__jsdl__OperatingSystemType(soap, (const struct jsdl__OperatingSystemType_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__OperatingSystem:
			soap_serialize__jsdl__OperatingSystem(soap, (const struct jsdl__OperatingSystem_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__CandidateHosts:
			soap_serialize__jsdl__CandidateHosts(soap, (const struct jsdl__CandidateHosts_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__Resources:
			soap_serialize__jsdl__Resources(soap, (const struct jsdl__Resources_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__Application:
			soap_serialize__jsdl__Application(soap, (const struct jsdl__Application_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__JobIdentification:
			soap_serialize__jsdl__JobIdentification(soap, (const struct jsdl__JobIdentification_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__JobDescription:
			soap_serialize__jsdl__JobDescription(soap, (const struct jsdl__JobDescription_USCOREType *)ptr);
			break;
		case SOAP_TYPE__jsdl__JobDefinition:
			soap_serialize__jsdl__JobDefinition(soap, (const struct jsdl__JobDefinition_USCOREType *)ptr);
			break;
		case SOAP_TYPE__wsa__ProblemAction:
			soap_serialize__wsa__ProblemAction(soap, (const struct wsa__ProblemActionType *)ptr);
			break;
		case SOAP_TYPE__wsa__ProblemIRI:
			soap_serialize__wsa__ProblemIRI(soap, (const struct wsa__AttributedURIType *)ptr);
			break;
		case SOAP_TYPE__wsa__ProblemHeaderQName:
			soap_serialize__wsa__ProblemHeaderQName(soap, (const struct wsa__AttributedQNameType *)ptr);
			break;
		case SOAP_TYPE__wsa__RetryAfter:
			soap_serialize__wsa__RetryAfter(soap, (const struct wsa__AttributedUnsignedLongType *)ptr);
			break;
		case SOAP_TYPE__wsa__Action:
			soap_serialize__wsa__Action(soap, (const struct wsa__AttributedURIType *)ptr);
			break;
		case SOAP_TYPE__wsa__To:
			soap_serialize__wsa__To(soap, (const struct wsa__AttributedURIType *)ptr);
			break;
		case SOAP_TYPE__wsa__FaultTo:
			soap_serialize__wsa__FaultTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
			break;
		case SOAP_TYPE__wsa__From:
			soap_serialize__wsa__From(soap, (const struct wsa__EndpointReferenceType *)ptr);
			break;
		case SOAP_TYPE__wsa__ReplyTo:
			soap_serialize__wsa__ReplyTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
			break;
		case SOAP_TYPE__wsa__RelatesTo:
			soap_serialize__wsa__RelatesTo(soap, (const struct wsa__RelatesToType *)ptr);
			break;
		case SOAP_TYPE__wsa__MessageID:
			soap_serialize__wsa__MessageID(soap, (const struct wsa__AttributedURIType *)ptr);
			break;
		case SOAP_TYPE__wsa__Metadata:
			soap_serialize__wsa__Metadata(soap, (const struct wsa__MetadataType *)ptr);
			break;
		case SOAP_TYPE__wsa__ReferenceParameters:
			soap_serialize__wsa__ReferenceParameters(soap, (const struct wsa__ReferenceParametersType *)ptr);
			break;
		case SOAP_TYPE__wsa__EndpointReference:
			soap_serialize__wsa__EndpointReference(soap, (const struct wsa__EndpointReferenceType *)ptr);
			break;
		case SOAP_TYPE__bes__ActivityStatus:
			soap_serialize__bes__ActivityStatus(soap, (const struct bes__ActivityStatusType *)ptr);
			break;
		case SOAP_TYPE__bes__ActivityDocument:
			soap_serialize__bes__ActivityDocument(soap, (const struct bes__ActivityDocumentType *)ptr);
			break;
		case SOAP_TYPE__bes__FactoryResourceAttributesDocument:
			soap_serialize__bes__FactoryResourceAttributesDocument(soap, (const struct bes__FactoryResourceAttributesDocumentType *)ptr);
			break;
		case SOAP_TYPE__bes__BasicResourceAttributesDocument:
			soap_serialize__bes__BasicResourceAttributesDocument(soap, (const struct bes__BasicResourceAttributesDocumentType *)ptr);
			break;
		case SOAP_TYPE__bes__InvalidRequestMessageFault:
			soap_serialize__bes__InvalidRequestMessageFault(soap, (const struct bes__InvalidRequestMessageFaultType *)ptr);
			break;
		case SOAP_TYPE__bes__InvalidActivityIdentifierFault:
			soap_serialize__bes__InvalidActivityIdentifierFault(soap, (const struct bes__InvalidActivityIdentifierFaultType *)ptr);
			break;
		case SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault:
			soap_serialize__bes__OperationWillBeAppliedEventuallyFault(soap, (const struct bes__OperationWillBeAppliedEventuallyFaultType *)ptr);
			break;
		case SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault:
			soap_serialize__bes__CantApplyOperationToCurrentStateFault(soap, (const struct bes__CantApplyOperationToCurrentStateFaultType *)ptr);
			break;
		case SOAP_TYPE__bes__UnsupportedFeatureFault:
			soap_serialize__bes__UnsupportedFeatureFault(soap, (const struct bes__UnsupportedFeatureFaultType *)ptr);
			break;
		case SOAP_TYPE__bes__NotAcceptingNewActivitiesFault:
			soap_serialize__bes__NotAcceptingNewActivitiesFault(soap, (const struct bes__NotAcceptingNewActivitiesFaultType *)ptr);
			break;
		case SOAP_TYPE__bes__NotAuthorizedFault:
			soap_serialize__bes__NotAuthorizedFault(soap, (const struct bes__NotAuthorizedFaultType *)ptr);
			break;
		case SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse:
			soap_serialize__bes__GetFactoryAttributesDocumentResponse(soap, (const struct bes__GetFactoryAttributesDocumentResponseType *)ptr);
			break;
		case SOAP_TYPE__bes__GetFactoryAttributesDocument:
			soap_serialize__bes__GetFactoryAttributesDocument(soap, (const struct bes__GetFactoryAttributesDocumentType *)ptr);
			break;
		case SOAP_TYPE__bes__GetActivityDocumentsResponse:
			soap_serialize__bes__GetActivityDocumentsResponse(soap, (const struct bes__GetActivityDocumentsResponseType *)ptr);
			break;
		case SOAP_TYPE__bes__GetActivityDocuments:
			soap_serialize__bes__GetActivityDocuments(soap, (const struct bes__GetActivityDocumentsType *)ptr);
			break;
		case SOAP_TYPE__bes__TerminateActivitiesResponse:
			soap_serialize__bes__TerminateActivitiesResponse(soap, (const struct bes__TerminateActivitiesResponseType *)ptr);
			break;
		case SOAP_TYPE__bes__TerminateActivities:
			soap_serialize__bes__TerminateActivities(soap, (const struct bes__TerminateActivitiesType *)ptr);
			break;
		case SOAP_TYPE__bes__GetActivityStatusesResponse:
			soap_serialize__bes__GetActivityStatusesResponse(soap, (const struct bes__GetActivityStatusesResponseType *)ptr);
			break;
		case SOAP_TYPE__bes__GetActivityStatuses:
			soap_serialize__bes__GetActivityStatuses(soap, (const struct bes__GetActivityStatusesType *)ptr);
			break;
		case SOAP_TYPE__bes__CreateActivityResponse:
			soap_serialize__bes__CreateActivityResponse(soap, (const struct bes__CreateActivityResponseType *)ptr);
			break;
		case SOAP_TYPE__bes__CreateActivity:
			soap_serialize__bes__CreateActivity(soap, (const struct bes__CreateActivityType *)ptr);
			break;
		case SOAP_TYPE_jsdl_hpcpa__HPCProfileApplication_USCOREType:
			soap_serialize_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, (const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType:
			soap_serialize_jsdl_hpcpa__UserName_USCOREType(soap, (const struct jsdl_hpcpa__UserName_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType:
			soap_serialize_jsdl_hpcpa__DirectoryName_USCOREType(soap, (const struct jsdl_hpcpa__DirectoryName_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType:
			soap_serialize_jsdl_hpcpa__FileName_USCOREType(soap, (const struct jsdl_hpcpa__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType:
			soap_serialize_jsdl_hpcpa__Argument_USCOREType(soap, (const struct jsdl_hpcpa__Argument_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType:
			soap_serialize_jsdl_hpcpa__Environment_USCOREType(soap, (const struct jsdl_hpcpa__Environment_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_posix__POSIXApplication_USCOREType:
			soap_serialize_jsdl_posix__POSIXApplication_USCOREType(soap, (const struct jsdl_posix__POSIXApplication_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_posix__GroupName_USCOREType:
			soap_serialize_jsdl_posix__GroupName_USCOREType(soap, (const struct jsdl_posix__GroupName_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_posix__UserName_USCOREType:
			soap_serialize_jsdl_posix__UserName_USCOREType(soap, (const struct jsdl_posix__UserName_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_posix__Limits_USCOREType:
			soap_serialize_jsdl_posix__Limits_USCOREType(soap, (const struct jsdl_posix__Limits_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType:
			soap_serialize_jsdl_posix__DirectoryName_USCOREType(soap, (const struct jsdl_posix__DirectoryName_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_posix__FileName_USCOREType:
			soap_serialize_jsdl_posix__FileName_USCOREType(soap, (const struct jsdl_posix__FileName_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_posix__Argument_USCOREType:
			soap_serialize_jsdl_posix__Argument_USCOREType(soap, (const struct jsdl_posix__Argument_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl_posix__Environment_USCOREType:
			soap_serialize_jsdl_posix__Environment_USCOREType(soap, (const struct jsdl_posix__Environment_USCOREType *)ptr);
			break;
		case SOAP_TYPE_hpcp_af__DynamicNodeStatusType:
			soap_serialize_hpcp_af__DynamicNodeStatusType(soap, (const struct hpcp_af__DynamicNodeStatusType *)ptr);
			break;
		case SOAP_TYPE_hpcp_af__ActivityIdType:
			soap_serialize_hpcp_af__ActivityIdType(soap, (const struct hpcp_af__ActivityIdType *)ptr);
			break;
		case SOAP_TYPE_hpcp_af__CPUType:
			soap_serialize_hpcp_af__CPUType(soap, (const struct hpcp_af__CPUType *)ptr);
			break;
		case SOAP_TYPE_hpcp_af__MemoryType:
			soap_serialize_hpcp_af__MemoryType(soap, (const struct hpcp_af__MemoryType *)ptr);
			break;
		case SOAP_TYPE_hpcp_af__NodeStatusType:
			soap_serialize_hpcp_af__NodeStatusType(soap, (const struct hpcp_af__NodeStatusType *)ptr);
			break;
		case SOAP_TYPE_hpcp_af__ActivityIdRangeType:
			soap_serialize_hpcp_af__ActivityIdRangeType(soap, (const struct hpcp_af__ActivityIdRangeType *)ptr);
			break;
		case SOAP_TYPE_hpcp_af__DateTimeRangeType:
			soap_serialize_hpcp_af__DateTimeRangeType(soap, (const struct hpcp_af__DateTimeRangeType *)ptr);
			break;
		case SOAP_TYPE_hpcp_af__AdvancedFilterType:
			soap_serialize_hpcp_af__AdvancedFilterType(soap, (const struct hpcp_af__AdvancedFilterType *)ptr);
			break;
		case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
			soap_serialize_jsdl__SourceTarget_USCOREType(soap, (const struct jsdl__SourceTarget_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__DataStaging_USCOREType:
			soap_serialize_jsdl__DataStaging_USCOREType(soap, (const struct jsdl__DataStaging_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
			soap_serialize_jsdl__OperatingSystemType_USCOREType(soap, (const struct jsdl__OperatingSystemType_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
			soap_serialize_jsdl__OperatingSystem_USCOREType(soap, (const struct jsdl__OperatingSystem_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__FileSystem_USCOREType:
			soap_serialize_jsdl__FileSystem_USCOREType(soap, (const struct jsdl__FileSystem_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
			soap_serialize_jsdl__CPUArchitecture_USCOREType(soap, (const struct jsdl__CPUArchitecture_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
			soap_serialize_jsdl__CandidateHosts_USCOREType(soap, (const struct jsdl__CandidateHosts_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__Resources_USCOREType:
			soap_serialize_jsdl__Resources_USCOREType(soap, (const struct jsdl__Resources_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__Application_USCOREType:
			soap_serialize_jsdl__Application_USCOREType(soap, (const struct jsdl__Application_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
			soap_serialize_jsdl__JobIdentification_USCOREType(soap, (const struct jsdl__JobIdentification_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__JobDescription_USCOREType:
			soap_serialize_jsdl__JobDescription_USCOREType(soap, (const struct jsdl__JobDescription_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
			soap_serialize_jsdl__JobDefinition_USCOREType(soap, (const struct jsdl__JobDefinition_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__RangeValue_USCOREType:
			soap_serialize_jsdl__RangeValue_USCOREType(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__Range_USCOREType:
			soap_serialize_jsdl__Range_USCOREType(soap, (const struct jsdl__Range_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__Exact_USCOREType:
			soap_serialize_jsdl__Exact_USCOREType(soap, (const struct jsdl__Exact_USCOREType *)ptr);
			break;
		case SOAP_TYPE_jsdl__Boundary_USCOREType:
			soap_serialize_jsdl__Boundary_USCOREType(soap, (const struct jsdl__Boundary_USCOREType *)ptr);
			break;
		case SOAP_TYPE_wsa__ProblemActionType:
			soap_serialize_wsa__ProblemActionType(soap, (const struct wsa__ProblemActionType *)ptr);
			break;
		case SOAP_TYPE_wsa__AttributedQNameType:
			soap_serialize_wsa__AttributedQNameType(soap, (const struct wsa__AttributedQNameType *)ptr);
			break;
		case SOAP_TYPE_wsa__AttributedUnsignedLongType:
			soap_serialize_wsa__AttributedUnsignedLongType(soap, (const struct wsa__AttributedUnsignedLongType *)ptr);
			break;
		case SOAP_TYPE_wsa__AttributedURIType:
			soap_serialize_wsa__AttributedURIType(soap, (const struct wsa__AttributedURIType *)ptr);
			break;
		case SOAP_TYPE_wsa__RelatesToType:
			soap_serialize_wsa__RelatesToType(soap, (const struct wsa__RelatesToType *)ptr);
			break;
		case SOAP_TYPE_wsa__MetadataType:
			soap_serialize_wsa__MetadataType(soap, (const struct wsa__MetadataType *)ptr);
			break;
		case SOAP_TYPE_wsa__ReferenceParametersType:
			soap_serialize_wsa__ReferenceParametersType(soap, (const struct wsa__ReferenceParametersType *)ptr);
			break;
		case SOAP_TYPE_wsa__EndpointReferenceType:
			soap_serialize_wsa__EndpointReferenceType(soap, (const struct wsa__EndpointReferenceType *)ptr);
			break;
		case SOAP_TYPE_bes__TerminateActivityResponseType:
			soap_serialize_bes__TerminateActivityResponseType(soap, (const struct bes__TerminateActivityResponseType *)ptr);
			break;
		case SOAP_TYPE_bes__GetActivityDocumentResponseType:
			soap_serialize_bes__GetActivityDocumentResponseType(soap, (const struct bes__GetActivityDocumentResponseType *)ptr);
			break;
		case SOAP_TYPE_bes__GetActivityStatusResponseType:
			soap_serialize_bes__GetActivityStatusResponseType(soap, (const struct bes__GetActivityStatusResponseType *)ptr);
			break;
		case SOAP_TYPE_bes__ActivityStatusType:
			soap_serialize_bes__ActivityStatusType(soap, (const struct bes__ActivityStatusType *)ptr);
			break;
		case SOAP_TYPE_bes__ActivityDocumentType:
			soap_serialize_bes__ActivityDocumentType(soap, (const struct bes__ActivityDocumentType *)ptr);
			break;
		case SOAP_TYPE_bes__FactoryResourceAttributesDocumentType:
			soap_serialize_bes__FactoryResourceAttributesDocumentType(soap, (const struct bes__FactoryResourceAttributesDocumentType *)ptr);
			break;
		case SOAP_TYPE_bes__BasicResourceAttributesDocumentType:
			soap_serialize_bes__BasicResourceAttributesDocumentType(soap, (const struct bes__BasicResourceAttributesDocumentType *)ptr);
			break;
		case SOAP_TYPE_bes__InvalidRequestMessageFaultType:
			soap_serialize_bes__InvalidRequestMessageFaultType(soap, (const struct bes__InvalidRequestMessageFaultType *)ptr);
			break;
		case SOAP_TYPE_bes__InvalidActivityIdentifierFaultType:
			soap_serialize_bes__InvalidActivityIdentifierFaultType(soap, (const struct bes__InvalidActivityIdentifierFaultType *)ptr);
			break;
		case SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType:
			soap_serialize_bes__OperationWillBeAppliedEventuallyFaultType(soap, (const struct bes__OperationWillBeAppliedEventuallyFaultType *)ptr);
			break;
		case SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType:
			soap_serialize_bes__CantApplyOperationToCurrentStateFaultType(soap, (const struct bes__CantApplyOperationToCurrentStateFaultType *)ptr);
			break;
		case SOAP_TYPE_bes__UnsupportedFeatureFaultType:
			soap_serialize_bes__UnsupportedFeatureFaultType(soap, (const struct bes__UnsupportedFeatureFaultType *)ptr);
			break;
		case SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType:
			soap_serialize_bes__NotAcceptingNewActivitiesFaultType(soap, (const struct bes__NotAcceptingNewActivitiesFaultType *)ptr);
			break;
		case SOAP_TYPE_bes__NotAuthorizedFaultType:
			soap_serialize_bes__NotAuthorizedFaultType(soap, (const struct bes__NotAuthorizedFaultType *)ptr);
			break;
		case SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType:
			soap_serialize_bes__GetFactoryAttributesDocumentResponseType(soap, (const struct bes__GetFactoryAttributesDocumentResponseType *)ptr);
			break;
		case SOAP_TYPE_bes__GetFactoryAttributesDocumentType:
			soap_serialize_bes__GetFactoryAttributesDocumentType(soap, (const struct bes__GetFactoryAttributesDocumentType *)ptr);
			break;
		case SOAP_TYPE_bes__GetActivityDocumentsResponseType:
			soap_serialize_bes__GetActivityDocumentsResponseType(soap, (const struct bes__GetActivityDocumentsResponseType *)ptr);
			break;
		case SOAP_TYPE_bes__GetActivityDocumentsType:
			soap_serialize_bes__GetActivityDocumentsType(soap, (const struct bes__GetActivityDocumentsType *)ptr);
			break;
		case SOAP_TYPE_bes__TerminateActivitiesResponseType:
			soap_serialize_bes__TerminateActivitiesResponseType(soap, (const struct bes__TerminateActivitiesResponseType *)ptr);
			break;
		case SOAP_TYPE_bes__TerminateActivitiesType:
			soap_serialize_bes__TerminateActivitiesType(soap, (const struct bes__TerminateActivitiesType *)ptr);
			break;
		case SOAP_TYPE_bes__GetActivityStatusesResponseType:
			soap_serialize_bes__GetActivityStatusesResponseType(soap, (const struct bes__GetActivityStatusesResponseType *)ptr);
			break;
		case SOAP_TYPE_bes__GetActivityStatusesType:
			soap_serialize_bes__GetActivityStatusesType(soap, (const struct bes__GetActivityStatusesType *)ptr);
			break;
		case SOAP_TYPE_bes__CreateActivityResponseType:
			soap_serialize_bes__CreateActivityResponseType(soap, (const struct bes__CreateActivityResponseType *)ptr);
			break;
		case SOAP_TYPE_bes__CreateActivityType:
			soap_serialize_bes__CreateActivityType(soap, (const struct bes__CreateActivityType *)ptr);
			break;
		case SOAP_TYPE_xsd__anyType:
			soap_serialize_xsd__anyType(soap, (const struct soap_dom_element *)ptr);
			break;
		case SOAP_TYPE__wsse__Security:
			soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
			break;
		case SOAP_TYPE_ds__RSAKeyValueType:
			soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
			break;
		case SOAP_TYPE_ds__DSAKeyValueType:
			soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
			break;
		case SOAP_TYPE_ds__X509IssuerSerialType:
			soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
			break;
		case SOAP_TYPE_ds__X509DataType:
			soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
			break;
		case SOAP_TYPE_ds__RetrievalMethodType:
			soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
			break;
		case SOAP_TYPE_ds__KeyValueType:
			soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
			break;
		case SOAP_TYPE_ds__DigestMethodType:
			soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
			break;
		case SOAP_TYPE_ds__TransformType:
			soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
			break;
		case SOAP_TYPE__c14n__InclusiveNamespaces:
			soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
			break;
		case SOAP_TYPE_ds__TransformsType:
			soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
			break;
		case SOAP_TYPE_ds__ReferenceType:
			soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
			break;
		case SOAP_TYPE_ds__SignatureMethodType:
			soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
			break;
		case SOAP_TYPE_ds__CanonicalizationMethodType:
			soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
			break;
		case SOAP_TYPE_ds__KeyInfoType:
			soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
			break;
		case SOAP_TYPE_ds__SignedInfoType:
			soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
			break;
		case SOAP_TYPE_ds__SignatureType:
			soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
			break;
		case SOAP_TYPE__wsse__SecurityTokenReference:
			soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
			break;
		case SOAP_TYPE__wsse__KeyIdentifier:
			soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
			break;
		case SOAP_TYPE__wsse__Embedded:
			soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
			break;
		case SOAP_TYPE__wsse__Reference:
			soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
			break;
		case SOAP_TYPE__wsse__BinarySecurityToken:
			soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
			break;
		case SOAP_TYPE__wsse__Password:
			soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
			break;
		case SOAP_TYPE__wsse__UsernameToken:
			soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
			break;
		case SOAP_TYPE__wsu__Timestamp:
			soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
			break;
		case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentResponseType:
			soap_serialize_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, (struct bes__GetFactoryAttributesDocumentResponseType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__GetActivityDocumentsResponseType:
			soap_serialize_PointerTobes__GetActivityDocumentsResponseType(soap, (struct bes__GetActivityDocumentsResponseType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__TerminateActivitiesResponseType:
			soap_serialize_PointerTobes__TerminateActivitiesResponseType(soap, (struct bes__TerminateActivitiesResponseType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__GetActivityStatusesResponseType:
			soap_serialize_PointerTobes__GetActivityStatusesResponseType(soap, (struct bes__GetActivityStatusesResponseType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__CreateActivityResponseType:
			soap_serialize_PointerTobes__CreateActivityResponseType(soap, (struct bes__CreateActivityResponseType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__CreateActivityType:
			soap_serialize_PointerTobes__CreateActivityType(soap, (struct bes__CreateActivityType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__UnsupportedFeatureFaultType:
			soap_serialize_PointerTobes__UnsupportedFeatureFaultType(soap, (struct bes__UnsupportedFeatureFaultType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__NotAuthorizedFaultType:
			soap_serialize_PointerTobes__NotAuthorizedFaultType(soap, (struct bes__NotAuthorizedFaultType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__NotAcceptingNewActivitiesFaultType:
			soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, (struct bes__NotAcceptingNewActivitiesFaultType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__InvalidRequestMessageFaultType:
			soap_serialize_PointerTobes__InvalidRequestMessageFaultType(soap, (struct bes__InvalidRequestMessageFaultType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsa__FaultTo:
			soap_serialize_PointerTo_wsa__FaultTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsa__ReplyTo:
			soap_serialize_PointerTo_wsa__ReplyTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsa__From:
			soap_serialize_PointerTo_wsa__From(soap, (struct wsa__EndpointReferenceType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsa__RelatesTo:
			soap_serialize_PointerTo_wsa__RelatesTo(soap, (struct wsa__RelatesToType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsse__Security:
			soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
			break;
		case SOAP_TYPE__jsdl__URI:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__FilesystemName:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__FileName:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__MountPoint:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__OperatingSystemVersion:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__HostName:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__ApplicationVersion:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__ApplicationName:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__JobProject:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__JobAnnotation:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__Description:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE__jsdl__JobName:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_hpcpa__UserName_USCOREType:
			soap_serialize_PointerTojsdl_hpcpa__UserName_USCOREType(soap, (struct jsdl_hpcpa__UserName_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_hpcpa__Environment_USCOREType:
			soap_serialize_PointerTojsdl_hpcpa__Environment_USCOREType(soap, (struct jsdl_hpcpa__Environment_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_hpcpa__DirectoryName_USCOREType:
			soap_serialize_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, (struct jsdl_hpcpa__DirectoryName_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_hpcpa__Argument_USCOREType:
			soap_serialize_PointerTojsdl_hpcpa__Argument_USCOREType(soap, (struct jsdl_hpcpa__Argument_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_hpcpa__FileName_USCOREType:
			soap_serialize_PointerTojsdl_hpcpa__FileName_USCOREType(soap, (struct jsdl_hpcpa__FileName_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_posix__GroupName_USCOREType:
			soap_serialize_PointerTojsdl_posix__GroupName_USCOREType(soap, (struct jsdl_posix__GroupName_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_posix__UserName_USCOREType:
			soap_serialize_PointerTojsdl_posix__UserName_USCOREType(soap, (struct jsdl_posix__UserName_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_posix__Limits_USCOREType:
			soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, (struct jsdl_posix__Limits_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_posix__Environment_USCOREType:
			soap_serialize_PointerTojsdl_posix__Environment_USCOREType(soap, (struct jsdl_posix__Environment_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_posix__DirectoryName_USCOREType:
			soap_serialize_PointerTojsdl_posix__DirectoryName_USCOREType(soap, (struct jsdl_posix__DirectoryName_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_posix__Argument_USCOREType:
			soap_serialize_PointerTojsdl_posix__Argument_USCOREType(soap, (struct jsdl_posix__Argument_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl_posix__FileName_USCOREType:
			soap_serialize_PointerTojsdl_posix__FileName_USCOREType(soap, (struct jsdl_posix__FileName_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTohpcp_af__NodeStatusType:
			soap_serialize_PointerTohpcp_af__NodeStatusType(soap, (struct hpcp_af__NodeStatusType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTohpcp_af__ActivityIdType:
			soap_serialize_PointerTohpcp_af__ActivityIdType(soap, (struct hpcp_af__ActivityIdType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTohpcp_af__CPUType:
			soap_serialize_PointerTohpcp_af__CPUType(soap, (struct hpcp_af__CPUType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTohpcp_af__MemoryType:
			soap_serialize_PointerTohpcp_af__MemoryType(soap, (struct hpcp_af__MemoryType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTohpcp_af__DateTimeRangeType:
			soap_serialize_PointerTohpcp_af__DateTimeRangeType(soap, (struct hpcp_af__DateTimeRangeType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTohpcp_af__ActivityIdRangeType:
			soap_serialize_PointerTohpcp_af__ActivityIdRangeType(soap, (struct hpcp_af__ActivityIdRangeType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__ActivityStateEnumeration:
			soap_serialize_PointerTobes__ActivityStateEnumeration(soap, (enum bes__ActivityStateEnumeration *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
			soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, (struct jsdl__SourceTarget_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
			soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, (struct jsdl__OperatingSystemType_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
			soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, (enum jsdl__FileSystemTypeEnumeration *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
			soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, (struct jsdl__RangeValue_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerToxsd__boolean:
			soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
			soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, (struct jsdl__FileSystem_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
			soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, (struct jsdl__CandidateHosts_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
			soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, (struct jsdl__DataStaging_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
			soap_serialize_PointerTojsdl__Resources_USCOREType(soap, (struct jsdl__Resources_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
			soap_serialize_PointerTojsdl__Application_USCOREType(soap, (struct jsdl__Application_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
			soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, (struct jsdl__JobIdentification_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
			soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, (struct jsdl__JobDescription_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
			soap_serialize_PointerTojsdl__Range_USCOREType(soap, (struct jsdl__Range_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
			soap_serialize_PointerTojsdl__Exact_USCOREType(soap, (struct jsdl__Exact_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
			soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, (struct jsdl__Boundary_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTowsa__MetadataType:
			soap_serialize_PointerTowsa__MetadataType(soap, (struct wsa__MetadataType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
			soap_serialize_PointerTowsa__ReferenceParametersType(soap, (struct wsa__ReferenceParametersType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTowsa__AttributedURIType:
			soap_serialize_PointerTowsa__AttributedURIType(soap, (struct wsa__AttributedURIType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
			soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, (struct jsdl__JobDefinition_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTohpcp_af__AdvancedFilterType:
			soap_serialize_PointerTohpcp_af__AdvancedFilterType(soap, (struct hpcp_af__AdvancedFilterType *const*)ptr);
			break;
		case SOAP_TYPE_PointerToxsd__anyURI:
			soap_serialize_PointerToxsd__anyURI(soap, (char **const*)ptr);
			break;
		case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
			soap_serialize_PointerTowsa__EndpointReferenceType(soap, (struct wsa__EndpointReferenceType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__BasicResourceAttributesDocumentType:
			soap_serialize_PointerTobes__BasicResourceAttributesDocumentType(soap, (struct bes__BasicResourceAttributesDocumentType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTodouble:
			soap_serialize_PointerTodouble(soap, (double *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
			soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, (struct jsdl__CPUArchitecture_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
			soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, (struct jsdl__OperatingSystem_USCOREType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTobes__ActivityStatusType:
			soap_serialize_PointerTobes__ActivityStatusType(soap, (struct bes__ActivityStatusType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTostring:
			soap_serialize_PointerTostring(soap, (char **const*)ptr);
			break;
		case SOAP_TYPE_jsdl__Description_USCOREType:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_wsa__FaultCodesOpenEnumType:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_wsa__RelationshipTypeOpenEnum:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_PointerToxsd__anyType:
			soap_serialize_PointerToxsd__anyType(soap, (struct soap_dom_element *const*)ptr);
			break;
		case SOAP_TYPE_xsd__normalizedString:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_xsd__nonNegativeInteger:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_xsd__anyURI:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_xsd__QName:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_xsd__NCName:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_xsd__ID:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_PointerTods__SignatureType:
			soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
			soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsse__UsernameToken:
			soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsu__Timestamp:
			soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__X509IssuerSerialType:
			soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__RSAKeyValueType:
			soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__DSAKeyValueType:
			soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__TransformType:
			soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__DigestMethodType:
			soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__TransformsType:
			soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
			break;
		case SOAP_TYPE_PointerToint:
			soap_serialize_PointerToint(soap, (int *const*)ptr);
			break;
		case SOAP_TYPE_PointerToPointerTods__ReferenceType:
			soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__ReferenceType:
			soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__SignatureMethodType:
			soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
			soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
			soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__X509DataType:
			soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__RetrievalMethodType:
			soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__KeyValueType:
			soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
			soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__KeyInfoType:
			soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTods__SignedInfoType:
			soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsse__Embedded:
			soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
			soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsse__Reference:
			soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
			break;
		case SOAP_TYPE_PointerTo_wsse__Password:
			soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
			break;
		case SOAP_TYPE__QName:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
		case SOAP_TYPE_string:
			soap_serialize_string(soap, (char*const*)&ptr);
			break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4
soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4
soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4
soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4
soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4
soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4
soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4
soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4
soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4
soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4
soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4
soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4
soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__DeleteOnTermination(struct soap *soap, enum xsd__boolean *a)
{	soap_default_xsd__boolean(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__DeleteOnTermination(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__DeleteOnTermination);
	if (soap_out__jsdl__DeleteOnTermination(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S
soap__jsdl__DeleteOnTermination2s(struct soap *soap, enum xsd__boolean n)
{	return soap_xsd__boolean2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__DeleteOnTermination(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__DeleteOnTermination), type);
	soap_send(soap, soap__jsdl__DeleteOnTermination2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get__jsdl__DeleteOnTermination(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__DeleteOnTermination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2_jsdl__DeleteOnTermination(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	return soap_s2xsd__boolean(soap, s, a);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in__jsdl__DeleteOnTermination(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__DeleteOnTermination, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2_jsdl__DeleteOnTermination(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__DeleteOnTermination, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__CreationFlag(struct soap *soap, enum jsdl__CreationFlagEnumeration *a)
{	soap_default_jsdl__CreationFlagEnumeration(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__CreationFlag(struct soap *soap, const enum jsdl__CreationFlagEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__CreationFlag);
	if (soap_out__jsdl__CreationFlag(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S
soap__jsdl__CreationFlag2s(struct soap *soap, enum jsdl__CreationFlagEnumeration n)
{	return soap_jsdl__CreationFlagEnumeration2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__CreationFlag(struct soap *soap, const char *tag, int id, const enum jsdl__CreationFlagEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__CreationFlag), type);
	soap_send(soap, soap__jsdl__CreationFlag2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_get__jsdl__CreationFlag(struct soap *soap, enum jsdl__CreationFlagEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__CreationFlag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2_jsdl__CreationFlag(struct soap *soap, const char *s, enum jsdl__CreationFlagEnumeration *a)
{
	return soap_s2jsdl__CreationFlagEnumeration(soap, s, a);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_in__jsdl__CreationFlag(struct soap *soap, const char *tag, enum jsdl__CreationFlagEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "jsdl:CreationFlagEnumeration")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum jsdl__CreationFlagEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__CreationFlag, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2_jsdl__CreationFlag(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum jsdl__CreationFlagEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__CreationFlag, 0, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__FileSystemType(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *a)
{	soap_default_jsdl__FileSystemTypeEnumeration(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__FileSystemType(struct soap *soap, const enum jsdl__FileSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__FileSystemType);
	if (soap_out__jsdl__FileSystemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S
soap__jsdl__FileSystemType2s(struct soap *soap, enum jsdl__FileSystemTypeEnumeration n)
{	return soap_jsdl__FileSystemTypeEnumeration2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__FileSystemType(struct soap *soap, const char *tag, int id, const enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__FileSystemType), type);
	soap_send(soap, soap__jsdl__FileSystemType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_get__jsdl__FileSystemType(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__FileSystemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2_jsdl__FileSystemType(struct soap *soap, const char *s, enum jsdl__FileSystemTypeEnumeration *a)
{
	return soap_s2jsdl__FileSystemTypeEnumeration(soap, s, a);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_in__jsdl__FileSystemType(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "jsdl:FileSystemTypeEnumeration")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__FileSystemType, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2_jsdl__FileSystemType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__FileSystemType, 0, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__CPUArchitectureName(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *a)
{	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__CPUArchitectureName(struct soap *soap, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__CPUArchitectureName);
	if (soap_out__jsdl__CPUArchitectureName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S
soap__jsdl__CPUArchitectureName2s(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration n)
{	return soap_jsdl__ProcessorArchitectureEnumeration2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__CPUArchitectureName(struct soap *soap, const char *tag, int id, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__CPUArchitectureName), type);
	soap_send(soap, soap__jsdl__CPUArchitectureName2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_get__jsdl__CPUArchitectureName(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__CPUArchitectureName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2_jsdl__CPUArchitectureName(struct soap *soap, const char *s, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	return soap_s2jsdl__ProcessorArchitectureEnumeration(soap, s, a);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_in__jsdl__CPUArchitectureName(struct soap *soap, const char *tag, enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "jsdl:ProcessorArchitectureEnumeration")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__CPUArchitectureName, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2_jsdl__CPUArchitectureName(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__CPUArchitectureName, 0, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__ExclusiveExecution(struct soap *soap, enum xsd__boolean *a)
{	soap_default_xsd__boolean(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__ExclusiveExecution(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__ExclusiveExecution);
	if (soap_out__jsdl__ExclusiveExecution(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S
soap__jsdl__ExclusiveExecution2s(struct soap *soap, enum xsd__boolean n)
{	return soap_xsd__boolean2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__ExclusiveExecution(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__ExclusiveExecution), type);
	soap_send(soap, soap__jsdl__ExclusiveExecution2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get__jsdl__ExclusiveExecution(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__ExclusiveExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2_jsdl__ExclusiveExecution(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	return soap_s2xsd__boolean(soap, s, a);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in__jsdl__ExclusiveExecution(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__ExclusiveExecution, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2_jsdl__ExclusiveExecution(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__ExclusiveExecution, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__OperatingSystemName(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *a)
{	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__OperatingSystemName(struct soap *soap, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__OperatingSystemName);
	if (soap_out__jsdl__OperatingSystemName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S
soap__jsdl__OperatingSystemName2s(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration n)
{	return soap_jsdl__OperatingSystemTypeEnumeration2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__OperatingSystemName(struct soap *soap, const char *tag, int id, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__OperatingSystemName), type);
	soap_send(soap, soap__jsdl__OperatingSystemName2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_get__jsdl__OperatingSystemName(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__OperatingSystemName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2_jsdl__OperatingSystemName(struct soap *soap, const char *s, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	return soap_s2jsdl__OperatingSystemTypeEnumeration(soap, s, a);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_in__jsdl__OperatingSystemName(struct soap *soap, const char *tag, enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "jsdl:OperatingSystemTypeEnumeration")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__OperatingSystemName, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2_jsdl__OperatingSystemName(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__OperatingSystemName, 0, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__IsReferenceParameter(struct soap *soap, enum xsd__boolean *a)
{	soap_default_xsd__boolean(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__IsReferenceParameter(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__IsReferenceParameter);
	if (soap_out__wsa__IsReferenceParameter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S
soap__wsa__IsReferenceParameter2s(struct soap *soap, enum xsd__boolean n)
{	return soap_xsd__boolean2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__IsReferenceParameter), type);
	soap_send(soap, soap__wsa__IsReferenceParameter2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get__wsa__IsReferenceParameter(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2_wsa__IsReferenceParameter(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	return soap_s2xsd__boolean(soap, s, a);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in__wsa__IsReferenceParameter(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__IsReferenceParameter, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2_wsa__IsReferenceParameter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__IsReferenceParameter, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__CreationFlagEnumeration
	*a = SOAP_DEFAULT_jsdl__CreationFlagEnumeration;
#else
	*a = (enum jsdl__CreationFlagEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__CreationFlagEnumeration(struct soap *soap, const enum jsdl__CreationFlagEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__CreationFlagEnumeration);
	if (soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__CreationFlagEnumeration[] =
	{	{(long)overwrite, "overwrite" },
	{(long)append, "append" },
	{(long)dontOverwrite, "dontOverwrite" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_jsdl__CreationFlagEnumeration2s(struct soap *soap, enum jsdl__CreationFlagEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__CreationFlagEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__CreationFlagEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CreationFlagEnumeration), type);
	soap_send(soap, soap_jsdl__CreationFlagEnumeration2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_get_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CreationFlagEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2jsdl__CreationFlagEnumeration(struct soap *soap, const char *s, enum jsdl__CreationFlagEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__CreationFlagEnumeration, s);
	if (map)
		*a = (enum jsdl__CreationFlagEnumeration)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__CreationFlagEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_in_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, enum jsdl__CreationFlagEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__CreationFlagEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CreationFlagEnumeration, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2jsdl__CreationFlagEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum jsdl__CreationFlagEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CreationFlagEnumeration, 0, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration;
#else
	*a = (enum jsdl__FileSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__FileSystemTypeEnumeration(struct soap *soap, const enum jsdl__FileSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
	if (soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__FileSystemTypeEnumeration[] =
	{	{(long)swap, "swap" },
	{(long)temporary, "temporary" },
	{(long)spool, "spool" },
	{(long)normal, "normal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_jsdl__FileSystemTypeEnumeration2s(struct soap *soap, enum jsdl__FileSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__FileSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration), type);
	soap_send(soap, soap_jsdl__FileSystemTypeEnumeration2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__FileSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__FileSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__FileSystemTypeEnumeration)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__FileSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2jsdl__FileSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, 0, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration;
#else
	*a = (enum jsdl__OperatingSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration);
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__OperatingSystemTypeEnumeration[] =
	{	{(long)Unknown, "Unknown" },
	{(long)MACOS, "MACOS" },
	{(long)ATTUNIX, "ATTUNIX" },
	{(long)DGUX, "DGUX" },
	{(long)DECNT, "DECNT" },
	{(long)Tru64_USCOREUNIX, "Tru64_UNIX" },
	{(long)OpenVMS, "OpenVMS" },
	{(long)HPUX, "HPUX" },
	{(long)AIX, "AIX" },
	{(long)MVS, "MVS" },
	{(long)OS400, "OS400" },
	{(long)OS_USCORE2, "OS_2" },
	{(long)JavaVM, "JavaVM" },
	{(long)MSDOS, "MSDOS" },
	{(long)WIN3x, "WIN3x" },
	{(long)WIN95, "WIN95" },
	{(long)WIN98, "WIN98" },
	{(long)WINNT, "WINNT" },
	{(long)WINCE, "WINCE" },
	{(long)NCR3000, "NCR3000" },
	{(long)NetWare, "NetWare" },
	{(long)OSF, "OSF" },
	{(long)DC_USCOREOS, "DC_OS" },
	{(long)Reliant_USCOREUNIX, "Reliant_UNIX" },
	{(long)SCO_USCOREUnixWare, "SCO_UnixWare" },
	{(long)SCO_USCOREOpenServer, "SCO_OpenServer" },
	{(long)Sequent, "Sequent" },
	{(long)IRIX, "IRIX" },
	{(long)Solaris, "Solaris" },
	{(long)SunOS, "SunOS" },
	{(long)U6000, "U6000" },
	{(long)ASERIES, "ASERIES" },
	{(long)TandemNSK, "TandemNSK" },
	{(long)TandemNT, "TandemNT" },
	{(long)BS2000, "BS2000" },
	{(long)LINUX, "LINUX" },
	{(long)Lynx, "Lynx" },
	{(long)XENIX, "XENIX" },
	{(long)VM, "VM" },
	{(long)Interactive_USCOREUNIX, "Interactive_UNIX" },
	{(long)BSDUNIX, "BSDUNIX" },
	{(long)FreeBSD, "FreeBSD" },
	{(long)NetBSD, "NetBSD" },
	{(long)GNU_USCOREHurd, "GNU_Hurd" },
	{(long)OS9, "OS9" },
	{(long)MACH_USCOREKernel, "MACH_Kernel" },
	{(long)Inferno, "Inferno" },
	{(long)QNX, "QNX" },
	{(long)EPOC, "EPOC" },
	{(long)IxWorks, "IxWorks" },
	{(long)VxWorks, "VxWorks" },
	{(long)MiNT, "MiNT" },
	{(long)BeOS, "BeOS" },
	{(long)HP_USCOREMPE, "HP_MPE" },
	{(long)NextStep, "NextStep" },
	{(long)PalmPilot, "PalmPilot" },
	{(long)Rhapsody, "Rhapsody" },
	{(long)Windows_USCORE2000, "Windows_2000" },
	{(long)Dedicated, "Dedicated" },
	{(long)OS_USCORE390, "OS_390" },
	{(long)VSE, "VSE" },
	{(long)TPF, "TPF" },
	{(long)Windows_USCORER_USCOREMe, "Windows_R_Me" },
	{(long)Caldera_USCOREOpen_USCOREUNIX, "Caldera_Open_UNIX" },
	{(long)OpenBSD, "OpenBSD" },
	{(long)Not_USCOREApplicable, "Not_Applicable" },
	{(long)Windows_USCOREXP, "Windows_XP" },
	{(long)z_USCOREOS, "z_OS" },
	{(long)other_, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_jsdl__OperatingSystemTypeEnumeration2s(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__OperatingSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration), type);
	soap_send(soap, soap_jsdl__OperatingSystemTypeEnumeration2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__OperatingSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__OperatingSystemTypeEnumeration)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 68)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__OperatingSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2jsdl__OperatingSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration, 0, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration
	*a = SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration;
#else
	*a = (enum jsdl__ProcessorArchitectureEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration);
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__ProcessorArchitectureEnumeration[] =
	{	{(long)sparc, "sparc" },
	{(long)powerpc, "powerpc" },
	{(long)x86, "x86" },
	{(long)x86_USCORE32, "x86_32" },
	{(long)x86_USCORE64, "x86_64" },
	{(long)parisc, "parisc" },
	{(long)mips, "mips" },
	{(long)ia64, "ia64" },
	{(long)arm, "arm" },
	{(long)other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_jsdl__ProcessorArchitectureEnumeration2s(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__ProcessorArchitectureEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration), type);
	soap_send(soap, soap_jsdl__ProcessorArchitectureEnumeration2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_get_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__ProcessorArchitectureEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *s, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__ProcessorArchitectureEnumeration, s);
	if (map)
		*a = (enum jsdl__ProcessorArchitectureEnumeration)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__ProcessorArchitectureEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_in_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2jsdl__ProcessorArchitectureEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration, 0, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__FaultCodesType(struct soap *soap, enum wsa__FaultCodesType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa__FaultCodesType
	*a = SOAP_DEFAULT_wsa__FaultCodesType;
#else
	*a = (enum wsa__FaultCodesType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__FaultCodesType(struct soap *soap, const enum wsa__FaultCodesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__FaultCodesType);
	if (soap_out_wsa__FaultCodesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsa__FaultCodesType[] =
	{	{(long)wsa__InvalidAddressingHeader, "wsa:InvalidAddressingHeader" },
	{(long)wsa__InvalidAddress, "wsa:InvalidAddress" },
	{(long)wsa__InvalidEPR, "wsa:InvalidEPR" },
	{(long)wsa__InvalidCardinality, "wsa:InvalidCardinality" },
	{(long)wsa__MissingAddressInEPR, "wsa:MissingAddressInEPR" },
	{(long)wsa__DuplicateMessageID, "wsa:DuplicateMessageID" },
	{(long)wsa__ActionMismatch, "wsa:ActionMismatch" },
	{(long)wsa__MessageAddressingHeaderRequired, "wsa:MessageAddressingHeaderRequired" },
	{(long)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{(long)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{(long)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_wsa__FaultCodesType2s(struct soap *soap, enum wsa__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_wsa__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa__FaultCodesType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultCodesType), type);
	soap_send(soap, soap_wsa__FaultCodesType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsa__FaultCodesType * SOAP_FMAC4 soap_get_wsa__FaultCodesType(struct soap *soap, enum wsa__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2wsa__FaultCodesType(struct soap *soap, const char *s, enum wsa__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsa__FaultCodesType, t);
	if (map)
		*a = (enum wsa__FaultCodesType)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultCodesType * SOAP_FMAC4 soap_in_wsa__FaultCodesType(struct soap *soap, const char *tag, enum wsa__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultCodesType, sizeof(enum wsa__FaultCodesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2wsa__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum wsa__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultCodesType, 0, sizeof(enum wsa__FaultCodesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__RelationshipType(struct soap *soap, enum wsa__RelationshipType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa__RelationshipType
	*a = SOAP_DEFAULT_wsa__RelationshipType;
#else
	*a = (enum wsa__RelationshipType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__RelationshipType(struct soap *soap, const enum wsa__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__RelationshipType);
	if (soap_out_wsa__RelationshipType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsa__RelationshipType[] =
	{	{(long)http___x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_wsa__RelationshipType2s(struct soap *soap, enum wsa__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_wsa__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipType), type);
	soap_send(soap, soap_wsa__RelationshipType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsa__RelationshipType * SOAP_FMAC4 soap_get_wsa__RelationshipType(struct soap *soap, enum wsa__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2wsa__RelationshipType(struct soap *soap, const char *s, enum wsa__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wsa__RelationshipType, s);
	if (map)
		*a = (enum wsa__RelationshipType)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipType * SOAP_FMAC4 soap_in_wsa__RelationshipType(struct soap *soap, const char *tag, enum wsa__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipType, sizeof(enum wsa__RelationshipType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2wsa__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum wsa__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipType, 0, sizeof(enum wsa__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__ActivityStateEnumeration(struct soap *soap, enum bes__ActivityStateEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bes__ActivityStateEnumeration
	*a = SOAP_DEFAULT_bes__ActivityStateEnumeration;
#else
	*a = (enum bes__ActivityStateEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__ActivityStateEnumeration(struct soap *soap, const enum bes__ActivityStateEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__ActivityStateEnumeration);
	if (soap_out_bes__ActivityStateEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bes__ActivityStateEnumeration[] =
	{	{(long)Pending, "Pending" },
	{(long)Running, "Running" },
	{(long)Cancelled, "Cancelled" },
	{(long)Failed, "Failed" },
	{(long)Finished, "Finished" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_bes__ActivityStateEnumeration2s(struct soap *soap, enum bes__ActivityStateEnumeration n)
{	const char *s = soap_code_str(soap_codes_bes__ActivityStateEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__ActivityStateEnumeration(struct soap *soap, const char *tag, int id, const enum bes__ActivityStateEnumeration *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__ActivityStateEnumeration), type);
	soap_send(soap, soap_bes__ActivityStateEnumeration2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum bes__ActivityStateEnumeration * SOAP_FMAC4 soap_get_bes__ActivityStateEnumeration(struct soap *soap, enum bes__ActivityStateEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__ActivityStateEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2bes__ActivityStateEnumeration(struct soap *soap, const char *s, enum bes__ActivityStateEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bes__ActivityStateEnumeration, s);
	if (map)
		*a = (enum bes__ActivityStateEnumeration)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum bes__ActivityStateEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum bes__ActivityStateEnumeration * SOAP_FMAC4 soap_in_bes__ActivityStateEnumeration(struct soap *soap, const char *tag, enum bes__ActivityStateEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum bes__ActivityStateEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__ActivityStateEnumeration, sizeof(enum bes__ActivityStateEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2bes__ActivityStateEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum bes__ActivityStateEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__ActivityStateEnumeration, 0, sizeof(enum bes__ActivityStateEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
	{	{(long)false_, "false" },
	{(long)true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{	return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type);
	soap_send(soap, soap_xsd__boolean2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else {
		long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
	if (soap_out_wsse__FaultcodeEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
	{	{(long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{(long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{(long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{(long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{(long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{(long)wsse__FailedCheck, "wsse:FailedCheck" },
	{(long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type);
	soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
	if (soap_out_wsu__tTimestampFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
	{	{(long)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S
soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type);
	soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S
soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else {
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href) {
		if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, "")) {
					soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string")) {
					soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string")) {
					soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, "")) {
					soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, "")) {
					soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, "")) {
					soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string")) {
					soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string")) {
					soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, "")) {
					soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string")) {
					soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, "")) {
					soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, "")) {
					soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default___bes__GetFactoryAttributesDocument(struct soap *soap, struct __bes__GetFactoryAttributesDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__GetFactoryAttributesDocumentType(soap, &a->bes__GetFactoryAttributesDocument);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize___bes__GetFactoryAttributesDocument(struct soap *soap, const struct __bes__GetFactoryAttributesDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__GetFactoryAttributesDocumentType(soap, &a->bes__GetFactoryAttributesDocument);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put___bes__GetFactoryAttributesDocument(struct soap *soap, const struct __bes__GetFactoryAttributesDocument *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__GetFactoryAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out___bes__GetFactoryAttributesDocument(struct soap *soap, const char *tag, int id, const struct __bes__GetFactoryAttributesDocument *a, const char *type)
{
	soap_out_bes__GetFactoryAttributesDocumentType(soap, "bes:GetFactoryAttributesDocument", -1, &a->bes__GetFactoryAttributesDocument, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__GetFactoryAttributesDocument * SOAP_FMAC4 soap_get___bes__GetFactoryAttributesDocument(struct soap *soap, struct __bes__GetFactoryAttributesDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__GetFactoryAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__GetFactoryAttributesDocument * SOAP_FMAC4 soap_in___bes__GetFactoryAttributesDocument(struct soap *soap, const char *tag, struct __bes__GetFactoryAttributesDocument *a, const char *type)
{
	short soap_flag_bes__GetFactoryAttributesDocument = 1;
	short soap_flag;
	a = (struct __bes__GetFactoryAttributesDocument *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__GetFactoryAttributesDocument, sizeof(struct __bes__GetFactoryAttributesDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__GetFactoryAttributesDocument(soap, a);
	for (soap_flag = 0;; soap_flag = 1) {
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_bes__GetFactoryAttributesDocument && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_bes__GetFactoryAttributesDocumentType(soap, "bes:GetFactoryAttributesDocument", &a->bes__GetFactoryAttributesDocument, "bes:GetFactoryAttributesDocumentType")) {
				soap_flag_bes__GetFactoryAttributesDocument--;
				continue;
			}
		if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag) {
				soap->error = SOAP_OK;
				break;
			}
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__GetFactoryAttributesDocument > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default___bes__GetActivityDocuments(struct soap *soap, struct __bes__GetActivityDocuments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__GetActivityDocumentsType(soap, &a->bes__GetActivityDocuments);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize___bes__GetActivityDocuments(struct soap *soap, const struct __bes__GetActivityDocuments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__GetActivityDocumentsType(soap, &a->bes__GetActivityDocuments);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put___bes__GetActivityDocuments(struct soap *soap, const struct __bes__GetActivityDocuments *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__GetActivityDocuments(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out___bes__GetActivityDocuments(struct soap *soap, const char *tag, int id, const struct __bes__GetActivityDocuments *a, const char *type)
{
	soap_out_bes__GetActivityDocumentsType(soap, "bes:GetActivityDocuments", -1, &a->bes__GetActivityDocuments, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__GetActivityDocuments * SOAP_FMAC4 soap_get___bes__GetActivityDocuments(struct soap *soap, struct __bes__GetActivityDocuments *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__GetActivityDocuments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__GetActivityDocuments * SOAP_FMAC4 soap_in___bes__GetActivityDocuments(struct soap *soap, const char *tag, struct __bes__GetActivityDocuments *a, const char *type)
{
	short soap_flag_bes__GetActivityDocuments = 1;
	short soap_flag;
	a = (struct __bes__GetActivityDocuments *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__GetActivityDocuments, sizeof(struct __bes__GetActivityDocuments), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__GetActivityDocuments(soap, a);
	for (soap_flag = 0;; soap_flag = 1) {
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_bes__GetActivityDocuments && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_bes__GetActivityDocumentsType(soap, "bes:GetActivityDocuments", &a->bes__GetActivityDocuments, "bes:GetActivityDocumentsType")) {
				soap_flag_bes__GetActivityDocuments--;
				continue;
			}
		if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag) {
				soap->error = SOAP_OK;
				break;
			}
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__GetActivityDocuments > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default___bes__TerminateActivities(struct soap *soap, struct __bes__TerminateActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__TerminateActivitiesType(soap, &a->bes__TerminateActivities);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize___bes__TerminateActivities(struct soap *soap, const struct __bes__TerminateActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__TerminateActivitiesType(soap, &a->bes__TerminateActivities);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put___bes__TerminateActivities(struct soap *soap, const struct __bes__TerminateActivities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__TerminateActivities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out___bes__TerminateActivities(struct soap *soap, const char *tag, int id, const struct __bes__TerminateActivities *a, const char *type)
{
	soap_out_bes__TerminateActivitiesType(soap, "bes:TerminateActivities", -1, &a->bes__TerminateActivities, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__TerminateActivities * SOAP_FMAC4 soap_get___bes__TerminateActivities(struct soap *soap, struct __bes__TerminateActivities *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__TerminateActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__TerminateActivities * SOAP_FMAC4 soap_in___bes__TerminateActivities(struct soap *soap, const char *tag, struct __bes__TerminateActivities *a, const char *type)
{
	short soap_flag_bes__TerminateActivities = 1;
	short soap_flag;
	a = (struct __bes__TerminateActivities *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__TerminateActivities, sizeof(struct __bes__TerminateActivities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__TerminateActivities(soap, a);
	for (soap_flag = 0;; soap_flag = 1) {
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_bes__TerminateActivities && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_bes__TerminateActivitiesType(soap, "bes:TerminateActivities", &a->bes__TerminateActivities, "bes:TerminateActivitiesType")) {
				soap_flag_bes__TerminateActivities--;
				continue;
			}
		if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag) {
				soap->error = SOAP_OK;
				break;
			}
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__TerminateActivities > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default___bes__GetActivityStatuses(struct soap *soap, struct __bes__GetActivityStatuses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__GetActivityStatusesType(soap, &a->bes__GetActivityStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize___bes__GetActivityStatuses(struct soap *soap, const struct __bes__GetActivityStatuses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__GetActivityStatusesType(soap, &a->bes__GetActivityStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put___bes__GetActivityStatuses(struct soap *soap, const struct __bes__GetActivityStatuses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__GetActivityStatuses(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out___bes__GetActivityStatuses(struct soap *soap, const char *tag, int id, const struct __bes__GetActivityStatuses *a, const char *type)
{
	soap_out_bes__GetActivityStatusesType(soap, "bes:GetActivityStatuses", -1, &a->bes__GetActivityStatuses, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__GetActivityStatuses * SOAP_FMAC4 soap_get___bes__GetActivityStatuses(struct soap *soap, struct __bes__GetActivityStatuses *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__GetActivityStatuses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__GetActivityStatuses * SOAP_FMAC4 soap_in___bes__GetActivityStatuses(struct soap *soap, const char *tag, struct __bes__GetActivityStatuses *a, const char *type)
{
	short soap_flag_bes__GetActivityStatuses = 1;
	short soap_flag;
	a = (struct __bes__GetActivityStatuses *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__GetActivityStatuses, sizeof(struct __bes__GetActivityStatuses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__GetActivityStatuses(soap, a);
	for (soap_flag = 0;; soap_flag = 1) {
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_bes__GetActivityStatuses && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_bes__GetActivityStatusesType(soap, "bes:GetActivityStatuses", &a->bes__GetActivityStatuses, "bes:GetActivityStatusesType")) {
				soap_flag_bes__GetActivityStatuses--;
				continue;
			}
		if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag) {
				soap->error = SOAP_OK;
				break;
			}
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__GetActivityStatuses > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default___bes__CreateActivity(struct soap *soap, struct __bes__CreateActivity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__CreateActivity = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize___bes__CreateActivity(struct soap *soap, const struct __bes__CreateActivity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__CreateActivityType(soap, &a->bes__CreateActivity);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put___bes__CreateActivity(struct soap *soap, const struct __bes__CreateActivity *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__CreateActivity(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out___bes__CreateActivity(struct soap *soap, const char *tag, int id, const struct __bes__CreateActivity *a, const char *type)
{
	soap_out_PointerTobes__CreateActivityType(soap, "bes:CreateActivity", -1, &a->bes__CreateActivity, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__CreateActivity * SOAP_FMAC4 soap_get___bes__CreateActivity(struct soap *soap, struct __bes__CreateActivity *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__CreateActivity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__CreateActivity * SOAP_FMAC4 soap_in___bes__CreateActivity(struct soap *soap, const char *tag, struct __bes__CreateActivity *a, const char *type)
{
	short soap_flag_bes__CreateActivity = 1;
	short soap_flag;
	a = (struct __bes__CreateActivity *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__CreateActivity, sizeof(struct __bes__CreateActivity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__CreateActivity(soap, a);
	for (soap_flag = 0;; soap_flag = 1) {
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_bes__CreateActivity && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTobes__CreateActivityType(soap, "bes:CreateActivity", &a->bes__CreateActivity, "bes:CreateActivityType")) {
				soap_flag_bes__CreateActivity--;
				continue;
			}
		if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag) {
				soap->error = SOAP_OK;
				break;
			}
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__InvalidRequestMessageFault = NULL;
	a->bes__NotAcceptingNewActivitiesFault = NULL;
	a->bes__NotAuthorizedFault = NULL;
	a->bes__UnsupportedFeatureFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__InvalidRequestMessageFaultType(soap, &a->bes__InvalidRequestMessageFault);
	soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, &a->bes__NotAcceptingNewActivitiesFault);
	soap_serialize_PointerTobes__NotAuthorizedFaultType(soap, &a->bes__NotAuthorizedFault);
	soap_serialize_PointerTobes__UnsupportedFeatureFaultType(soap, &a->bes__UnsupportedFeatureFault);
	soap_markelement(soap, a->fault, a->__type);
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_out_PointerTobes__InvalidRequestMessageFaultType(soap, "bes:InvalidRequestMessageFault", -1, &a->bes__InvalidRequestMessageFault, "");
	soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, "bes:NotAcceptingNewActivitiesFault", -1, &a->bes__NotAcceptingNewActivitiesFault, "");
	soap_out_PointerTobes__NotAuthorizedFaultType(soap, "bes:NotAuthorizedFault", -1, &a->bes__NotAuthorizedFault, "");
	soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, "bes:UnsupportedFeatureFault", -1, &a->bes__UnsupportedFeatureFault, "");
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_bes__InvalidRequestMessageFault = 1, soap_flag_bes__NotAcceptingNewActivitiesFault = 1, soap_flag_bes__NotAuthorizedFault = 1, soap_flag_bes__UnsupportedFeatureFault = 1, soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__InvalidRequestMessageFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__InvalidRequestMessageFaultType(soap, "bes:InvalidRequestMessageFault", &a->bes__InvalidRequestMessageFault, "bes:InvalidRequestMessageFaultType")) {
					soap_flag_bes__InvalidRequestMessageFault--;
					continue;
				}
			if (soap_flag_bes__NotAcceptingNewActivitiesFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, "bes:NotAcceptingNewActivitiesFault", &a->bes__NotAcceptingNewActivitiesFault, "bes:NotAcceptingNewActivitiesFaultType")) {
					soap_flag_bes__NotAcceptingNewActivitiesFault--;
					continue;
				}
			if (soap_flag_bes__NotAuthorizedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__NotAuthorizedFaultType(soap, "bes:NotAuthorizedFault", &a->bes__NotAuthorizedFault, "bes:NotAuthorizedFaultType")) {
					soap_flag_bes__NotAuthorizedFault--;
					continue;
				}
			if (soap_flag_bes__UnsupportedFeatureFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, "bes:UnsupportedFeatureFault", &a->bes__UnsupportedFeatureFault, "bes:UnsupportedFeatureFaultType")) {
					soap_flag_bes__UnsupportedFeatureFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type))) {
					soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
	soap_serialize__wsa__MessageID(soap, &a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, &a->wsa__To);
	soap_serialize__wsa__Action(soap, &a->wsa__Action);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	soap->mustUnderstand = 1;
	soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, "");
	soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, &a->wsa__MessageID, "");
	soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, "");
	soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, "");
	soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, "");
	soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, "");
	soap_out__wsa__To(soap, "wsa:To", -1, &a->wsa__To, "");
	soap_out__wsa__Action(soap, "wsa:Action", -1, &a->wsa__Action, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	short soap_flag_wsse__Security = 1, soap_flag_wsa__MessageID = 1, soap_flag_wsa__RelatesTo = 1, soap_flag_wsa__From = 1, soap_flag_wsa__ReplyTo = 1, soap_flag_wsa__FaultTo = 1, soap_flag_wsa__To = 1, soap_flag_wsa__Action = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, "")) {
					soap_flag_wsse__Security--;
					continue;
				}
			if (soap_flag_wsa__MessageID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__MessageID(soap, "wsa:MessageID", &a->wsa__MessageID, "")) {
					soap_flag_wsa__MessageID--;
					continue;
				}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, "")) {
					soap_flag_wsa__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, "")) {
					soap_flag_wsa__From--;
					continue;
				}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, "")) {
					soap_flag_wsa__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, "")) {
					soap_flag_wsa__FaultTo--;
					continue;
				}
			if (soap_flag_wsa__To && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__To(soap, "wsa:To", &a->wsa__To, "")) {
					soap_flag_wsa__To--;
					continue;
				}
			if (soap_flag_wsa__Action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__Action(soap, "wsa:Action", &a->wsa__Action, "")) {
					soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__UserName(struct soap *soap, struct jsdl_hpcpa__UserName_USCOREType *a)
{	soap_default_jsdl_hpcpa__UserName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__UserName(struct soap *soap, struct jsdl_hpcpa__UserName_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__UserName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__UserName(struct soap *soap, const struct jsdl_hpcpa__UserName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__UserName);
	if (soap_out__jsdl_hpcpa__UserName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__UserName(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__UserName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__UserName_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__UserName(struct soap *soap, struct jsdl_hpcpa__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__UserName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__UserName_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__UserName(struct soap *soap, const char *tag, struct jsdl_hpcpa__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__UserName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__UserName, sizeof(struct jsdl_hpcpa__UserName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_hpcpa__UserName(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__Environment(struct soap *soap, struct jsdl_hpcpa__Environment_USCOREType *a)
{	soap_default_jsdl_hpcpa__Environment_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__Environment(struct soap *soap, struct jsdl_hpcpa__Environment_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__Environment_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__Environment(struct soap *soap, const struct jsdl_hpcpa__Environment_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__Environment);
	if (soap_out__jsdl_hpcpa__Environment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__Environment(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__Environment_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__Environment_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__Environment(struct soap *soap, struct jsdl_hpcpa__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__Environment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__Environment_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__Environment(struct soap *soap, const char *tag, struct jsdl_hpcpa__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__Environment_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__Environment, sizeof(struct jsdl_hpcpa__Environment_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_hpcpa__Environment(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__WorkingDirectory(struct soap *soap, struct jsdl_hpcpa__DirectoryName_USCOREType *a)
{	soap_default_jsdl_hpcpa__DirectoryName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__WorkingDirectory(struct soap *soap, struct jsdl_hpcpa__DirectoryName_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__DirectoryName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__WorkingDirectory(struct soap *soap, const struct jsdl_hpcpa__DirectoryName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__WorkingDirectory);
	if (soap_out__jsdl_hpcpa__WorkingDirectory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__WorkingDirectory(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__DirectoryName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__DirectoryName_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__WorkingDirectory(struct soap *soap, struct jsdl_hpcpa__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__WorkingDirectory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__DirectoryName_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__WorkingDirectory(struct soap *soap, const char *tag, struct jsdl_hpcpa__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__DirectoryName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__WorkingDirectory, sizeof(struct jsdl_hpcpa__DirectoryName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_hpcpa__WorkingDirectory(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__Error(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *a)
{	soap_default_jsdl_hpcpa__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__Error(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__Error(struct soap *soap, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__Error);
	if (soap_out__jsdl_hpcpa__Error(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__Error(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__Error(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__Error(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__Error(struct soap *soap, const char *tag, struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__Error, sizeof(struct jsdl_hpcpa__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_hpcpa__Error(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__Output(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *a)
{	soap_default_jsdl_hpcpa__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__Output(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__Output(struct soap *soap, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__Output);
	if (soap_out__jsdl_hpcpa__Output(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__Output(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__Output(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__Output(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__Output(struct soap *soap, const char *tag, struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__Output, sizeof(struct jsdl_hpcpa__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_hpcpa__Output(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__Input(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *a)
{	soap_default_jsdl_hpcpa__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__Input(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__Input(struct soap *soap, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__Input);
	if (soap_out__jsdl_hpcpa__Input(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__Input(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__Input(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__Input(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__Input(struct soap *soap, const char *tag, struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__Input, sizeof(struct jsdl_hpcpa__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_hpcpa__Input(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__Argument(struct soap *soap, struct jsdl_hpcpa__Argument_USCOREType *a)
{	soap_default_jsdl_hpcpa__Argument_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__Argument(struct soap *soap, struct jsdl_hpcpa__Argument_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__Argument_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__Argument(struct soap *soap, const struct jsdl_hpcpa__Argument_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__Argument);
	if (soap_out__jsdl_hpcpa__Argument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__Argument(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__Argument_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__Argument_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__Argument(struct soap *soap, struct jsdl_hpcpa__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__Argument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__Argument_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__Argument(struct soap *soap, const char *tag, struct jsdl_hpcpa__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__Argument_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__Argument, sizeof(struct jsdl_hpcpa__Argument_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_hpcpa__Argument(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__Executable(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *a)
{	soap_default_jsdl_hpcpa__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__Executable(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__Executable(struct soap *soap, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__Executable);
	if (soap_out__jsdl_hpcpa__Executable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__Executable(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__Executable(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__Executable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__Executable(struct soap *soap, const char *tag, struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__Executable, sizeof(struct jsdl_hpcpa__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_hpcpa__Executable(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_hpcpa__HPCProfileApplication(struct soap *soap, struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a)
{	soap_default_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_hpcpa__HPCProfileApplication(struct soap *soap, struct jsdl_hpcpa__HPCProfileApplication_USCOREType const*a)
{	soap_serialize_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_hpcpa__HPCProfileApplication(struct soap *soap, const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_hpcpa__HPCProfileApplication);
	if (soap_out__jsdl_hpcpa__HPCProfileApplication(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_hpcpa__HPCProfileApplication(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl_hpcpa__HPCProfileApplication), type);
	soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Executable", -1, &a->jsdl_hpcpa__Executable, "");
	if (a->jsdl_hpcpa__Argument) {
		int i;
		for (i = 0; i < a->__sizeArgument; i++)
			soap_out_jsdl_hpcpa__Argument_USCOREType(soap, "jsdl-hpcpa:Argument", -1, a->jsdl_hpcpa__Argument + i, "");
	}
	soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Input", -1, &a->jsdl_hpcpa__Input, "");
	soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Output", -1, &a->jsdl_hpcpa__Output, "");
	soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Error", -1, &a->jsdl_hpcpa__Error, "");
	soap_out_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, "jsdl-hpcpa:WorkingDirectory", -1, &a->jsdl_hpcpa__WorkingDirectory, "");
	if (a->jsdl_hpcpa__Environment) {
		int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
			soap_out_jsdl_hpcpa__Environment_USCOREType(soap, "jsdl-hpcpa:Environment", -1, a->jsdl_hpcpa__Environment + i, "");
	}
	soap_out_PointerTojsdl_hpcpa__UserName_USCOREType(soap, "jsdl-hpcpa:UserName", -1, &a->jsdl_hpcpa__UserName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl_hpcpa__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_get__jsdl_hpcpa__HPCProfileApplication(struct soap *soap, struct jsdl_hpcpa__HPCProfileApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_hpcpa__HPCProfileApplication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_in__jsdl_hpcpa__HPCProfileApplication(struct soap *soap, const char *tag, struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a, const char *type)
{
	short soap_flag_jsdl_hpcpa__Executable = 1, soap_flag_jsdl_hpcpa__Argument = 1, soap_flag_jsdl_hpcpa__Input = 1, soap_flag_jsdl_hpcpa__Output = 1, soap_flag_jsdl_hpcpa__Error = 1, soap_flag_jsdl_hpcpa__WorkingDirectory = 1, soap_flag_jsdl_hpcpa__Environment = 1, soap_flag_jsdl_hpcpa__UserName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl_hpcpa__HPCProfileApplication_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_hpcpa__HPCProfileApplication, sizeof(struct jsdl_hpcpa__HPCProfileApplication_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl_hpcpa__HPCProfileApplication(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl_hpcpa__Executable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Executable", &a->jsdl_hpcpa__Executable, "jsdl-hpcpa:FileName_Type")) {
					soap_flag_jsdl_hpcpa__Executable--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__Argument && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl_hpcpa__Argument_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeArgument = 0; !soap_element_begin_in(soap, "jsdl-hpcpa:Argument", 1, NULL); a->__sizeArgument++) {
					p = (struct jsdl_hpcpa__Argument_USCOREType *)soap_push_block(soap, sizeof(struct jsdl_hpcpa__Argument_USCOREType));
					soap_default_jsdl_hpcpa__Argument_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl_hpcpa__Argument_USCOREType(soap, "jsdl-hpcpa:Argument", p, "jsdl-hpcpa:Argument_Type"))
						break;
					soap_flag_jsdl_hpcpa__Argument = 0;
				}
				a->jsdl_hpcpa__Argument = (struct jsdl_hpcpa__Argument_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl_hpcpa__Argument && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl_hpcpa__Input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Input", &a->jsdl_hpcpa__Input, "jsdl-hpcpa:FileName_Type")) {
					soap_flag_jsdl_hpcpa__Input--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__Output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Output", &a->jsdl_hpcpa__Output, "jsdl-hpcpa:FileName_Type")) {
					soap_flag_jsdl_hpcpa__Output--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Error", &a->jsdl_hpcpa__Error, "jsdl-hpcpa:FileName_Type")) {
					soap_flag_jsdl_hpcpa__Error--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__WorkingDirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, "jsdl-hpcpa:WorkingDirectory", &a->jsdl_hpcpa__WorkingDirectory, "jsdl-hpcpa:DirectoryName_Type")) {
					soap_flag_jsdl_hpcpa__WorkingDirectory--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__Environment && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl_hpcpa__Environment_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeEnvironment = 0; !soap_element_begin_in(soap, "jsdl-hpcpa:Environment", 1, NULL); a->__sizeEnvironment++) {
					p = (struct jsdl_hpcpa__Environment_USCOREType *)soap_push_block(soap, sizeof(struct jsdl_hpcpa__Environment_USCOREType));
					soap_default_jsdl_hpcpa__Environment_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl_hpcpa__Environment_USCOREType(soap, "jsdl-hpcpa:Environment", p, "jsdl-hpcpa:Environment_Type"))
						break;
					soap_flag_jsdl_hpcpa__Environment = 0;
				}
				a->jsdl_hpcpa__Environment = (struct jsdl_hpcpa__Environment_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl_hpcpa__Environment && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl_hpcpa__UserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__UserName_USCOREType(soap, "jsdl-hpcpa:UserName", &a->jsdl_hpcpa__UserName, "jsdl-hpcpa:UserName_Type")) {
					soap_flag_jsdl_hpcpa__UserName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl_hpcpa__HPCProfileApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl_hpcpa__HPCProfileApplication, 0, sizeof(struct jsdl_hpcpa__HPCProfileApplication_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__GroupName(struct soap *soap, struct jsdl_posix__GroupName_USCOREType *a)
{	soap_default_jsdl_posix__GroupName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__GroupName(struct soap *soap, struct jsdl_posix__GroupName_USCOREType const*a)
{	soap_serialize_jsdl_posix__GroupName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__GroupName(struct soap *soap, const struct jsdl_posix__GroupName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__GroupName);
	if (soap_out__jsdl_posix__GroupName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__GroupName(struct soap *soap, const char *tag, int id, const struct jsdl_posix__GroupName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__GroupName_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__GroupName(struct soap *soap, struct jsdl_posix__GroupName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__GroupName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__GroupName_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__GroupName(struct soap *soap, const char *tag, struct jsdl_posix__GroupName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__GroupName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__GroupName, sizeof(struct jsdl_posix__GroupName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__GroupName(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__UserName(struct soap *soap, struct jsdl_posix__UserName_USCOREType *a)
{	soap_default_jsdl_posix__UserName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__UserName(struct soap *soap, struct jsdl_posix__UserName_USCOREType const*a)
{	soap_serialize_jsdl_posix__UserName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__UserName(struct soap *soap, const struct jsdl_posix__UserName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__UserName);
	if (soap_out__jsdl_posix__UserName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__UserName(struct soap *soap, const char *tag, int id, const struct jsdl_posix__UserName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__UserName_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__UserName(struct soap *soap, struct jsdl_posix__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__UserName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__UserName_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__UserName(struct soap *soap, const char *tag, struct jsdl_posix__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__UserName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__UserName, sizeof(struct jsdl_posix__UserName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__UserName(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__ThreadCountLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__ThreadCountLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__ThreadCountLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__ThreadCountLimit);
	if (soap_out__jsdl_posix__ThreadCountLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__ThreadCountLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__ThreadCountLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__ThreadCountLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__ThreadCountLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__ThreadCountLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__ThreadCountLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__VirtualMemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__VirtualMemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__VirtualMemoryLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__VirtualMemoryLimit);
	if (soap_out__jsdl_posix__VirtualMemoryLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__VirtualMemoryLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__VirtualMemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__VirtualMemoryLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__VirtualMemoryLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__VirtualMemoryLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__VirtualMemoryLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__ProcessCountLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__ProcessCountLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__ProcessCountLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__ProcessCountLimit);
	if (soap_out__jsdl_posix__ProcessCountLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__ProcessCountLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__ProcessCountLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__ProcessCountLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__ProcessCountLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__ProcessCountLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__ProcessCountLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__CPUTimeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__CPUTimeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__CPUTimeLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__CPUTimeLimit);
	if (soap_out__jsdl_posix__CPUTimeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__CPUTimeLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__CPUTimeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__CPUTimeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__CPUTimeLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__CPUTimeLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__CPUTimeLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__StackSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__StackSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__StackSizeLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__StackSizeLimit);
	if (soap_out__jsdl_posix__StackSizeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__StackSizeLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__StackSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__StackSizeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__StackSizeLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__StackSizeLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__StackSizeLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__PipeSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__PipeSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__PipeSizeLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__PipeSizeLimit);
	if (soap_out__jsdl_posix__PipeSizeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__PipeSizeLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__PipeSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__PipeSizeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__PipeSizeLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__PipeSizeLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__PipeSizeLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__OpenDescriptorsLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__OpenDescriptorsLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__OpenDescriptorsLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__OpenDescriptorsLimit);
	if (soap_out__jsdl_posix__OpenDescriptorsLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__OpenDescriptorsLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__OpenDescriptorsLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__OpenDescriptorsLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__OpenDescriptorsLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__OpenDescriptorsLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__OpenDescriptorsLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__MemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__MemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__MemoryLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__MemoryLimit);
	if (soap_out__jsdl_posix__MemoryLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__MemoryLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__MemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__MemoryLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__MemoryLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__MemoryLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__MemoryLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__LockedMemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__LockedMemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__LockedMemoryLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__LockedMemoryLimit);
	if (soap_out__jsdl_posix__LockedMemoryLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__LockedMemoryLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__LockedMemoryLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__LockedMemoryLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__LockedMemoryLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__LockedMemoryLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__LockedMemoryLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__DataSegmentLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__DataSegmentLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__DataSegmentLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__DataSegmentLimit);
	if (soap_out__jsdl_posix__DataSegmentLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__DataSegmentLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__DataSegmentLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__DataSegmentLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__DataSegmentLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__DataSegmentLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__DataSegmentLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__CoreDumpLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__CoreDumpLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__CoreDumpLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__CoreDumpLimit);
	if (soap_out__jsdl_posix__CoreDumpLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__CoreDumpLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__CoreDumpLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__CoreDumpLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__CoreDumpLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__CoreDumpLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__CoreDumpLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__FileSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__FileSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__FileSizeLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__FileSizeLimit);
	if (soap_out__jsdl_posix__FileSizeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__FileSizeLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__FileSizeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__FileSizeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__FileSizeLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__FileSizeLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__FileSizeLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__WallTimeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__WallTimeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType const*a)
{	soap_serialize_jsdl_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__WallTimeLimit(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__WallTimeLimit);
	if (soap_out__jsdl_posix__WallTimeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__WallTimeLimit(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__WallTimeLimit(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__WallTimeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__WallTimeLimit(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__WallTimeLimit, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__WallTimeLimit(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__Environment(struct soap *soap, struct jsdl_posix__Environment_USCOREType *a)
{	soap_default_jsdl_posix__Environment_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__Environment(struct soap *soap, struct jsdl_posix__Environment_USCOREType const*a)
{	soap_serialize_jsdl_posix__Environment_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__Environment(struct soap *soap, const struct jsdl_posix__Environment_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__Environment);
	if (soap_out__jsdl_posix__Environment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__Environment(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Environment_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Environment_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__Environment(struct soap *soap, struct jsdl_posix__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__Environment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Environment_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__Environment(struct soap *soap, const char *tag, struct jsdl_posix__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Environment_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__Environment, sizeof(struct jsdl_posix__Environment_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__Environment(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__WorkingDirectory(struct soap *soap, struct jsdl_posix__DirectoryName_USCOREType *a)
{	soap_default_jsdl_posix__DirectoryName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__WorkingDirectory(struct soap *soap, struct jsdl_posix__DirectoryName_USCOREType const*a)
{	soap_serialize_jsdl_posix__DirectoryName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__WorkingDirectory(struct soap *soap, const struct jsdl_posix__DirectoryName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__WorkingDirectory);
	if (soap_out__jsdl_posix__WorkingDirectory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__WorkingDirectory(struct soap *soap, const char *tag, int id, const struct jsdl_posix__DirectoryName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__DirectoryName_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__WorkingDirectory(struct soap *soap, struct jsdl_posix__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__WorkingDirectory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__DirectoryName_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__WorkingDirectory(struct soap *soap, const char *tag, struct jsdl_posix__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__DirectoryName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__WorkingDirectory, sizeof(struct jsdl_posix__DirectoryName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__WorkingDirectory(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__Error(struct soap *soap, struct jsdl_posix__FileName_USCOREType *a)
{	soap_default_jsdl_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__Error(struct soap *soap, struct jsdl_posix__FileName_USCOREType const*a)
{	soap_serialize_jsdl_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__Error(struct soap *soap, const struct jsdl_posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__Error);
	if (soap_out__jsdl_posix__Error(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__Error(struct soap *soap, const char *tag, int id, const struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__Error(struct soap *soap, struct jsdl_posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__Error(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__Error(struct soap *soap, const char *tag, struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__Error, sizeof(struct jsdl_posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__Error(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__Output(struct soap *soap, struct jsdl_posix__FileName_USCOREType *a)
{	soap_default_jsdl_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__Output(struct soap *soap, struct jsdl_posix__FileName_USCOREType const*a)
{	soap_serialize_jsdl_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__Output(struct soap *soap, const struct jsdl_posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__Output);
	if (soap_out__jsdl_posix__Output(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__Output(struct soap *soap, const char *tag, int id, const struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__Output(struct soap *soap, struct jsdl_posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__Output(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__Output(struct soap *soap, const char *tag, struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__Output, sizeof(struct jsdl_posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__Output(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__Input(struct soap *soap, struct jsdl_posix__FileName_USCOREType *a)
{	soap_default_jsdl_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__Input(struct soap *soap, struct jsdl_posix__FileName_USCOREType const*a)
{	soap_serialize_jsdl_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__Input(struct soap *soap, const struct jsdl_posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__Input);
	if (soap_out__jsdl_posix__Input(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__Input(struct soap *soap, const char *tag, int id, const struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__Input(struct soap *soap, struct jsdl_posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__Input(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__Input(struct soap *soap, const char *tag, struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__Input, sizeof(struct jsdl_posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__Input(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__Argument(struct soap *soap, struct jsdl_posix__Argument_USCOREType *a)
{	soap_default_jsdl_posix__Argument_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__Argument(struct soap *soap, struct jsdl_posix__Argument_USCOREType const*a)
{	soap_serialize_jsdl_posix__Argument_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__Argument(struct soap *soap, const struct jsdl_posix__Argument_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__Argument);
	if (soap_out__jsdl_posix__Argument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__Argument(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Argument_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_xsd__normalizedString(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Argument_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__Argument(struct soap *soap, struct jsdl_posix__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__Argument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Argument_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__Argument(struct soap *soap, const char *tag, struct jsdl_posix__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Argument_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__Argument, sizeof(struct jsdl_posix__Argument_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__Argument(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_xsd__normalizedString(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__Executable(struct soap *soap, struct jsdl_posix__FileName_USCOREType *a)
{	soap_default_jsdl_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__Executable(struct soap *soap, struct jsdl_posix__FileName_USCOREType const*a)
{	soap_serialize_jsdl_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__Executable(struct soap *soap, const struct jsdl_posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__Executable);
	if (soap_out__jsdl_posix__Executable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__Executable(struct soap *soap, const char *tag, int id, const struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__Executable(struct soap *soap, struct jsdl_posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__Executable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__Executable(struct soap *soap, const char *tag, struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__Executable, sizeof(struct jsdl_posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__jsdl_posix__Executable(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl_posix__POSIXApplication(struct soap *soap, struct jsdl_posix__POSIXApplication_USCOREType *a)
{	soap_default_jsdl_posix__POSIXApplication_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl_posix__POSIXApplication(struct soap *soap, struct jsdl_posix__POSIXApplication_USCOREType const*a)
{	soap_serialize_jsdl_posix__POSIXApplication_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl_posix__POSIXApplication(struct soap *soap, const struct jsdl_posix__POSIXApplication_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl_posix__POSIXApplication);
	if (soap_out__jsdl_posix__POSIXApplication(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl_posix__POSIXApplication(struct soap *soap, const char *tag, int id, const struct jsdl_posix__POSIXApplication_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl_posix__POSIXApplication), type);
	soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Executable", -1, &a->jsdl_posix__Executable, "");
	if (a->jsdl_posix__Argument) {
		int i;
		for (i = 0; i < a->__sizeArgument; i++)
			soap_out_jsdl_posix__Argument_USCOREType(soap, "jsdl-posix:Argument", -1, a->jsdl_posix__Argument + i, "");
	}
	soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Input", -1, &a->jsdl_posix__Input, "");
	soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Output", -1, &a->jsdl_posix__Output, "");
	soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Error", -1, &a->jsdl_posix__Error, "");
	soap_out_PointerTojsdl_posix__DirectoryName_USCOREType(soap, "jsdl-posix:WorkingDirectory", -1, &a->jsdl_posix__WorkingDirectory, "");
	if (a->jsdl_posix__Environment) {
		int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
			soap_out_jsdl_posix__Environment_USCOREType(soap, "jsdl-posix:Environment", -1, a->jsdl_posix__Environment + i, "");
	}
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:WallTimeLimit", -1, &a->jsdl_posix__WallTimeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:FileSizeLimit", -1, &a->jsdl_posix__FileSizeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:CoreDumpLimit", -1, &a->jsdl_posix__CoreDumpLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:DataSegmentLimit", -1, &a->jsdl_posix__DataSegmentLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:LockedMemoryLimit", -1, &a->jsdl_posix__LockedMemoryLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:MemoryLimit", -1, &a->jsdl_posix__MemoryLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:OpenDescriptorsLimit", -1, &a->jsdl_posix__OpenDescriptorsLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:PipeSizeLimit", -1, &a->jsdl_posix__PipeSizeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:StackSizeLimit", -1, &a->jsdl_posix__StackSizeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:CPUTimeLimit", -1, &a->jsdl_posix__CPUTimeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:ProcessCountLimit", -1, &a->jsdl_posix__ProcessCountLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:VirtualMemoryLimit", -1, &a->jsdl_posix__VirtualMemoryLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:ThreadCountLimit", -1, &a->jsdl_posix__ThreadCountLimit, "");
	soap_out_PointerTojsdl_posix__UserName_USCOREType(soap, "jsdl-posix:UserName", -1, &a->jsdl_posix__UserName, "");
	soap_out_PointerTojsdl_posix__GroupName_USCOREType(soap, "jsdl-posix:GroupName", -1, &a->jsdl_posix__GroupName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl_posix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_get__jsdl_posix__POSIXApplication(struct soap *soap, struct jsdl_posix__POSIXApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl_posix__POSIXApplication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_in__jsdl_posix__POSIXApplication(struct soap *soap, const char *tag, struct jsdl_posix__POSIXApplication_USCOREType *a, const char *type)
{
	short soap_flag_jsdl_posix__Executable = 1, soap_flag_jsdl_posix__Argument = 1, soap_flag_jsdl_posix__Input = 1, soap_flag_jsdl_posix__Output = 1, soap_flag_jsdl_posix__Error = 1, soap_flag_jsdl_posix__WorkingDirectory = 1, soap_flag_jsdl_posix__Environment = 1, soap_flag_jsdl_posix__WallTimeLimit = 1, soap_flag_jsdl_posix__FileSizeLimit = 1, soap_flag_jsdl_posix__CoreDumpLimit = 1, soap_flag_jsdl_posix__DataSegmentLimit = 1, soap_flag_jsdl_posix__LockedMemoryLimit = 1, soap_flag_jsdl_posix__MemoryLimit = 1, soap_flag_jsdl_posix__OpenDescriptorsLimit = 1, soap_flag_jsdl_posix__PipeSizeLimit = 1, soap_flag_jsdl_posix__StackSizeLimit = 1, soap_flag_jsdl_posix__CPUTimeLimit = 1, soap_flag_jsdl_posix__ProcessCountLimit = 1, soap_flag_jsdl_posix__VirtualMemoryLimit = 1, soap_flag_jsdl_posix__ThreadCountLimit = 1, soap_flag_jsdl_posix__UserName = 1, soap_flag_jsdl_posix__GroupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl_posix__POSIXApplication_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl_posix__POSIXApplication, sizeof(struct jsdl_posix__POSIXApplication_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl_posix__POSIXApplication(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl_posix__Executable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Executable", &a->jsdl_posix__Executable, "jsdl-posix:FileName_Type")) {
					soap_flag_jsdl_posix__Executable--;
					continue;
				}
			if (soap_flag_jsdl_posix__Argument && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl_posix__Argument_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeArgument = 0; !soap_element_begin_in(soap, "jsdl-posix:Argument", 1, NULL); a->__sizeArgument++) {
					p = (struct jsdl_posix__Argument_USCOREType *)soap_push_block(soap, sizeof(struct jsdl_posix__Argument_USCOREType));
					soap_default_jsdl_posix__Argument_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl_posix__Argument_USCOREType(soap, "jsdl-posix:Argument", p, "jsdl-posix:Argument_Type"))
						break;
					soap_flag_jsdl_posix__Argument = 0;
				}
				a->jsdl_posix__Argument = (struct jsdl_posix__Argument_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl_posix__Argument && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl_posix__Input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Input", &a->jsdl_posix__Input, "jsdl-posix:FileName_Type")) {
					soap_flag_jsdl_posix__Input--;
					continue;
				}
			if (soap_flag_jsdl_posix__Output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Output", &a->jsdl_posix__Output, "jsdl-posix:FileName_Type")) {
					soap_flag_jsdl_posix__Output--;
					continue;
				}
			if (soap_flag_jsdl_posix__Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Error", &a->jsdl_posix__Error, "jsdl-posix:FileName_Type")) {
					soap_flag_jsdl_posix__Error--;
					continue;
				}
			if (soap_flag_jsdl_posix__WorkingDirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__DirectoryName_USCOREType(soap, "jsdl-posix:WorkingDirectory", &a->jsdl_posix__WorkingDirectory, "jsdl-posix:DirectoryName_Type")) {
					soap_flag_jsdl_posix__WorkingDirectory--;
					continue;
				}
			if (soap_flag_jsdl_posix__Environment && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl_posix__Environment_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeEnvironment = 0; !soap_element_begin_in(soap, "jsdl-posix:Environment", 1, NULL); a->__sizeEnvironment++) {
					p = (struct jsdl_posix__Environment_USCOREType *)soap_push_block(soap, sizeof(struct jsdl_posix__Environment_USCOREType));
					soap_default_jsdl_posix__Environment_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl_posix__Environment_USCOREType(soap, "jsdl-posix:Environment", p, "jsdl-posix:Environment_Type"))
						break;
					soap_flag_jsdl_posix__Environment = 0;
				}
				a->jsdl_posix__Environment = (struct jsdl_posix__Environment_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl_posix__Environment && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl_posix__WallTimeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:WallTimeLimit", &a->jsdl_posix__WallTimeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__WallTimeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__FileSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:FileSizeLimit", &a->jsdl_posix__FileSizeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__FileSizeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__CoreDumpLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:CoreDumpLimit", &a->jsdl_posix__CoreDumpLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__CoreDumpLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__DataSegmentLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:DataSegmentLimit", &a->jsdl_posix__DataSegmentLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__DataSegmentLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__LockedMemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:LockedMemoryLimit", &a->jsdl_posix__LockedMemoryLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__LockedMemoryLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__MemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:MemoryLimit", &a->jsdl_posix__MemoryLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__MemoryLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__OpenDescriptorsLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:OpenDescriptorsLimit", &a->jsdl_posix__OpenDescriptorsLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__OpenDescriptorsLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__PipeSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:PipeSizeLimit", &a->jsdl_posix__PipeSizeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__PipeSizeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__StackSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:StackSizeLimit", &a->jsdl_posix__StackSizeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__StackSizeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__CPUTimeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:CPUTimeLimit", &a->jsdl_posix__CPUTimeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__CPUTimeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__ProcessCountLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:ProcessCountLimit", &a->jsdl_posix__ProcessCountLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__ProcessCountLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__VirtualMemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:VirtualMemoryLimit", &a->jsdl_posix__VirtualMemoryLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__VirtualMemoryLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__ThreadCountLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:ThreadCountLimit", &a->jsdl_posix__ThreadCountLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__ThreadCountLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__UserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__UserName_USCOREType(soap, "jsdl-posix:UserName", &a->jsdl_posix__UserName, "jsdl-posix:UserName_Type")) {
					soap_flag_jsdl_posix__UserName--;
					continue;
				}
			if (soap_flag_jsdl_posix__GroupName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__GroupName_USCOREType(soap, "jsdl-posix:GroupName", &a->jsdl_posix__GroupName, "jsdl-posix:GroupName_Type")) {
					soap_flag_jsdl_posix__GroupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__POSIXApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl_posix__POSIXApplication, 0, sizeof(struct jsdl_posix__POSIXApplication_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__hpcp_af__AdvancedFilter(struct soap *soap, struct hpcp_af__AdvancedFilterType *a)
{	soap_default_hpcp_af__AdvancedFilterType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__hpcp_af__AdvancedFilter(struct soap *soap, struct hpcp_af__AdvancedFilterType const*a)
{	soap_serialize_hpcp_af__AdvancedFilterType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__hpcp_af__AdvancedFilter(struct soap *soap, const struct hpcp_af__AdvancedFilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__hpcp_af__AdvancedFilter);
	if (soap_out__hpcp_af__AdvancedFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__hpcp_af__AdvancedFilter(struct soap *soap, const char *tag, int id, const struct hpcp_af__AdvancedFilterType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__hpcp_af__AdvancedFilter), type);
	if (a->UserName) {
		int i;
		for (i = 0; i < a->__sizeUserName; i++)
			soap_out_string(soap, "hpcp_af:UserName", -1, a->UserName + i, "");
	}
	if (a->Owner) {
		int i;
		for (i = 0; i < a->__sizeOwner; i++)
			soap_out_string(soap, "hpcp_af:Owner", -1, a->Owner + i, "");
	}
	if (a->State) {
		int i;
		for (i = 0; i < a->__sizeState; i++)
			soap_out_bes__ActivityStateEnumeration(soap, "hpcp_af:State", -1, a->State + i, "");
	}
	if (a->ActivityIdRange) {
		int i;
		for (i = 0; i < a->__sizeActivityIdRange; i++)
			soap_out_hpcp_af__ActivityIdRangeType(soap, "hpcp_af:ActivityIdRange", -1, a->ActivityIdRange + i, "");
	}
	if (a->ActivityId) {
		int i;
		for (i = 0; i < a->__sizeActivityId; i++)
			soap_out_string(soap, "hpcp_af:ActivityId", -1, a->ActivityId + i, "");
	}
	if (a->DateTimeRange) {
		int i;
		for (i = 0; i < a->__sizeDateTimeRange; i++)
			soap_out_hpcp_af__DateTimeRangeType(soap, "hpcp_af:DateTimeRange", -1, a->DateTimeRange + i, "");
	}
	soap_out_string(soap, "hpcp_af:CompactResources", -1, &a->CompactResources, "");
	soap_out_string(soap, "hpcp_af:UsageRecordFormat", -1, &a->UsageRecordFormat, "");
	soap_out_string(soap, "hpcp_af:NodeStatus", -1, &a->NodeStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__AdvancedFilterType * SOAP_FMAC4 soap_get__hpcp_af__AdvancedFilter(struct soap *soap, struct hpcp_af__AdvancedFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in__hpcp_af__AdvancedFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__AdvancedFilterType * SOAP_FMAC4 soap_in__hpcp_af__AdvancedFilter(struct soap *soap, const char *tag, struct hpcp_af__AdvancedFilterType *a, const char *type)
{
	short soap_flag_UserName = 1, soap_flag_Owner = 1, soap_flag_State = 1, soap_flag_ActivityIdRange = 1, soap_flag_ActivityId = 1, soap_flag_DateTimeRange = 1, soap_flag_CompactResources = 1, soap_flag_UsageRecordFormat = 1, soap_flag_NodeStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__AdvancedFilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__hpcp_af__AdvancedFilter, sizeof(struct hpcp_af__AdvancedFilterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__hpcp_af__AdvancedFilter(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeUserName = 0; !soap_element_begin_in(soap, "hpcp_af:UserName", 1, NULL); a->__sizeUserName++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "hpcp_af:UserName", p, "xsd:string"))
						break;
					soap_flag_UserName = 0;
				}
				a->UserName = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_UserName && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Owner && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeOwner = 0; !soap_element_begin_in(soap, "hpcp_af:Owner", 1, NULL); a->__sizeOwner++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "hpcp_af:Owner", p, "xsd:string"))
						break;
					soap_flag_Owner = 0;
				}
				a->Owner = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Owner && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH) {
				enum bes__ActivityStateEnumeration *p;
				soap_new_block(soap);
				for (a->__sizeState = 0; !soap_element_begin_in(soap, "hpcp_af:State", 1, NULL); a->__sizeState++) {
					p = (enum bes__ActivityStateEnumeration *)soap_push_block(soap, sizeof(enum bes__ActivityStateEnumeration));
					soap_default_bes__ActivityStateEnumeration(soap, p);
					soap_revert(soap);
					if (!soap_in_bes__ActivityStateEnumeration(soap, "hpcp_af:State", p, "bes:ActivityStateEnumeration"))
						break;
					soap_flag_State = 0;
				}
				a->State = (enum bes__ActivityStateEnumeration *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_ActivityIdRange && soap->error == SOAP_TAG_MISMATCH) {
				struct hpcp_af__ActivityIdRangeType *p;
				soap_new_block(soap);
				for (a->__sizeActivityIdRange = 0; !soap_element_begin_in(soap, "hpcp_af:ActivityIdRange", 1, NULL); a->__sizeActivityIdRange++) {
					p = (struct hpcp_af__ActivityIdRangeType *)soap_push_block(soap, sizeof(struct hpcp_af__ActivityIdRangeType));
					soap_default_hpcp_af__ActivityIdRangeType(soap, p);
					soap_revert(soap);
					if (!soap_in_hpcp_af__ActivityIdRangeType(soap, "hpcp_af:ActivityIdRange", p, "hpcp-af:ActivityIdRangeType"))
						break;
					soap_flag_ActivityIdRange = 0;
				}
				a->ActivityIdRange = (struct hpcp_af__ActivityIdRangeType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ActivityIdRange && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_ActivityId && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeActivityId = 0; !soap_element_begin_in(soap, "hpcp_af:ActivityId", 1, NULL); a->__sizeActivityId++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "hpcp_af:ActivityId", p, "xsd:string"))
						break;
					soap_flag_ActivityId = 0;
				}
				a->ActivityId = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ActivityId && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_DateTimeRange && soap->error == SOAP_TAG_MISMATCH) {
				struct hpcp_af__DateTimeRangeType *p;
				soap_new_block(soap);
				for (a->__sizeDateTimeRange = 0; !soap_element_begin_in(soap, "hpcp_af:DateTimeRange", 1, NULL); a->__sizeDateTimeRange++) {
					p = (struct hpcp_af__DateTimeRangeType *)soap_push_block(soap, sizeof(struct hpcp_af__DateTimeRangeType));
					soap_default_hpcp_af__DateTimeRangeType(soap, p);
					soap_revert(soap);
					if (!soap_in_hpcp_af__DateTimeRangeType(soap, "hpcp_af:DateTimeRange", p, "hpcp-af:DateTimeRangeType"))
						break;
					soap_flag_DateTimeRange = 0;
				}
				a->DateTimeRange = (struct hpcp_af__DateTimeRangeType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_DateTimeRange && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_CompactResources && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "hpcp_af:CompactResources", &a->CompactResources, "xsd:string")) {
					soap_flag_CompactResources--;
					continue;
				}
			if (soap_flag_UsageRecordFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "hpcp_af:UsageRecordFormat", &a->UsageRecordFormat, "xsd:string")) {
					soap_flag_UsageRecordFormat--;
					continue;
				}
			if (soap_flag_NodeStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "hpcp_af:NodeStatus", &a->NodeStatus, "xsd:string")) {
					soap_flag_NodeStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__AdvancedFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__hpcp_af__AdvancedFilter, 0, sizeof(struct hpcp_af__AdvancedFilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__Target(struct soap *soap, struct jsdl__SourceTarget_USCOREType *a)
{	soap_default_jsdl__SourceTarget_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__Target(struct soap *soap, struct jsdl__SourceTarget_USCOREType const*a)
{	soap_serialize_jsdl__SourceTarget_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__Target(struct soap *soap, const struct jsdl__SourceTarget_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Target);
	if (soap_out__jsdl__Target(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__Target(struct soap *soap, const char *tag, int id, const struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__Target), type);
	soap_out_xsd__anyURI(soap, "jsdl:URI", -1, &a->jsdl__URI, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get__jsdl__Target(struct soap *soap, struct jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Target(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in__jsdl__Target(struct soap *soap, const char *tag, struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__URI = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__Target, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__Target(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "jsdl:URI", &a->jsdl__URI, "xsd:anyURI")) {
					soap_flag_jsdl__URI--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__Target, 0, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__Source(struct soap *soap, struct jsdl__SourceTarget_USCOREType *a)
{	soap_default_jsdl__SourceTarget_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__Source(struct soap *soap, struct jsdl__SourceTarget_USCOREType const*a)
{	soap_serialize_jsdl__SourceTarget_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__Source(struct soap *soap, const struct jsdl__SourceTarget_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Source);
	if (soap_out__jsdl__Source(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__Source(struct soap *soap, const char *tag, int id, const struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__Source), type);
	soap_out_xsd__anyURI(soap, "jsdl:URI", -1, &a->jsdl__URI, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get__jsdl__Source(struct soap *soap, struct jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Source(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in__jsdl__Source(struct soap *soap, const char *tag, struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__URI = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__Source, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__Source(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "jsdl:URI", &a->jsdl__URI, "xsd:anyURI")) {
					soap_flag_jsdl__URI--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__Source, 0, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__DataStaging(struct soap *soap, struct jsdl__DataStaging_USCOREType *a)
{	soap_default_jsdl__DataStaging_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__DataStaging(struct soap *soap, struct jsdl__DataStaging_USCOREType const*a)
{	soap_serialize_jsdl__DataStaging_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__DataStaging(struct soap *soap, const struct jsdl__DataStaging_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__DataStaging);
	if (soap_out__jsdl__DataStaging(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__DataStaging(struct soap *soap, const char *tag, int id, const struct jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__DataStaging), type);
	soap_out_string(soap, "jsdl:FileName", -1, &a->jsdl__FileName, "");
	soap_out_xsd__NCName(soap, "jsdl:FilesystemName", -1, &a->jsdl__FilesystemName, "");
	soap_out_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", -1, &a->jsdl__CreationFlag, "");
	soap_out_PointerToxsd__boolean(soap, "jsdl:DeleteOnTermination", -1, &a->jsdl__DeleteOnTermination, "");
	soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", -1, &a->jsdl__Source, "");
	soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", -1, &a->jsdl__Target, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_get__jsdl__DataStaging(struct soap *soap, struct jsdl__DataStaging_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__DataStaging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_in__jsdl__DataStaging(struct soap *soap, const char *tag, struct jsdl__DataStaging_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__FileName = 1, soap_flag_jsdl__FilesystemName = 1, soap_flag_jsdl__CreationFlag = 1, soap_flag_jsdl__DeleteOnTermination = 1, soap_flag_jsdl__Source = 1, soap_flag_jsdl__Target = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__DataStaging_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__DataStaging, sizeof(struct jsdl__DataStaging_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__DataStaging(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:FileName", &a->jsdl__FileName, "xsd:string")) {
					soap_flag_jsdl__FileName--;
					continue;
				}
			if (soap_flag_jsdl__FilesystemName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__NCName(soap, "jsdl:FilesystemName", &a->jsdl__FilesystemName, "xsd:NCName")) {
					soap_flag_jsdl__FilesystemName--;
					continue;
				}
			if (soap_flag_jsdl__CreationFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", &a->jsdl__CreationFlag, "jsdl:CreationFlagEnumeration")) {
					soap_flag_jsdl__CreationFlag--;
					continue;
				}
			if (soap_flag_jsdl__DeleteOnTermination && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "jsdl:DeleteOnTermination", &a->jsdl__DeleteOnTermination, "xsd:boolean")) {
					soap_flag_jsdl__DeleteOnTermination--;
					continue;
				}
			if (soap_flag_jsdl__Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", &a->jsdl__Source, "jsdl:SourceTarget_Type")) {
					soap_flag_jsdl__Source--;
					continue;
				}
			if (soap_flag_jsdl__Target && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", &a->jsdl__Target, "jsdl:SourceTarget_Type")) {
					soap_flag_jsdl__Target--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__DataStaging_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__DataStaging, 0, sizeof(struct jsdl__DataStaging_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__FileName > 0 || soap_flag_jsdl__CreationFlag > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__TotalResourceCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__TotalResourceCount(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__TotalResourceCount(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalResourceCount);
	if (soap_out__jsdl__TotalResourceCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__TotalResourceCount(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalResourceCount), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalResourceCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalResourceCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalResourceCount(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalResourceCount, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalResourceCount(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalResourceCount, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__TotalDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__TotalDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__TotalDiskSpace(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalDiskSpace);
	if (soap_out__jsdl__TotalDiskSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__TotalDiskSpace(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalDiskSpace), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalDiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalDiskSpace(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalDiskSpace, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalDiskSpace(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalDiskSpace, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__TotalVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__TotalVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__TotalVirtualMemory(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalVirtualMemory);
	if (soap_out__jsdl__TotalVirtualMemory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__TotalVirtualMemory(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalVirtualMemory), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalVirtualMemory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalVirtualMemory(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalVirtualMemory, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalVirtualMemory(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalVirtualMemory, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__TotalPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__TotalPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__TotalPhysicalMemory(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalPhysicalMemory);
	if (soap_out__jsdl__TotalPhysicalMemory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__TotalPhysicalMemory(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalPhysicalMemory), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalPhysicalMemory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalPhysicalMemory(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalPhysicalMemory, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalPhysicalMemory(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalPhysicalMemory, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__TotalCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__TotalCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__TotalCPUCount(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalCPUCount);
	if (soap_out__jsdl__TotalCPUCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__TotalCPUCount(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalCPUCount), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalCPUCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalCPUCount(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalCPUCount, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalCPUCount(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalCPUCount, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__TotalCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__TotalCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__TotalCPUTime(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalCPUTime);
	if (soap_out__jsdl__TotalCPUTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__TotalCPUTime(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalCPUTime), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalCPUTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalCPUTime(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalCPUTime, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalCPUTime(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalCPUTime, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__IndividualDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__IndividualDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__IndividualDiskSpace(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualDiskSpace);
	if (soap_out__jsdl__IndividualDiskSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__IndividualDiskSpace(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualDiskSpace), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualDiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualDiskSpace(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualDiskSpace, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualDiskSpace(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualDiskSpace, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__IndividualNetworkBandwidth(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__IndividualNetworkBandwidth(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__IndividualNetworkBandwidth(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualNetworkBandwidth);
	if (soap_out__jsdl__IndividualNetworkBandwidth(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__IndividualNetworkBandwidth(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualNetworkBandwidth), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualNetworkBandwidth(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualNetworkBandwidth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualNetworkBandwidth(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualNetworkBandwidth, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualNetworkBandwidth(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualNetworkBandwidth, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__IndividualVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__IndividualVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__IndividualVirtualMemory(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualVirtualMemory);
	if (soap_out__jsdl__IndividualVirtualMemory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__IndividualVirtualMemory(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualVirtualMemory), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualVirtualMemory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualVirtualMemory(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualVirtualMemory, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualVirtualMemory(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualVirtualMemory, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__IndividualPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__IndividualPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__IndividualPhysicalMemory(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualPhysicalMemory);
	if (soap_out__jsdl__IndividualPhysicalMemory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__IndividualPhysicalMemory(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualPhysicalMemory), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualPhysicalMemory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualPhysicalMemory(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualPhysicalMemory, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualPhysicalMemory(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualPhysicalMemory, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__IndividualCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__IndividualCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__IndividualCPUCount(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualCPUCount);
	if (soap_out__jsdl__IndividualCPUCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__IndividualCPUCount(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualCPUCount), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualCPUCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualCPUCount(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualCPUCount, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualCPUCount(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualCPUCount, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__IndividualCPUSpeed(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__IndividualCPUSpeed(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__IndividualCPUSpeed(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualCPUSpeed);
	if (soap_out__jsdl__IndividualCPUSpeed(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__IndividualCPUSpeed(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualCPUSpeed), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualCPUSpeed(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualCPUSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualCPUSpeed(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualCPUSpeed, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualCPUSpeed(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualCPUSpeed, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__IndividualCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__IndividualCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__IndividualCPUTime(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualCPUTime);
	if (soap_out__jsdl__IndividualCPUTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__IndividualCPUTime(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualCPUTime), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualCPUTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualCPUTime(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualCPUTime, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualCPUTime(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualCPUTime, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__DiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__DiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__DiskSpace(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__DiskSpace);
	if (soap_out__jsdl__DiskSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__DiskSpace(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__DiskSpace), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__DiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__DiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__DiskSpace(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__DiskSpace, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__DiskSpace(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__DiskSpace, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__FileSystem(struct soap *soap, struct jsdl__FileSystem_USCOREType *a)
{	soap_default_jsdl__FileSystem_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__FileSystem(struct soap *soap, struct jsdl__FileSystem_USCOREType const*a)
{	soap_serialize_jsdl__FileSystem_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__FileSystem(struct soap *soap, const struct jsdl__FileSystem_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__FileSystem);
	if (soap_out__jsdl__FileSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__FileSystem(struct soap *soap, const char *tag, int id, const struct jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__FileSystem), type);
	soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", -1, &a->jsdl__FileSystemType, "");
	soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, "");
	soap_out_string(soap, "jsdl:MountPoint", -1, &a->jsdl__MountPoint, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", -1, &a->jsdl__DiskSpace, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_get__jsdl__FileSystem(struct soap *soap, struct jsdl__FileSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__FileSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_in__jsdl__FileSystem(struct soap *soap, const char *tag, struct jsdl__FileSystem_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__FileSystemType = 1, soap_flag_jsdl__Description = 1, soap_flag_jsdl__MountPoint = 1, soap_flag_jsdl__DiskSpace = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__FileSystem_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__FileSystem, sizeof(struct jsdl__FileSystem_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__FileSystem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileSystemType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", &a->jsdl__FileSystemType, "jsdl:FileSystemTypeEnumeration")) {
					soap_flag_jsdl__FileSystemType--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type")) {
					soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag_jsdl__MountPoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:MountPoint", &a->jsdl__MountPoint, "xsd:string")) {
					soap_flag_jsdl__MountPoint--;
					continue;
				}
			if (soap_flag_jsdl__DiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", &a->jsdl__DiskSpace, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__DiskSpace--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__FileSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__FileSystem, 0, sizeof(struct jsdl__FileSystem_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__CPUArchitecture(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *a)
{	soap_default_jsdl__CPUArchitecture_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__CPUArchitecture(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType const*a)
{	soap_serialize_jsdl__CPUArchitecture_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__CPUArchitecture(struct soap *soap, const struct jsdl__CPUArchitecture_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__CPUArchitecture);
	if (soap_out__jsdl__CPUArchitecture(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__CPUArchitecture(struct soap *soap, const char *tag, int id, const struct jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__CPUArchitecture), type);
	soap_out_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", -1, &a->jsdl__CPUArchitectureName, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_get__jsdl__CPUArchitecture(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__CPUArchitecture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_in__jsdl__CPUArchitecture(struct soap *soap, const char *tag, struct jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__CPUArchitectureName = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__CPUArchitecture_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__CPUArchitecture, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__CPUArchitecture(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CPUArchitectureName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", &a->jsdl__CPUArchitectureName, "jsdl:ProcessorArchitectureEnumeration")) {
					soap_flag_jsdl__CPUArchitectureName--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__CPUArchitecture_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__CPUArchitecture, 0, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__CPUArchitectureName > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__OperatingSystemType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *a)
{	soap_default_jsdl__OperatingSystemType_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__OperatingSystemType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType const*a)
{	soap_serialize_jsdl__OperatingSystemType_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__OperatingSystemType(struct soap *soap, const struct jsdl__OperatingSystemType_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__OperatingSystemType);
	if (soap_out__jsdl__OperatingSystemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__OperatingSystemType(struct soap *soap, const char *tag, int id, const struct jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__OperatingSystemType), type);
	soap_out_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", -1, &a->jsdl__OperatingSystemName, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_get__jsdl__OperatingSystemType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__OperatingSystemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_in__jsdl__OperatingSystemType(struct soap *soap, const char *tag, struct jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__OperatingSystemName = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__OperatingSystemType_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__OperatingSystemType, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__OperatingSystemType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", &a->jsdl__OperatingSystemName, "jsdl:OperatingSystemTypeEnumeration")) {
					soap_flag_jsdl__OperatingSystemName--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__OperatingSystemType_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__OperatingSystemType, 0, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__OperatingSystemName > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__OperatingSystem(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *a)
{	soap_default_jsdl__OperatingSystem_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__OperatingSystem(struct soap *soap, struct jsdl__OperatingSystem_USCOREType const*a)
{	soap_serialize_jsdl__OperatingSystem_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__OperatingSystem(struct soap *soap, const struct jsdl__OperatingSystem_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__OperatingSystem);
	if (soap_out__jsdl__OperatingSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__OperatingSystem(struct soap *soap, const char *tag, int id, const struct jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__OperatingSystem), type);
	soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", -1, &a->jsdl__OperatingSystemType, "");
	soap_out_string(soap, "jsdl:OperatingSystemVersion", -1, &a->jsdl__OperatingSystemVersion, "");
	soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_get__jsdl__OperatingSystem(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__OperatingSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_in__jsdl__OperatingSystem(struct soap *soap, const char *tag, struct jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__OperatingSystemType = 1, soap_flag_jsdl__OperatingSystemVersion = 1, soap_flag_jsdl__Description = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__OperatingSystem_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__OperatingSystem, sizeof(struct jsdl__OperatingSystem_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__OperatingSystem(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", &a->jsdl__OperatingSystemType, "jsdl:OperatingSystemType_Type")) {
					soap_flag_jsdl__OperatingSystemType--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystemVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:OperatingSystemVersion", &a->jsdl__OperatingSystemVersion, "xsd:string")) {
					soap_flag_jsdl__OperatingSystemVersion--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type")) {
					soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__OperatingSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__OperatingSystem, 0, sizeof(struct jsdl__OperatingSystem_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__CandidateHosts(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *a)
{	soap_default_jsdl__CandidateHosts_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__CandidateHosts(struct soap *soap, struct jsdl__CandidateHosts_USCOREType const*a)
{	soap_serialize_jsdl__CandidateHosts_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__CandidateHosts(struct soap *soap, const struct jsdl__CandidateHosts_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__CandidateHosts);
	if (soap_out__jsdl__CandidateHosts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__CandidateHosts(struct soap *soap, const char *tag, int id, const struct jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__CandidateHosts), type);
	if (a->jsdl__HostName) {
		int i;
		for (i = 0; i < a->__sizeHostName; i++)
			soap_out_string(soap, "jsdl:HostName", -1, a->jsdl__HostName + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_get__jsdl__CandidateHosts(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__CandidateHosts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_in__jsdl__CandidateHosts(struct soap *soap, const char *tag, struct jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__HostName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__CandidateHosts_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__CandidateHosts, sizeof(struct jsdl__CandidateHosts_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__CandidateHosts(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__HostName && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeHostName = 0; !soap_element_begin_in(soap, "jsdl:HostName", 1, NULL); a->__sizeHostName++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:HostName", p, "xsd:string"))
						break;
					soap_flag_jsdl__HostName = 0;
				}
				a->jsdl__HostName = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__HostName && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__CandidateHosts_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__CandidateHosts, 0, sizeof(struct jsdl__CandidateHosts_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__Resources(struct soap *soap, struct jsdl__Resources_USCOREType *a)
{	soap_default_jsdl__Resources_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__Resources(struct soap *soap, struct jsdl__Resources_USCOREType const*a)
{	soap_serialize_jsdl__Resources_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__Resources(struct soap *soap, const struct jsdl__Resources_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Resources);
	if (soap_out__jsdl__Resources(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__Resources(struct soap *soap, const char *tag, int id, const struct jsdl__Resources_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__Resources), type);
	soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", -1, &a->jsdl__CandidateHosts, "");
	if (a->jsdl__FileSystem) {
		int i;
		for (i = 0; i < a->__sizeFileSystem; i++)
			soap_out_jsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", -1, a->jsdl__FileSystem + i, "");
	}
	soap_out_PointerToxsd__boolean(soap, "jsdl:ExclusiveExecution", -1, &a->jsdl__ExclusiveExecution, "");
	soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", -1, &a->jsdl__OperatingSystem, "");
	soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", -1, &a->jsdl__CPUArchitecture, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", -1, &a->jsdl__IndividualCPUSpeed, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", -1, &a->jsdl__IndividualCPUTime, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", -1, &a->jsdl__IndividualCPUCount, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", -1, &a->jsdl__IndividualNetworkBandwidth, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", -1, &a->jsdl__IndividualPhysicalMemory, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", -1, &a->jsdl__IndividualVirtualMemory, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", -1, &a->jsdl__IndividualDiskSpace, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", -1, &a->jsdl__TotalCPUTime, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", -1, &a->jsdl__TotalCPUCount, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", -1, &a->jsdl__TotalPhysicalMemory, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", -1, &a->jsdl__TotalVirtualMemory, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", -1, &a->jsdl__TotalDiskSpace, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", -1, &a->jsdl__TotalResourceCount, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType * SOAP_FMAC4 soap_get__jsdl__Resources(struct soap *soap, struct jsdl__Resources_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Resources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType * SOAP_FMAC4 soap_in__jsdl__Resources(struct soap *soap, const char *tag, struct jsdl__Resources_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__CandidateHosts = 1, soap_flag_jsdl__FileSystem = 1, soap_flag_jsdl__ExclusiveExecution = 1, soap_flag_jsdl__OperatingSystem = 1, soap_flag_jsdl__CPUArchitecture = 1, soap_flag_jsdl__IndividualCPUSpeed = 1, soap_flag_jsdl__IndividualCPUTime = 1, soap_flag_jsdl__IndividualCPUCount = 1, soap_flag_jsdl__IndividualNetworkBandwidth = 1, soap_flag_jsdl__IndividualPhysicalMemory = 1, soap_flag_jsdl__IndividualVirtualMemory = 1, soap_flag_jsdl__IndividualDiskSpace = 1, soap_flag_jsdl__TotalCPUTime = 1, soap_flag_jsdl__TotalCPUCount = 1, soap_flag_jsdl__TotalPhysicalMemory = 1, soap_flag_jsdl__TotalVirtualMemory = 1, soap_flag_jsdl__TotalDiskSpace = 1, soap_flag_jsdl__TotalResourceCount = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Resources_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__Resources, sizeof(struct jsdl__Resources_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__Resources(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CandidateHosts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", &a->jsdl__CandidateHosts, "jsdl:CandidateHosts_Type")) {
					soap_flag_jsdl__CandidateHosts--;
					continue;
				}
			if (soap_flag_jsdl__FileSystem && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__FileSystem_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeFileSystem = 0; !soap_element_begin_in(soap, "jsdl:FileSystem", 1, NULL); a->__sizeFileSystem++) {
					p = (struct jsdl__FileSystem_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__FileSystem_USCOREType));
					soap_default_jsdl__FileSystem_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", p, "jsdl:FileSystem_Type"))
						break;
					soap_flag_jsdl__FileSystem = 0;
				}
				a->jsdl__FileSystem = (struct jsdl__FileSystem_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__FileSystem && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl__ExclusiveExecution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "jsdl:ExclusiveExecution", &a->jsdl__ExclusiveExecution, "xsd:boolean")) {
					soap_flag_jsdl__ExclusiveExecution--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", &a->jsdl__OperatingSystem, "jsdl:OperatingSystem_Type")) {
					soap_flag_jsdl__OperatingSystem--;
					continue;
				}
			if (soap_flag_jsdl__CPUArchitecture && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", &a->jsdl__CPUArchitecture, "jsdl:CPUArchitecture_Type")) {
					soap_flag_jsdl__CPUArchitecture--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", &a->jsdl__IndividualCPUSpeed, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualCPUSpeed--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", &a->jsdl__IndividualCPUTime, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualCPUTime--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", &a->jsdl__IndividualCPUCount, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualCPUCount--;
					continue;
				}
			if (soap_flag_jsdl__IndividualNetworkBandwidth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", &a->jsdl__IndividualNetworkBandwidth, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualNetworkBandwidth--;
					continue;
				}
			if (soap_flag_jsdl__IndividualPhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", &a->jsdl__IndividualPhysicalMemory, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualPhysicalMemory--;
					continue;
				}
			if (soap_flag_jsdl__IndividualVirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", &a->jsdl__IndividualVirtualMemory, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualVirtualMemory--;
					continue;
				}
			if (soap_flag_jsdl__IndividualDiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", &a->jsdl__IndividualDiskSpace, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualDiskSpace--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", &a->jsdl__TotalCPUTime, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalCPUTime--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", &a->jsdl__TotalCPUCount, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalCPUCount--;
					continue;
				}
			if (soap_flag_jsdl__TotalPhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", &a->jsdl__TotalPhysicalMemory, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalPhysicalMemory--;
					continue;
				}
			if (soap_flag_jsdl__TotalVirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", &a->jsdl__TotalVirtualMemory, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalVirtualMemory--;
					continue;
				}
			if (soap_flag_jsdl__TotalDiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", &a->jsdl__TotalDiskSpace, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalDiskSpace--;
					continue;
				}
			if (soap_flag_jsdl__TotalResourceCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", &a->jsdl__TotalResourceCount, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalResourceCount--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__Resources_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__Resources, 0, sizeof(struct jsdl__Resources_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__Application(struct soap *soap, struct jsdl__Application_USCOREType *a)
{	soap_default_jsdl__Application_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__Application(struct soap *soap, struct jsdl__Application_USCOREType const*a)
{	soap_serialize_jsdl__Application_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__Application(struct soap *soap, const struct jsdl__Application_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Application);
	if (soap_out__jsdl__Application(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__Application(struct soap *soap, const char *tag, int id, const struct jsdl__Application_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__Application), type);
	soap_out_string(soap, "jsdl:ApplicationName", -1, &a->jsdl__ApplicationName, "");
	soap_out_string(soap, "jsdl:ApplicationVersion", -1, &a->jsdl__ApplicationVersion, "");
	soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__Application_USCOREType * SOAP_FMAC4 soap_get__jsdl__Application(struct soap *soap, struct jsdl__Application_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Application(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Application_USCOREType * SOAP_FMAC4 soap_in__jsdl__Application(struct soap *soap, const char *tag, struct jsdl__Application_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__ApplicationName = 1, soap_flag_jsdl__ApplicationVersion = 1, soap_flag_jsdl__Description = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Application_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__Application, sizeof(struct jsdl__Application_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__Application(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__ApplicationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:ApplicationName", &a->jsdl__ApplicationName, "xsd:string")) {
					soap_flag_jsdl__ApplicationName--;
					continue;
				}
			if (soap_flag_jsdl__ApplicationVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:ApplicationVersion", &a->jsdl__ApplicationVersion, "xsd:string")) {
					soap_flag_jsdl__ApplicationVersion--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type")) {
					soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__Application_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__Application, 0, sizeof(struct jsdl__Application_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__JobIdentification(struct soap *soap, struct jsdl__JobIdentification_USCOREType *a)
{	soap_default_jsdl__JobIdentification_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__JobIdentification(struct soap *soap, struct jsdl__JobIdentification_USCOREType const*a)
{	soap_serialize_jsdl__JobIdentification_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__JobIdentification(struct soap *soap, const struct jsdl__JobIdentification_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobIdentification);
	if (soap_out__jsdl__JobIdentification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__JobIdentification(struct soap *soap, const char *tag, int id, const struct jsdl__JobIdentification_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__JobIdentification), type);
	soap_out_string(soap, "jsdl:JobName", -1, &a->jsdl__JobName, "");
	soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, "");
	if (a->jsdl__JobAnnotation) {
		int i;
		for (i = 0; i < a->__sizeJobAnnotation; i++)
			soap_out_string(soap, "jsdl:JobAnnotation", -1, a->jsdl__JobAnnotation + i, "");
	}
	if (a->jsdl__JobProject) {
		int i;
		for (i = 0; i < a->__sizeJobProject; i++)
			soap_out_string(soap, "jsdl:JobProject", -1, a->jsdl__JobProject + i, "");
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_get__jsdl__JobIdentification(struct soap *soap, struct jsdl__JobIdentification_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_in__jsdl__JobIdentification(struct soap *soap, const char *tag, struct jsdl__JobIdentification_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobName = 1, soap_flag_jsdl__Description = 1, soap_flag_jsdl__JobAnnotation = 1, soap_flag_jsdl__JobProject = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobIdentification_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__JobIdentification, sizeof(struct jsdl__JobIdentification_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__JobIdentification(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:JobName", &a->jsdl__JobName, "xsd:string")) {
					soap_flag_jsdl__JobName--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type")) {
					soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag_jsdl__JobAnnotation && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeJobAnnotation = 0; !soap_element_begin_in(soap, "jsdl:JobAnnotation", 1, NULL); a->__sizeJobAnnotation++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:JobAnnotation", p, "xsd:string"))
						break;
					soap_flag_jsdl__JobAnnotation = 0;
				}
				a->jsdl__JobAnnotation = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__JobAnnotation && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl__JobProject && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeJobProject = 0; !soap_element_begin_in(soap, "jsdl:JobProject", 1, NULL); a->__sizeJobProject++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:JobProject", p, "xsd:string"))
						break;
					soap_flag_jsdl__JobProject = 0;
				}
				a->jsdl__JobProject = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__JobProject && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__JobIdentification_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__JobIdentification, 0, sizeof(struct jsdl__JobIdentification_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__JobDescription(struct soap *soap, struct jsdl__JobDescription_USCOREType *a)
{	soap_default_jsdl__JobDescription_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__JobDescription(struct soap *soap, struct jsdl__JobDescription_USCOREType const*a)
{	soap_serialize_jsdl__JobDescription_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__JobDescription(struct soap *soap, const struct jsdl__JobDescription_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobDescription);
	if (soap_out__jsdl__JobDescription(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__JobDescription(struct soap *soap, const char *tag, int id, const struct jsdl__JobDescription_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__JobDescription), type);
	soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", -1, &a->jsdl__JobIdentification, "");
	soap_out_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", -1, &a->jsdl__Application, "");
	soap_out_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", -1, &a->jsdl__Resources, "");
	if (a->jsdl__DataStaging) {
		int i;
		for (i = 0; i < a->__sizeDataStaging; i++)
			soap_out_jsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", -1, a->jsdl__DataStaging + i, "");
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_get__jsdl__JobDescription(struct soap *soap, struct jsdl__JobDescription_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_in__jsdl__JobDescription(struct soap *soap, const char *tag, struct jsdl__JobDescription_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobIdentification = 1, soap_flag_jsdl__Application = 1, soap_flag_jsdl__Resources = 1, soap_flag_jsdl__DataStaging = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobDescription_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__JobDescription, sizeof(struct jsdl__JobDescription_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__JobDescription(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobIdentification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", &a->jsdl__JobIdentification, "jsdl:JobIdentification_Type")) {
					soap_flag_jsdl__JobIdentification--;
					continue;
				}
			if (soap_flag_jsdl__Application && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", &a->jsdl__Application, "jsdl:Application_Type")) {
					soap_flag_jsdl__Application--;
					continue;
				}
			if (soap_flag_jsdl__Resources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", &a->jsdl__Resources, "jsdl:Resources_Type")) {
					soap_flag_jsdl__Resources--;
					continue;
				}
			if (soap_flag_jsdl__DataStaging && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__DataStaging_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeDataStaging = 0; !soap_element_begin_in(soap, "jsdl:DataStaging", 1, NULL); a->__sizeDataStaging++) {
					p = (struct jsdl__DataStaging_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__DataStaging_USCOREType));
					soap_default_jsdl__DataStaging_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", p, "jsdl:DataStaging_Type"))
						break;
					soap_flag_jsdl__DataStaging = 0;
				}
				a->jsdl__DataStaging = (struct jsdl__DataStaging_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__DataStaging && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__JobDescription_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__JobDescription, 0, sizeof(struct jsdl__JobDescription_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__JobDefinition(struct soap *soap, struct jsdl__JobDefinition_USCOREType *a)
{	soap_default_jsdl__JobDefinition_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__JobDefinition(struct soap *soap, struct jsdl__JobDefinition_USCOREType const*a)
{	soap_serialize_jsdl__JobDefinition_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__JobDefinition(struct soap *soap, const struct jsdl__JobDefinition_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobDefinition);
	if (soap_out__jsdl__JobDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__JobDefinition(struct soap *soap, const char *tag, int id, const struct jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__JobDefinition), type);
	soap_out_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", -1, &a->jsdl__JobDescription, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_get__jsdl__JobDefinition(struct soap *soap, struct jsdl__JobDefinition_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_in__jsdl__JobDefinition(struct soap *soap, const char *tag, struct jsdl__JobDefinition_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobDescription = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobDefinition_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__JobDefinition, sizeof(struct jsdl__JobDefinition_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__JobDefinition(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 0), &a->id))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", &a->jsdl__JobDescription, "jsdl:JobDescription_Type")) {
					soap_flag_jsdl__JobDescription--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__JobDefinition_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__JobDefinition, 0, sizeof(struct jsdl__JobDefinition_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDescription > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__ProblemAction(struct soap *soap, struct wsa__ProblemActionType *a)
{	soap_default_wsa__ProblemActionType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__ProblemAction(struct soap *soap, struct wsa__ProblemActionType const*a)
{	soap_serialize_wsa__ProblemActionType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__ProblemAction(struct soap *soap, const struct wsa__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ProblemAction);
	if (soap_out__wsa__ProblemAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__ProblemAction(struct soap *soap, const char *tag, int id, const struct wsa__ProblemActionType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__ProblemAction), type);
	soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Action", -1, &a->wsa__Action, "");
	soap_out_xsd__anyURI(soap, "wsa:SoapAction", -1, &a->SoapAction, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__ProblemActionType * SOAP_FMAC4 soap_get__wsa__ProblemAction(struct soap *soap, struct wsa__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ProblemAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ProblemActionType * SOAP_FMAC4 soap_in__wsa__ProblemAction(struct soap *soap, const char *tag, struct wsa__ProblemActionType *a, const char *type)
{
	short soap_flag_wsa__Action = 1, soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ProblemAction, sizeof(struct wsa__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__ProblemAction(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__Action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Action", &a->wsa__Action, "wsa:AttributedURIType")) {
					soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "wsa:SoapAction", &a->SoapAction, "xsd:anyURI")) {
					soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__ProblemAction, 0, sizeof(struct wsa__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__ProblemIRI(struct soap *soap, struct wsa__AttributedURIType *a)
{	soap_default_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__ProblemIRI(struct soap *soap, struct wsa__AttributedURIType const*a)
{	soap_serialize_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__ProblemIRI(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ProblemIRI);
	if (soap_out__wsa__ProblemIRI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__ProblemIRI(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get__wsa__ProblemIRI(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ProblemIRI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in__wsa__ProblemIRI(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ProblemIRI, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__ProblemIRI(soap, a);
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__ProblemHeaderQName(struct soap *soap, struct wsa__AttributedQNameType *a)
{	soap_default_wsa__AttributedQNameType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__ProblemHeaderQName(struct soap *soap, struct wsa__AttributedQNameType const*a)
{	soap_serialize_wsa__AttributedQNameType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__ProblemHeaderQName(struct soap *soap, const struct wsa__AttributedQNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ProblemHeaderQName);
	if (soap_out__wsa__ProblemHeaderQName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__ProblemHeaderQName(struct soap *soap, const char *tag, int id, const struct wsa__AttributedQNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	return soap_out_xsd__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__AttributedQNameType * SOAP_FMAC4 soap_get__wsa__ProblemHeaderQName(struct soap *soap, struct wsa__AttributedQNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ProblemHeaderQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedQNameType * SOAP_FMAC4 soap_in__wsa__ProblemHeaderQName(struct soap *soap, const char *tag, struct wsa__AttributedQNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedQNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ProblemHeaderQName, sizeof(struct wsa__AttributedQNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__ProblemHeaderQName(soap, a);
	if (!soap_in_xsd__QName(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__RetryAfter(struct soap *soap, struct wsa__AttributedUnsignedLongType *a)
{	soap_default_wsa__AttributedUnsignedLongType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__RetryAfter(struct soap *soap, struct wsa__AttributedUnsignedLongType const*a)
{	soap_serialize_wsa__AttributedUnsignedLongType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__RetryAfter(struct soap *soap, const struct wsa__AttributedUnsignedLongType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__RetryAfter);
	if (soap_out__wsa__RetryAfter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__RetryAfter(struct soap *soap, const char *tag, int id, const struct wsa__AttributedUnsignedLongType *a, const char *type)
{
	return soap_out_unsignedLONG64(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedUnsignedLongType * SOAP_FMAC4 soap_get__wsa__RetryAfter(struct soap *soap, struct wsa__AttributedUnsignedLongType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__RetryAfter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedUnsignedLongType * SOAP_FMAC4 soap_in__wsa__RetryAfter(struct soap *soap, const char *tag, struct wsa__AttributedUnsignedLongType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedUnsignedLongType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__RetryAfter, sizeof(struct wsa__AttributedUnsignedLongType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__RetryAfter(soap, a);
	if (!soap_in_unsignedLONG64(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__Action(struct soap *soap, struct wsa__AttributedURIType *a)
{	soap_default_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__Action(struct soap *soap, struct wsa__AttributedURIType const*a)
{	soap_serialize_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__Action(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__Action);
	if (soap_out__wsa__Action(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__Action(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get__wsa__Action(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__Action(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in__wsa__Action(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__Action, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__Action(soap, a);
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__To(struct soap *soap, struct wsa__AttributedURIType *a)
{	soap_default_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__To(struct soap *soap, struct wsa__AttributedURIType const*a)
{	soap_serialize_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__To(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__To);
	if (soap_out__wsa__To(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__To(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get__wsa__To(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__To(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in__wsa__To(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__To, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__To(soap, a);
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *a)
{	soap_default_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType const*a)
{	soap_serialize_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__FaultTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__FaultTo);
	if (soap_out__wsa__FaultTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__FaultTo(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__FaultTo), type);
	soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, "");
	soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, "");
	soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get__wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in__wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__FaultTo(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType")) {
					soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType")) {
					soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType")) {
					soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__FaultTo, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *a)
{	soap_default_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__From(struct soap *soap, struct wsa__EndpointReferenceType const*a)
{	soap_serialize_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__From(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__From);
	if (soap_out__wsa__From(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__From(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__From), type);
	soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, "");
	soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, "");
	soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get__wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in__wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__From(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType")) {
					soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType")) {
					soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType")) {
					soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__From, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *a)
{	soap_default_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType const*a)
{	soap_serialize_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__ReplyTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ReplyTo);
	if (soap_out__wsa__ReplyTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__ReplyTo(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__ReplyTo), type);
	soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, "");
	soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, "");
	soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get__wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in__wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__ReplyTo(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType")) {
					soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType")) {
					soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType")) {
					soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__ReplyTo, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType *a)
{	soap_default_wsa__RelatesToType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType const*a)
{	soap_serialize_wsa__RelatesToType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__RelatesTo(struct soap *soap, const struct wsa__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__RelatesTo);
	if (soap_out__wsa__RelatesTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__RelatesTo(struct soap *soap, const char *tag, int id, const struct wsa__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType);
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__RelatesToType * SOAP_FMAC4 soap_get__wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__RelatesToType * SOAP_FMAC4 soap_in__wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__RelatesTo(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__MessageID(struct soap *soap, struct wsa__AttributedURIType *a)
{	soap_default_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__MessageID(struct soap *soap, struct wsa__AttributedURIType const*a)
{	soap_serialize_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__MessageID(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__MessageID);
	if (soap_out__wsa__MessageID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__MessageID(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get__wsa__MessageID(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__MessageID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in__wsa__MessageID(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__MessageID, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__MessageID(soap, a);
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__Metadata(struct soap *soap, struct wsa__MetadataType *a)
{	soap_default_wsa__MetadataType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__Metadata(struct soap *soap, struct wsa__MetadataType const*a)
{	soap_serialize_wsa__MetadataType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__Metadata(struct soap *soap, const struct wsa__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__Metadata);
	if (soap_out__wsa__Metadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__Metadata(struct soap *soap, const char *tag, int id, const struct wsa__MetadataType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__Metadata), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__MetadataType * SOAP_FMAC4 soap_get__wsa__Metadata(struct soap *soap, struct wsa__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__Metadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__MetadataType * SOAP_FMAC4 soap_in__wsa__Metadata(struct soap *soap, const char *tag, struct wsa__MetadataType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__Metadata, sizeof(struct wsa__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__Metadata(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__Metadata, 0, sizeof(struct wsa__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__ReferenceParameters(struct soap *soap, struct wsa__ReferenceParametersType *a)
{	soap_default_wsa__ReferenceParametersType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__ReferenceParameters(struct soap *soap, struct wsa__ReferenceParametersType const*a)
{	soap_serialize_wsa__ReferenceParametersType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__ReferenceParameters(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ReferenceParameters);
	if (soap_out__wsa__ReferenceParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__ReferenceParameters(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__ReferenceParameters), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get__wsa__ReferenceParameters(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ReferenceParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in__wsa__ReferenceParameters(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ReferenceParameters, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__ReferenceParameters(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__ReferenceParameters, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsa__EndpointReference(struct soap *soap, struct wsa__EndpointReferenceType *a)
{	soap_default_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsa__EndpointReference(struct soap *soap, struct wsa__EndpointReferenceType const*a)
{	soap_serialize_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsa__EndpointReference(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__EndpointReference);
	if (soap_out__wsa__EndpointReference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsa__EndpointReference(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__EndpointReference), type);
	soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, "");
	soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, "");
	soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get__wsa__EndpointReference(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__EndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in__wsa__EndpointReference(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__EndpointReference, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__EndpointReference(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType")) {
					soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType")) {
					soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType")) {
					soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__EndpointReference, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__ActivityStatus(struct soap *soap, struct bes__ActivityStatusType *a)
{	soap_default_bes__ActivityStatusType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__ActivityStatus(struct soap *soap, struct bes__ActivityStatusType const*a)
{	soap_serialize_bes__ActivityStatusType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__ActivityStatus(struct soap *soap, const struct bes__ActivityStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__ActivityStatus);
	if (soap_out__bes__ActivityStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__ActivityStatus(struct soap *soap, const char *tag, int id, const struct bes__ActivityStatusType *a, const char *type)
{
	soap_set_attr(soap, "state", soap_bes__ActivityStateEnumeration2s(soap, a->state));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__ActivityStatus), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__ActivityStatusType * SOAP_FMAC4 soap_get__bes__ActivityStatus(struct soap *soap, struct bes__ActivityStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__ActivityStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityStatusType * SOAP_FMAC4 soap_in__bes__ActivityStatus(struct soap *soap, const char *tag, struct bes__ActivityStatusType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__ActivityStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__ActivityStatus, sizeof(struct bes__ActivityStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__ActivityStatus(soap, a);
	if (soap_s2bes__ActivityStateEnumeration(soap, soap_attr_value(soap, "state", 1), &a->state))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__ActivityStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__ActivityStatus, 0, sizeof(struct bes__ActivityStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__ActivityDocument(struct soap *soap, struct bes__ActivityDocumentType *a)
{	soap_default_bes__ActivityDocumentType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__ActivityDocument(struct soap *soap, struct bes__ActivityDocumentType const*a)
{	soap_serialize_bes__ActivityDocumentType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__ActivityDocument(struct soap *soap, const struct bes__ActivityDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__ActivityDocument);
	if (soap_out__bes__ActivityDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__ActivityDocument(struct soap *soap, const char *tag, int id, const struct bes__ActivityDocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__ActivityDocument), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__ActivityDocumentType * SOAP_FMAC4 soap_get__bes__ActivityDocument(struct soap *soap, struct bes__ActivityDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__ActivityDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityDocumentType * SOAP_FMAC4 soap_in__bes__ActivityDocument(struct soap *soap, const char *tag, struct bes__ActivityDocumentType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__ActivityDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__ActivityDocument, sizeof(struct bes__ActivityDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__ActivityDocument(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__ActivityDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__ActivityDocument, 0, sizeof(struct bes__ActivityDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__FactoryResourceAttributesDocument(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType *a)
{	soap_default_bes__FactoryResourceAttributesDocumentType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__FactoryResourceAttributesDocument(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType const*a)
{	soap_serialize_bes__FactoryResourceAttributesDocumentType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__FactoryResourceAttributesDocument(struct soap *soap, const struct bes__FactoryResourceAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__FactoryResourceAttributesDocument);
	if (soap_out__bes__FactoryResourceAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__FactoryResourceAttributesDocument(struct soap *soap, const char *tag, int id, const struct bes__FactoryResourceAttributesDocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__FactoryResourceAttributesDocument), type);
	soap_out_PointerTobes__BasicResourceAttributesDocumentType(soap, "bes:BasicResourceAttributesDocument", -1, &a->bes__BasicResourceAttributesDocument, "");
	soap_out_xsd__boolean(soap, "bes:IsAcceptingNewActivities", -1, &a->IsAcceptingNewActivities, "");
	soap_out_string(soap, "bes:CommonName", -1, &a->CommonName, "");
	soap_out_string(soap, "bes:LongDescription", -1, &a->LongDescription, "");
	soap_out_LONG64(soap, "bes:TotalNumberOfActivities", -1, &a->TotalNumberOfActivities, "");
	if (a->ActivityReference) {
		int i;
		for (i = 0; i < a->__sizeActivityReference; i++)
			soap_out_wsa__EndpointReferenceType(soap, "bes:ActivityReference", -1, a->ActivityReference + i, "");
	}
	soap_out_LONG64(soap, "bes:TotalNumberOfContainedResources", -1, &a->TotalNumberOfContainedResources, "");
	if (a->ContainedResource) {
		int i;
		for (i = 0; i < a->__sizeContainedResource; i++)
			soap_out_xsd__anyType(soap, "bes:ContainedResource", -1, a->ContainedResource + i, "");
	}
	if (a->NamingProfile) {
		int i;
		for (i = 0; i < a->__sizeNamingProfile; i++)
			soap_out_xsd__anyURI(soap, "bes:NamingProfile", -1, a->NamingProfile + i, "");
	}
	if (a->BESExtension) {
		int i;
		for (i = 0; i < a->__sizeBESExtension; i++)
			soap_out_xsd__anyURI(soap, "bes:BESExtension", -1, a->BESExtension + i, "");
	}
	soap_out_xsd__anyURI(soap, "bes:LocalResourceManagerType", -1, &a->LocalResourceManagerType, "");
	soap_out_PointerTohpcp_af__AdvancedFilterType(soap, "bes:AdvancedFilter", -1, &a->AdvancedFilter, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_get__bes__FactoryResourceAttributesDocument(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__FactoryResourceAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_in__bes__FactoryResourceAttributesDocument(struct soap *soap, const char *tag, struct bes__FactoryResourceAttributesDocumentType *a, const char *type)
{
	short soap_flag_bes__BasicResourceAttributesDocument = 1, soap_flag_IsAcceptingNewActivities = 1, soap_flag_CommonName = 1, soap_flag_LongDescription = 1, soap_flag_TotalNumberOfActivities = 1, soap_flag_ActivityReference = 1, soap_flag_TotalNumberOfContainedResources = 1, soap_flag_ContainedResource = 1, soap_flag_NamingProfile = 1, soap_flag_BESExtension = 1, soap_flag_LocalResourceManagerType = 1, soap_flag_AdvancedFilter = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__FactoryResourceAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__FactoryResourceAttributesDocument, sizeof(struct bes__FactoryResourceAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__FactoryResourceAttributesDocument(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__BasicResourceAttributesDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__BasicResourceAttributesDocumentType(soap, "bes:BasicResourceAttributesDocument", &a->bes__BasicResourceAttributesDocument, "bes:BasicResourceAttributesDocumentType")) {
					soap_flag_bes__BasicResourceAttributesDocument--;
					continue;
				}
			if (soap_flag_IsAcceptingNewActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "bes:IsAcceptingNewActivities", &a->IsAcceptingNewActivities, "xsd:boolean")) {
					soap_flag_IsAcceptingNewActivities--;
					continue;
				}
			if (soap_flag_CommonName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:CommonName", &a->CommonName, "xsd:string")) {
					soap_flag_CommonName--;
					continue;
				}
			if (soap_flag_LongDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:LongDescription", &a->LongDescription, "xsd:string")) {
					soap_flag_LongDescription--;
					continue;
				}
			if (soap_flag_TotalNumberOfActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "bes:TotalNumberOfActivities", &a->TotalNumberOfActivities, "xsd:long")) {
					soap_flag_TotalNumberOfActivities--;
					continue;
				}
			if (soap_flag_ActivityReference && soap->error == SOAP_TAG_MISMATCH) {
				struct wsa__EndpointReferenceType *p;
				soap_new_block(soap);
				for (a->__sizeActivityReference = 0; !soap_element_begin_in(soap, "bes:ActivityReference", 1, NULL); a->__sizeActivityReference++) {
					p = (struct wsa__EndpointReferenceType *)soap_push_block(soap, sizeof(struct wsa__EndpointReferenceType));
					soap_default_wsa__EndpointReferenceType(soap, p);
					soap_revert(soap);
					if (!soap_in_wsa__EndpointReferenceType(soap, "bes:ActivityReference", p, "wsa:EndpointReferenceType"))
						break;
					soap_flag_ActivityReference = 0;
				}
				a->ActivityReference = (struct wsa__EndpointReferenceType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ActivityReference && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_TotalNumberOfContainedResources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "bes:TotalNumberOfContainedResources", &a->TotalNumberOfContainedResources, "xsd:long")) {
					soap_flag_TotalNumberOfContainedResources--;
					continue;
				}
			if (soap_flag_ContainedResource && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__sizeContainedResource = 0; !soap_element_begin_in(soap, "bes:ContainedResource", 1, NULL); a->__sizeContainedResource++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					soap_revert(soap);
					if (!soap_in_xsd__anyType(soap, "bes:ContainedResource", p, "xsd:anyType"))
						break;
					soap_flag_ContainedResource = 0;
				}
				a->ContainedResource = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ContainedResource && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_NamingProfile && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeNamingProfile = 0; !soap_element_begin_in(soap, "bes:NamingProfile", 1, NULL); a->__sizeNamingProfile++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "bes:NamingProfile", p, "xsd:anyURI"))
						break;
					soap_flag_NamingProfile = 0;
				}
				a->NamingProfile = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_NamingProfile && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_BESExtension && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeBESExtension = 0; !soap_element_begin_in(soap, "bes:BESExtension", 1, NULL); a->__sizeBESExtension++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "bes:BESExtension", p, "xsd:anyURI"))
						break;
					soap_flag_BESExtension = 0;
				}
				a->BESExtension = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_BESExtension && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_LocalResourceManagerType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "bes:LocalResourceManagerType", &a->LocalResourceManagerType, "xsd:anyURI")) {
					soap_flag_LocalResourceManagerType--;
					continue;
				}
			if (soap_flag_AdvancedFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTohpcp_af__AdvancedFilterType(soap, "bes:AdvancedFilter", &a->AdvancedFilter, "hpcp-af:AdvancedFilterType")) {
					soap_flag_AdvancedFilter--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__FactoryResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__FactoryResourceAttributesDocument, 0, sizeof(struct bes__FactoryResourceAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IsAcceptingNewActivities > 0 || soap_flag_TotalNumberOfActivities > 0 || soap_flag_TotalNumberOfContainedResources > 0 || soap_flag_LocalResourceManagerType > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__BasicResourceAttributesDocument(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *a)
{	soap_default_bes__BasicResourceAttributesDocumentType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__BasicResourceAttributesDocument(struct soap *soap, struct bes__BasicResourceAttributesDocumentType const*a)
{	soap_serialize_bes__BasicResourceAttributesDocumentType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__BasicResourceAttributesDocument(struct soap *soap, const struct bes__BasicResourceAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__BasicResourceAttributesDocument);
	if (soap_out__bes__BasicResourceAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__BasicResourceAttributesDocument(struct soap *soap, const char *tag, int id, const struct bes__BasicResourceAttributesDocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__BasicResourceAttributesDocument), type);
	soap_out_string(soap, "bes:ResourceName", -1, &a->ResourceName, "");
	soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "bes:OperatingSystem", -1, &a->OperatingSystem, "");
	soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "bes:CPUArchitecture", -1, &a->CPUArchitecture, "");
	soap_out_PointerTodouble(soap, "bes:CPUCount", -1, &a->CPUCount, "");
	soap_out_PointerTodouble(soap, "bes:CPUSpeed", -1, &a->CPUSpeed, "");
	soap_out_PointerTodouble(soap, "bes:PhysicalMemory", -1, &a->PhysicalMemory, "");
	soap_out_PointerTodouble(soap, "bes:VirtualMemory", -1, &a->VirtualMemory, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType * SOAP_FMAC4 soap_get__bes__BasicResourceAttributesDocument(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__BasicResourceAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType * SOAP_FMAC4 soap_in__bes__BasicResourceAttributesDocument(struct soap *soap, const char *tag, struct bes__BasicResourceAttributesDocumentType *a, const char *type)
{
	short soap_flag_ResourceName = 1, soap_flag_OperatingSystem = 1, soap_flag_CPUArchitecture = 1, soap_flag_CPUCount = 1, soap_flag_CPUSpeed = 1, soap_flag_PhysicalMemory = 1, soap_flag_VirtualMemory = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__BasicResourceAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__BasicResourceAttributesDocument, sizeof(struct bes__BasicResourceAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__BasicResourceAttributesDocument(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:ResourceName", &a->ResourceName, "xsd:string")) {
					soap_flag_ResourceName--;
					continue;
				}
			if (soap_flag_OperatingSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "bes:OperatingSystem", &a->OperatingSystem, "jsdl:OperatingSystem_Type")) {
					soap_flag_OperatingSystem--;
					continue;
				}
			if (soap_flag_CPUArchitecture && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "bes:CPUArchitecture", &a->CPUArchitecture, "jsdl:CPUArchitecture_Type")) {
					soap_flag_CPUArchitecture--;
					continue;
				}
			if (soap_flag_CPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:CPUCount", &a->CPUCount, "xsd:double")) {
					soap_flag_CPUCount--;
					continue;
				}
			if (soap_flag_CPUSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:CPUSpeed", &a->CPUSpeed, "xsd:double")) {
					soap_flag_CPUSpeed--;
					continue;
				}
			if (soap_flag_PhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:PhysicalMemory", &a->PhysicalMemory, "xsd:double")) {
					soap_flag_PhysicalMemory--;
					continue;
				}
			if (soap_flag_VirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:VirtualMemory", &a->VirtualMemory, "xsd:double")) {
					soap_flag_VirtualMemory--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__BasicResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__BasicResourceAttributesDocument, 0, sizeof(struct bes__BasicResourceAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__InvalidRequestMessageFault(struct soap *soap, struct bes__InvalidRequestMessageFaultType *a)
{	soap_default_bes__InvalidRequestMessageFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__InvalidRequestMessageFault(struct soap *soap, struct bes__InvalidRequestMessageFaultType const*a)
{	soap_serialize_bes__InvalidRequestMessageFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__InvalidRequestMessageFault(struct soap *soap, const struct bes__InvalidRequestMessageFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__InvalidRequestMessageFault);
	if (soap_out__bes__InvalidRequestMessageFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__InvalidRequestMessageFault(struct soap *soap, const char *tag, int id, const struct bes__InvalidRequestMessageFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__InvalidRequestMessageFault), type);
	if (a->InvalidElement) {
		int i;
		for (i = 0; i < a->__sizeInvalidElement; i++)
			soap_out_string(soap, "bes:InvalidElement", -1, a->InvalidElement + i, "");
	}
	soap_out_string(soap, "bes:Message", -1, &a->Message, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType * SOAP_FMAC4 soap_get__bes__InvalidRequestMessageFault(struct soap *soap, struct bes__InvalidRequestMessageFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__InvalidRequestMessageFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType * SOAP_FMAC4 soap_in__bes__InvalidRequestMessageFault(struct soap *soap, const char *tag, struct bes__InvalidRequestMessageFaultType *a, const char *type)
{
	short soap_flag_InvalidElement = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__InvalidRequestMessageFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__InvalidRequestMessageFault, sizeof(struct bes__InvalidRequestMessageFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__InvalidRequestMessageFault(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InvalidElement && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeInvalidElement = 0; !soap_element_begin_in(soap, "bes:InvalidElement", 1, NULL); a->__sizeInvalidElement++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "bes:InvalidElement", p, "xsd:string"))
						break;
					soap_flag_InvalidElement = 0;
				}
				a->InvalidElement = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_InvalidElement && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string")) {
					soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__InvalidRequestMessageFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__InvalidRequestMessageFault, 0, sizeof(struct bes__InvalidRequestMessageFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__InvalidActivityIdentifierFault(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType *a)
{	soap_default_bes__InvalidActivityIdentifierFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__InvalidActivityIdentifierFault(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType const*a)
{	soap_serialize_bes__InvalidActivityIdentifierFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__InvalidActivityIdentifierFault(struct soap *soap, const struct bes__InvalidActivityIdentifierFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__InvalidActivityIdentifierFault);
	if (soap_out__bes__InvalidActivityIdentifierFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__InvalidActivityIdentifierFault(struct soap *soap, const char *tag, int id, const struct bes__InvalidActivityIdentifierFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__InvalidActivityIdentifierFault), type);
	soap_out_string(soap, "bes:Message", -1, &a->Message, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__InvalidActivityIdentifierFaultType * SOAP_FMAC4 soap_get__bes__InvalidActivityIdentifierFault(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__InvalidActivityIdentifierFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidActivityIdentifierFaultType * SOAP_FMAC4 soap_in__bes__InvalidActivityIdentifierFault(struct soap *soap, const char *tag, struct bes__InvalidActivityIdentifierFaultType *a, const char *type)
{
	short soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__InvalidActivityIdentifierFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__InvalidActivityIdentifierFault, sizeof(struct bes__InvalidActivityIdentifierFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__InvalidActivityIdentifierFault(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string")) {
					soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__InvalidActivityIdentifierFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__InvalidActivityIdentifierFault, 0, sizeof(struct bes__InvalidActivityIdentifierFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType *a)
{	soap_default_bes__OperationWillBeAppliedEventuallyFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType const*a)
{	soap_serialize_bes__OperationWillBeAppliedEventuallyFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, const struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault);
	if (soap_out__bes__OperationWillBeAppliedEventuallyFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, const char *tag, int id, const struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault), type);
	soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->ActivityStatus, "");
	soap_out_string(soap, "bes:Message", -1, &a->Message, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__OperationWillBeAppliedEventuallyFaultType * SOAP_FMAC4 soap_get__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__OperationWillBeAppliedEventuallyFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__OperationWillBeAppliedEventuallyFaultType * SOAP_FMAC4 soap_in__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, const char *tag, struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *type)
{
	short soap_flag_ActivityStatus = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__OperationWillBeAppliedEventuallyFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault, sizeof(struct bes__OperationWillBeAppliedEventuallyFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__OperationWillBeAppliedEventuallyFault(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->ActivityStatus, "bes:ActivityStatusType")) {
					soap_flag_ActivityStatus--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string")) {
					soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__OperationWillBeAppliedEventuallyFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault, 0, sizeof(struct bes__OperationWillBeAppliedEventuallyFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityStatus > 0 || soap_flag_Message > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType *a)
{	soap_default_bes__CantApplyOperationToCurrentStateFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType const*a)
{	soap_serialize_bes__CantApplyOperationToCurrentStateFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, const struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault);
	if (soap_out__bes__CantApplyOperationToCurrentStateFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, const char *tag, int id, const struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault), type);
	soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->ActivityStatus, "");
	soap_out_string(soap, "bes:Message", -1, &a->Message, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__CantApplyOperationToCurrentStateFaultType * SOAP_FMAC4 soap_get__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__CantApplyOperationToCurrentStateFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CantApplyOperationToCurrentStateFaultType * SOAP_FMAC4 soap_in__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, const char *tag, struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *type)
{
	short soap_flag_ActivityStatus = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CantApplyOperationToCurrentStateFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault, sizeof(struct bes__CantApplyOperationToCurrentStateFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__CantApplyOperationToCurrentStateFault(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->ActivityStatus, "bes:ActivityStatusType")) {
					soap_flag_ActivityStatus--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string")) {
					soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__CantApplyOperationToCurrentStateFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault, 0, sizeof(struct bes__CantApplyOperationToCurrentStateFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityStatus > 0 || soap_flag_Message > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__UnsupportedFeatureFault(struct soap *soap, struct bes__UnsupportedFeatureFaultType *a)
{	soap_default_bes__UnsupportedFeatureFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__UnsupportedFeatureFault(struct soap *soap, struct bes__UnsupportedFeatureFaultType const*a)
{	soap_serialize_bes__UnsupportedFeatureFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__UnsupportedFeatureFault(struct soap *soap, const struct bes__UnsupportedFeatureFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__UnsupportedFeatureFault);
	if (soap_out__bes__UnsupportedFeatureFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__UnsupportedFeatureFault(struct soap *soap, const char *tag, int id, const struct bes__UnsupportedFeatureFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__UnsupportedFeatureFault), type);
	if (a->Feature) {
		int i;
		for (i = 0; i < a->__sizeFeature; i++)
			soap_out_string(soap, "bes:Feature", -1, a->Feature + i, "");
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_get__bes__UnsupportedFeatureFault(struct soap *soap, struct bes__UnsupportedFeatureFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__UnsupportedFeatureFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_in__bes__UnsupportedFeatureFault(struct soap *soap, const char *tag, struct bes__UnsupportedFeatureFaultType *a, const char *type)
{
	short soap_flag_Feature = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__UnsupportedFeatureFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__UnsupportedFeatureFault, sizeof(struct bes__UnsupportedFeatureFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__UnsupportedFeatureFault(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Feature && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeFeature = 0; !soap_element_begin_in(soap, "bes:Feature", 1, NULL); a->__sizeFeature++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "bes:Feature", p, "xsd:string"))
						break;
					soap_flag_Feature = 0;
				}
				a->Feature = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Feature && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__UnsupportedFeatureFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__UnsupportedFeatureFault, 0, sizeof(struct bes__UnsupportedFeatureFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__NotAcceptingNewActivitiesFault(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *a)
{	soap_default_bes__NotAcceptingNewActivitiesFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__NotAcceptingNewActivitiesFault(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType const*a)
{	soap_serialize_bes__NotAcceptingNewActivitiesFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__NotAcceptingNewActivitiesFault(struct soap *soap, const struct bes__NotAcceptingNewActivitiesFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__NotAcceptingNewActivitiesFault);
	if (soap_out__bes__NotAcceptingNewActivitiesFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__NotAcceptingNewActivitiesFault(struct soap *soap, const char *tag, int id, const struct bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__NotAcceptingNewActivitiesFault), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_get__bes__NotAcceptingNewActivitiesFault(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__NotAcceptingNewActivitiesFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_in__bes__NotAcceptingNewActivitiesFault(struct soap *soap, const char *tag, struct bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__NotAcceptingNewActivitiesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__NotAcceptingNewActivitiesFault, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__NotAcceptingNewActivitiesFault(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__NotAcceptingNewActivitiesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__NotAcceptingNewActivitiesFault, 0, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__NotAuthorizedFault(struct soap *soap, struct bes__NotAuthorizedFaultType *a)
{	soap_default_bes__NotAuthorizedFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__NotAuthorizedFault(struct soap *soap, struct bes__NotAuthorizedFaultType const*a)
{	soap_serialize_bes__NotAuthorizedFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__NotAuthorizedFault(struct soap *soap, const struct bes__NotAuthorizedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__NotAuthorizedFault);
	if (soap_out__bes__NotAuthorizedFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__NotAuthorizedFault(struct soap *soap, const char *tag, int id, const struct bes__NotAuthorizedFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__NotAuthorizedFault), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType * SOAP_FMAC4 soap_get__bes__NotAuthorizedFault(struct soap *soap, struct bes__NotAuthorizedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__NotAuthorizedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType * SOAP_FMAC4 soap_in__bes__NotAuthorizedFault(struct soap *soap, const char *tag, struct bes__NotAuthorizedFaultType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__NotAuthorizedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__NotAuthorizedFault, sizeof(struct bes__NotAuthorizedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__NotAuthorizedFault(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__NotAuthorizedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__NotAuthorizedFault, 0, sizeof(struct bes__NotAuthorizedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *a)
{	soap_default_bes__GetFactoryAttributesDocumentResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType const*a)
{	soap_serialize_bes__GetFactoryAttributesDocumentResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, const struct bes__GetFactoryAttributesDocumentResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse);
	if (soap_out__bes__GetFactoryAttributesDocumentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, const char *tag, int id, const struct bes__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_get__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetFactoryAttributesDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_in__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetFactoryAttributesDocumentResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetFactoryAttributesDocumentResponse(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetFactoryAttributesDocumentResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse, 0, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__GetFactoryAttributesDocument(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *a)
{	soap_default_bes__GetFactoryAttributesDocumentType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__GetFactoryAttributesDocument(struct soap *soap, struct bes__GetFactoryAttributesDocumentType const*a)
{	soap_serialize_bes__GetFactoryAttributesDocumentType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__GetFactoryAttributesDocument(struct soap *soap, const struct bes__GetFactoryAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetFactoryAttributesDocument);
	if (soap_out__bes__GetFactoryAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__GetFactoryAttributesDocument(struct soap *soap, const char *tag, int id, const struct bes__GetFactoryAttributesDocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetFactoryAttributesDocument), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_get__bes__GetFactoryAttributesDocument(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetFactoryAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_in__bes__GetFactoryAttributesDocument(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetFactoryAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetFactoryAttributesDocument, sizeof(struct bes__GetFactoryAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetFactoryAttributesDocument(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetFactoryAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetFactoryAttributesDocument, 0, sizeof(struct bes__GetFactoryAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__GetActivityDocumentsResponse(struct soap *soap, struct bes__GetActivityDocumentsResponseType *a)
{	soap_default_bes__GetActivityDocumentsResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__GetActivityDocumentsResponse(struct soap *soap, struct bes__GetActivityDocumentsResponseType const*a)
{	soap_serialize_bes__GetActivityDocumentsResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__GetActivityDocumentsResponse(struct soap *soap, const struct bes__GetActivityDocumentsResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetActivityDocumentsResponse);
	if (soap_out__bes__GetActivityDocumentsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__GetActivityDocumentsResponse(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentsResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetActivityDocumentsResponse), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_get__bes__GetActivityDocumentsResponse(struct soap *soap, struct bes__GetActivityDocumentsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityDocumentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_in__bes__GetActivityDocumentsResponse(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentsResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetActivityDocumentsResponse, sizeof(struct bes__GetActivityDocumentsResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetActivityDocumentsResponse(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityDocumentsResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetActivityDocumentsResponse, 0, sizeof(struct bes__GetActivityDocumentsResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__GetActivityDocuments(struct soap *soap, struct bes__GetActivityDocumentsType *a)
{	soap_default_bes__GetActivityDocumentsType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__GetActivityDocuments(struct soap *soap, struct bes__GetActivityDocumentsType const*a)
{	soap_serialize_bes__GetActivityDocumentsType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__GetActivityDocuments(struct soap *soap, const struct bes__GetActivityDocumentsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetActivityDocuments);
	if (soap_out__bes__GetActivityDocuments(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__GetActivityDocuments(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetActivityDocuments), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsType * SOAP_FMAC4 soap_get__bes__GetActivityDocuments(struct soap *soap, struct bes__GetActivityDocumentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityDocuments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsType * SOAP_FMAC4 soap_in__bes__GetActivityDocuments(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetActivityDocuments, sizeof(struct bes__GetActivityDocumentsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetActivityDocuments(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityDocumentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetActivityDocuments, 0, sizeof(struct bes__GetActivityDocumentsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__TerminateActivitiesResponse(struct soap *soap, struct bes__TerminateActivitiesResponseType *a)
{	soap_default_bes__TerminateActivitiesResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__TerminateActivitiesResponse(struct soap *soap, struct bes__TerminateActivitiesResponseType const*a)
{	soap_serialize_bes__TerminateActivitiesResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__TerminateActivitiesResponse(struct soap *soap, const struct bes__TerminateActivitiesResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__TerminateActivitiesResponse);
	if (soap_out__bes__TerminateActivitiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__TerminateActivitiesResponse(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivitiesResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__TerminateActivitiesResponse), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType * SOAP_FMAC4 soap_get__bes__TerminateActivitiesResponse(struct soap *soap, struct bes__TerminateActivitiesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__TerminateActivitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType * SOAP_FMAC4 soap_in__bes__TerminateActivitiesResponse(struct soap *soap, const char *tag, struct bes__TerminateActivitiesResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivitiesResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__TerminateActivitiesResponse, sizeof(struct bes__TerminateActivitiesResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__TerminateActivitiesResponse(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__TerminateActivitiesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__TerminateActivitiesResponse, 0, sizeof(struct bes__TerminateActivitiesResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__TerminateActivities(struct soap *soap, struct bes__TerminateActivitiesType *a)
{	soap_default_bes__TerminateActivitiesType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__TerminateActivities(struct soap *soap, struct bes__TerminateActivitiesType const*a)
{	soap_serialize_bes__TerminateActivitiesType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__TerminateActivities(struct soap *soap, const struct bes__TerminateActivitiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__TerminateActivities);
	if (soap_out__bes__TerminateActivities(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__TerminateActivities(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivitiesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__TerminateActivities), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__TerminateActivitiesType * SOAP_FMAC4 soap_get__bes__TerminateActivities(struct soap *soap, struct bes__TerminateActivitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__TerminateActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesType * SOAP_FMAC4 soap_in__bes__TerminateActivities(struct soap *soap, const char *tag, struct bes__TerminateActivitiesType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivitiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__TerminateActivities, sizeof(struct bes__TerminateActivitiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__TerminateActivities(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__TerminateActivitiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__TerminateActivities, 0, sizeof(struct bes__TerminateActivitiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__GetActivityStatusesResponse(struct soap *soap, struct bes__GetActivityStatusesResponseType *a)
{	soap_default_bes__GetActivityStatusesResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__GetActivityStatusesResponse(struct soap *soap, struct bes__GetActivityStatusesResponseType const*a)
{	soap_serialize_bes__GetActivityStatusesResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__GetActivityStatusesResponse(struct soap *soap, const struct bes__GetActivityStatusesResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetActivityStatusesResponse);
	if (soap_out__bes__GetActivityStatusesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__GetActivityStatusesResponse(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusesResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetActivityStatusesResponse), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType * SOAP_FMAC4 soap_get__bes__GetActivityStatusesResponse(struct soap *soap, struct bes__GetActivityStatusesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityStatusesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType * SOAP_FMAC4 soap_in__bes__GetActivityStatusesResponse(struct soap *soap, const char *tag, struct bes__GetActivityStatusesResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusesResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetActivityStatusesResponse, sizeof(struct bes__GetActivityStatusesResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetActivityStatusesResponse(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityStatusesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetActivityStatusesResponse, 0, sizeof(struct bes__GetActivityStatusesResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__GetActivityStatuses(struct soap *soap, struct bes__GetActivityStatusesType *a)
{	soap_default_bes__GetActivityStatusesType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__GetActivityStatuses(struct soap *soap, struct bes__GetActivityStatusesType const*a)
{	soap_serialize_bes__GetActivityStatusesType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__GetActivityStatuses(struct soap *soap, const struct bes__GetActivityStatusesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetActivityStatuses);
	if (soap_out__bes__GetActivityStatuses(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__GetActivityStatuses(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetActivityStatuses), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityStatusesType * SOAP_FMAC4 soap_get__bes__GetActivityStatuses(struct soap *soap, struct bes__GetActivityStatusesType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityStatuses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesType * SOAP_FMAC4 soap_in__bes__GetActivityStatuses(struct soap *soap, const char *tag, struct bes__GetActivityStatusesType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetActivityStatuses, sizeof(struct bes__GetActivityStatusesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetActivityStatuses(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityStatusesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetActivityStatuses, 0, sizeof(struct bes__GetActivityStatusesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__CreateActivityResponse(struct soap *soap, struct bes__CreateActivityResponseType *a)
{	soap_default_bes__CreateActivityResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__CreateActivityResponse(struct soap *soap, struct bes__CreateActivityResponseType const*a)
{	soap_serialize_bes__CreateActivityResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__CreateActivityResponse(struct soap *soap, const struct bes__CreateActivityResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__CreateActivityResponse);
	if (soap_out__bes__CreateActivityResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__CreateActivityResponse(struct soap *soap, const char *tag, int id, const struct bes__CreateActivityResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__CreateActivityResponse), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__CreateActivityResponseType * SOAP_FMAC4 soap_get__bes__CreateActivityResponse(struct soap *soap, struct bes__CreateActivityResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__CreateActivityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityResponseType * SOAP_FMAC4 soap_in__bes__CreateActivityResponse(struct soap *soap, const char *tag, struct bes__CreateActivityResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CreateActivityResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__CreateActivityResponse, sizeof(struct bes__CreateActivityResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__CreateActivityResponse(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__CreateActivityResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__CreateActivityResponse, 0, sizeof(struct bes__CreateActivityResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__bes__CreateActivity(struct soap *soap, struct bes__CreateActivityType *a)
{	soap_default_bes__CreateActivityType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__bes__CreateActivity(struct soap *soap, struct bes__CreateActivityType const*a)
{	soap_serialize_bes__CreateActivityType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__bes__CreateActivity(struct soap *soap, const struct bes__CreateActivityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__CreateActivity);
	if (soap_out__bes__CreateActivity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__bes__CreateActivity(struct soap *soap, const char *tag, int id, const struct bes__CreateActivityType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__CreateActivity), type);
	soap_out_bes__ActivityDocumentType(soap, "bes:ActivityDocument", -1, &a->bes__ActivityDocument, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__CreateActivityType * SOAP_FMAC4 soap_get__bes__CreateActivity(struct soap *soap, struct bes__CreateActivityType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__CreateActivity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityType * SOAP_FMAC4 soap_in__bes__CreateActivity(struct soap *soap, const char *tag, struct bes__CreateActivityType *a, const char *type)
{
	short soap_flag_bes__ActivityDocument = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CreateActivityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__CreateActivity, sizeof(struct bes__CreateActivityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__CreateActivity(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__ActivityDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bes__ActivityDocumentType(soap, "bes:ActivityDocument", &a->bes__ActivityDocument, "bes:ActivityDocumentType")) {
					soap_flag_bes__ActivityDocument--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__CreateActivityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__CreateActivity, 0, sizeof(struct bes__CreateActivityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__ActivityDocument > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_hpcpa__HPCProfileApplication_USCOREType(struct soap *soap, struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl_hpcpa__Executable = NULL;
	a->__sizeArgument = 0;
	a->jsdl_hpcpa__Argument = NULL;
	a->jsdl_hpcpa__Input = NULL;
	a->jsdl_hpcpa__Output = NULL;
	a->jsdl_hpcpa__Error = NULL;
	a->jsdl_hpcpa__WorkingDirectory = NULL;
	a->__sizeEnvironment = 0;
	a->jsdl_hpcpa__Environment = NULL;
	a->jsdl_hpcpa__UserName = NULL;
	soap_default_xsd__NCName(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_hpcpa__HPCProfileApplication_USCOREType(struct soap *soap, const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl_hpcpa__FileName_USCOREType(soap, &a->jsdl_hpcpa__Executable);
	if (a->jsdl_hpcpa__Argument) {
		int i;
		for (i = 0; i < a->__sizeArgument; i++) {
			soap_embedded(soap, a->jsdl_hpcpa__Argument + i, SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType);
			soap_serialize_jsdl_hpcpa__Argument_USCOREType(soap, a->jsdl_hpcpa__Argument + i);
		}
	}
	soap_serialize_PointerTojsdl_hpcpa__FileName_USCOREType(soap, &a->jsdl_hpcpa__Input);
	soap_serialize_PointerTojsdl_hpcpa__FileName_USCOREType(soap, &a->jsdl_hpcpa__Output);
	soap_serialize_PointerTojsdl_hpcpa__FileName_USCOREType(soap, &a->jsdl_hpcpa__Error);
	soap_serialize_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, &a->jsdl_hpcpa__WorkingDirectory);
	if (a->jsdl_hpcpa__Environment) {
		int i;
		for (i = 0; i < a->__sizeEnvironment; i++) {
			soap_embedded(soap, a->jsdl_hpcpa__Environment + i, SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType);
			soap_serialize_jsdl_hpcpa__Environment_USCOREType(soap, a->jsdl_hpcpa__Environment + i);
		}
	}
	soap_serialize_PointerTojsdl_hpcpa__UserName_USCOREType(soap, &a->jsdl_hpcpa__UserName);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_hpcpa__HPCProfileApplication_USCOREType(struct soap *soap, const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_hpcpa__HPCProfileApplication_USCOREType);
	if (soap_out_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_hpcpa__HPCProfileApplication_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl_hpcpa__HPCProfileApplication_USCOREType), type);
	soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Executable", -1, &a->jsdl_hpcpa__Executable, "");
	if (a->jsdl_hpcpa__Argument) {
		int i;
		for (i = 0; i < a->__sizeArgument; i++)
			soap_out_jsdl_hpcpa__Argument_USCOREType(soap, "jsdl-hpcpa:Argument", -1, a->jsdl_hpcpa__Argument + i, "");
	}
	soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Input", -1, &a->jsdl_hpcpa__Input, "");
	soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Output", -1, &a->jsdl_hpcpa__Output, "");
	soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Error", -1, &a->jsdl_hpcpa__Error, "");
	soap_out_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, "jsdl-hpcpa:WorkingDirectory", -1, &a->jsdl_hpcpa__WorkingDirectory, "");
	if (a->jsdl_hpcpa__Environment) {
		int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
			soap_out_jsdl_hpcpa__Environment_USCOREType(soap, "jsdl-hpcpa:Environment", -1, a->jsdl_hpcpa__Environment + i, "");
	}
	soap_out_PointerTojsdl_hpcpa__UserName_USCOREType(soap, "jsdl-hpcpa:UserName", -1, &a->jsdl_hpcpa__UserName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl_hpcpa__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_get_jsdl_hpcpa__HPCProfileApplication_USCOREType(struct soap *soap, struct jsdl_hpcpa__HPCProfileApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_in_jsdl_hpcpa__HPCProfileApplication_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__HPCProfileApplication_USCOREType *a, const char *type)
{
	short soap_flag_jsdl_hpcpa__Executable = 1, soap_flag_jsdl_hpcpa__Argument = 1, soap_flag_jsdl_hpcpa__Input = 1, soap_flag_jsdl_hpcpa__Output = 1, soap_flag_jsdl_hpcpa__Error = 1, soap_flag_jsdl_hpcpa__WorkingDirectory = 1, soap_flag_jsdl_hpcpa__Environment = 1, soap_flag_jsdl_hpcpa__UserName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl_hpcpa__HPCProfileApplication_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_hpcpa__HPCProfileApplication_USCOREType, sizeof(struct jsdl_hpcpa__HPCProfileApplication_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl_hpcpa__HPCProfileApplication_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl_hpcpa__Executable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Executable", &a->jsdl_hpcpa__Executable, "jsdl-hpcpa:FileName_Type")) {
					soap_flag_jsdl_hpcpa__Executable--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__Argument && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl_hpcpa__Argument_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeArgument = 0; !soap_element_begin_in(soap, "jsdl-hpcpa:Argument", 1, NULL); a->__sizeArgument++) {
					p = (struct jsdl_hpcpa__Argument_USCOREType *)soap_push_block(soap, sizeof(struct jsdl_hpcpa__Argument_USCOREType));
					soap_default_jsdl_hpcpa__Argument_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl_hpcpa__Argument_USCOREType(soap, "jsdl-hpcpa:Argument", p, "jsdl-hpcpa:Argument_Type"))
						break;
					soap_flag_jsdl_hpcpa__Argument = 0;
				}
				a->jsdl_hpcpa__Argument = (struct jsdl_hpcpa__Argument_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl_hpcpa__Argument && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl_hpcpa__Input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Input", &a->jsdl_hpcpa__Input, "jsdl-hpcpa:FileName_Type")) {
					soap_flag_jsdl_hpcpa__Input--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__Output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Output", &a->jsdl_hpcpa__Output, "jsdl-hpcpa:FileName_Type")) {
					soap_flag_jsdl_hpcpa__Output--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, "jsdl-hpcpa:Error", &a->jsdl_hpcpa__Error, "jsdl-hpcpa:FileName_Type")) {
					soap_flag_jsdl_hpcpa__Error--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__WorkingDirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, "jsdl-hpcpa:WorkingDirectory", &a->jsdl_hpcpa__WorkingDirectory, "jsdl-hpcpa:DirectoryName_Type")) {
					soap_flag_jsdl_hpcpa__WorkingDirectory--;
					continue;
				}
			if (soap_flag_jsdl_hpcpa__Environment && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl_hpcpa__Environment_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeEnvironment = 0; !soap_element_begin_in(soap, "jsdl-hpcpa:Environment", 1, NULL); a->__sizeEnvironment++) {
					p = (struct jsdl_hpcpa__Environment_USCOREType *)soap_push_block(soap, sizeof(struct jsdl_hpcpa__Environment_USCOREType));
					soap_default_jsdl_hpcpa__Environment_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl_hpcpa__Environment_USCOREType(soap, "jsdl-hpcpa:Environment", p, "jsdl-hpcpa:Environment_Type"))
						break;
					soap_flag_jsdl_hpcpa__Environment = 0;
				}
				a->jsdl_hpcpa__Environment = (struct jsdl_hpcpa__Environment_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl_hpcpa__Environment && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl_hpcpa__UserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_hpcpa__UserName_USCOREType(soap, "jsdl-hpcpa:UserName", &a->jsdl_hpcpa__UserName, "jsdl-hpcpa:UserName_Type")) {
					soap_flag_jsdl_hpcpa__UserName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl_hpcpa__HPCProfileApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl_hpcpa__HPCProfileApplication_USCOREType, 0, sizeof(struct jsdl_hpcpa__HPCProfileApplication_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_hpcpa__UserName_USCOREType(struct soap *soap, struct jsdl_hpcpa__UserName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_hpcpa__UserName_USCOREType(struct soap *soap, const struct jsdl_hpcpa__UserName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_hpcpa__UserName_USCOREType(struct soap *soap, const struct jsdl_hpcpa__UserName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType);
	if (soap_out_jsdl_hpcpa__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_hpcpa__UserName_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__UserName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__UserName_USCOREType * SOAP_FMAC4 soap_get_jsdl_hpcpa__UserName_USCOREType(struct soap *soap, struct jsdl_hpcpa__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_hpcpa__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__UserName_USCOREType * SOAP_FMAC4 soap_in_jsdl_hpcpa__UserName_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__UserName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType, sizeof(struct jsdl_hpcpa__UserName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_hpcpa__UserName_USCOREType(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-hpcpa:UserName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, struct jsdl_hpcpa__DirectoryName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, const struct jsdl_hpcpa__DirectoryName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, const struct jsdl_hpcpa__DirectoryName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType);
	if (soap_out_jsdl_hpcpa__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__DirectoryName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__DirectoryName_USCOREType * SOAP_FMAC4 soap_get_jsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, struct jsdl_hpcpa__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_hpcpa__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__DirectoryName_USCOREType * SOAP_FMAC4 soap_in_jsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__DirectoryName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType, sizeof(struct jsdl_hpcpa__DirectoryName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_hpcpa__DirectoryName_USCOREType(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-hpcpa:DirectoryName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_hpcpa__FileName_USCOREType(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_hpcpa__FileName_USCOREType(struct soap *soap, const struct jsdl_hpcpa__FileName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_hpcpa__FileName_USCOREType(struct soap *soap, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType);
	if (soap_out_jsdl_hpcpa__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_hpcpa__FileName_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_get_jsdl_hpcpa__FileName_USCOREType(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_hpcpa__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType * SOAP_FMAC4 soap_in_jsdl_hpcpa__FileName_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType, sizeof(struct jsdl_hpcpa__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_hpcpa__FileName_USCOREType(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-hpcpa:FileName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_hpcpa__Argument_USCOREType(struct soap *soap, struct jsdl_hpcpa__Argument_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_hpcpa__Argument_USCOREType(struct soap *soap, const struct jsdl_hpcpa__Argument_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_hpcpa__Argument_USCOREType(struct soap *soap, const struct jsdl_hpcpa__Argument_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType);
	if (soap_out_jsdl_hpcpa__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_hpcpa__Argument_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__Argument_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__Argument_USCOREType * SOAP_FMAC4 soap_get_jsdl_hpcpa__Argument_USCOREType(struct soap *soap, struct jsdl_hpcpa__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_hpcpa__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__Argument_USCOREType * SOAP_FMAC4 soap_in_jsdl_hpcpa__Argument_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__Argument_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType, sizeof(struct jsdl_hpcpa__Argument_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_hpcpa__Argument_USCOREType(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-hpcpa:Argument_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_hpcpa__Environment_USCOREType(struct soap *soap, struct jsdl_hpcpa__Environment_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_hpcpa__Environment_USCOREType(struct soap *soap, const struct jsdl_hpcpa__Environment_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_hpcpa__Environment_USCOREType(struct soap *soap, const struct jsdl_hpcpa__Environment_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType);
	if (soap_out_jsdl_hpcpa__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_hpcpa__Environment_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_hpcpa__Environment_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_hpcpa__Environment_USCOREType * SOAP_FMAC4 soap_get_jsdl_hpcpa__Environment_USCOREType(struct soap *soap, struct jsdl_hpcpa__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_hpcpa__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__Environment_USCOREType * SOAP_FMAC4 soap_in_jsdl_hpcpa__Environment_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_hpcpa__Environment_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType, sizeof(struct jsdl_hpcpa__Environment_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_hpcpa__Environment_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-hpcpa:Environment_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_posix__POSIXApplication_USCOREType(struct soap *soap, struct jsdl_posix__POSIXApplication_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl_posix__Executable = NULL;
	a->__sizeArgument = 0;
	a->jsdl_posix__Argument = NULL;
	a->jsdl_posix__Input = NULL;
	a->jsdl_posix__Output = NULL;
	a->jsdl_posix__Error = NULL;
	a->jsdl_posix__WorkingDirectory = NULL;
	a->__sizeEnvironment = 0;
	a->jsdl_posix__Environment = NULL;
	a->jsdl_posix__WallTimeLimit = NULL;
	a->jsdl_posix__FileSizeLimit = NULL;
	a->jsdl_posix__CoreDumpLimit = NULL;
	a->jsdl_posix__DataSegmentLimit = NULL;
	a->jsdl_posix__LockedMemoryLimit = NULL;
	a->jsdl_posix__MemoryLimit = NULL;
	a->jsdl_posix__OpenDescriptorsLimit = NULL;
	a->jsdl_posix__PipeSizeLimit = NULL;
	a->jsdl_posix__StackSizeLimit = NULL;
	a->jsdl_posix__CPUTimeLimit = NULL;
	a->jsdl_posix__ProcessCountLimit = NULL;
	a->jsdl_posix__VirtualMemoryLimit = NULL;
	a->jsdl_posix__ThreadCountLimit = NULL;
	a->jsdl_posix__UserName = NULL;
	a->jsdl_posix__GroupName = NULL;
	soap_default_xsd__NCName(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_posix__POSIXApplication_USCOREType(struct soap *soap, const struct jsdl_posix__POSIXApplication_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl_posix__FileName_USCOREType(soap, &a->jsdl_posix__Executable);
	if (a->jsdl_posix__Argument) {
		int i;
		for (i = 0; i < a->__sizeArgument; i++) {
			soap_embedded(soap, a->jsdl_posix__Argument + i, SOAP_TYPE_jsdl_posix__Argument_USCOREType);
			soap_serialize_jsdl_posix__Argument_USCOREType(soap, a->jsdl_posix__Argument + i);
		}
	}
	soap_serialize_PointerTojsdl_posix__FileName_USCOREType(soap, &a->jsdl_posix__Input);
	soap_serialize_PointerTojsdl_posix__FileName_USCOREType(soap, &a->jsdl_posix__Output);
	soap_serialize_PointerTojsdl_posix__FileName_USCOREType(soap, &a->jsdl_posix__Error);
	soap_serialize_PointerTojsdl_posix__DirectoryName_USCOREType(soap, &a->jsdl_posix__WorkingDirectory);
	if (a->jsdl_posix__Environment) {
		int i;
		for (i = 0; i < a->__sizeEnvironment; i++) {
			soap_embedded(soap, a->jsdl_posix__Environment + i, SOAP_TYPE_jsdl_posix__Environment_USCOREType);
			soap_serialize_jsdl_posix__Environment_USCOREType(soap, a->jsdl_posix__Environment + i);
		}
	}
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__WallTimeLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__FileSizeLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__CoreDumpLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__DataSegmentLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__LockedMemoryLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__MemoryLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__OpenDescriptorsLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__PipeSizeLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__StackSizeLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__CPUTimeLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__ProcessCountLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__VirtualMemoryLimit);
	soap_serialize_PointerTojsdl_posix__Limits_USCOREType(soap, &a->jsdl_posix__ThreadCountLimit);
	soap_serialize_PointerTojsdl_posix__UserName_USCOREType(soap, &a->jsdl_posix__UserName);
	soap_serialize_PointerTojsdl_posix__GroupName_USCOREType(soap, &a->jsdl_posix__GroupName);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_posix__POSIXApplication_USCOREType(struct soap *soap, const struct jsdl_posix__POSIXApplication_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_posix__POSIXApplication_USCOREType);
	if (soap_out_jsdl_posix__POSIXApplication_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_posix__POSIXApplication_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_posix__POSIXApplication_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl_posix__POSIXApplication_USCOREType), type);
	soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Executable", -1, &a->jsdl_posix__Executable, "");
	if (a->jsdl_posix__Argument) {
		int i;
		for (i = 0; i < a->__sizeArgument; i++)
			soap_out_jsdl_posix__Argument_USCOREType(soap, "jsdl-posix:Argument", -1, a->jsdl_posix__Argument + i, "");
	}
	soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Input", -1, &a->jsdl_posix__Input, "");
	soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Output", -1, &a->jsdl_posix__Output, "");
	soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Error", -1, &a->jsdl_posix__Error, "");
	soap_out_PointerTojsdl_posix__DirectoryName_USCOREType(soap, "jsdl-posix:WorkingDirectory", -1, &a->jsdl_posix__WorkingDirectory, "");
	if (a->jsdl_posix__Environment) {
		int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
			soap_out_jsdl_posix__Environment_USCOREType(soap, "jsdl-posix:Environment", -1, a->jsdl_posix__Environment + i, "");
	}
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:WallTimeLimit", -1, &a->jsdl_posix__WallTimeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:FileSizeLimit", -1, &a->jsdl_posix__FileSizeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:CoreDumpLimit", -1, &a->jsdl_posix__CoreDumpLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:DataSegmentLimit", -1, &a->jsdl_posix__DataSegmentLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:LockedMemoryLimit", -1, &a->jsdl_posix__LockedMemoryLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:MemoryLimit", -1, &a->jsdl_posix__MemoryLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:OpenDescriptorsLimit", -1, &a->jsdl_posix__OpenDescriptorsLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:PipeSizeLimit", -1, &a->jsdl_posix__PipeSizeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:StackSizeLimit", -1, &a->jsdl_posix__StackSizeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:CPUTimeLimit", -1, &a->jsdl_posix__CPUTimeLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:ProcessCountLimit", -1, &a->jsdl_posix__ProcessCountLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:VirtualMemoryLimit", -1, &a->jsdl_posix__VirtualMemoryLimit, "");
	soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:ThreadCountLimit", -1, &a->jsdl_posix__ThreadCountLimit, "");
	soap_out_PointerTojsdl_posix__UserName_USCOREType(soap, "jsdl-posix:UserName", -1, &a->jsdl_posix__UserName, "");
	soap_out_PointerTojsdl_posix__GroupName_USCOREType(soap, "jsdl-posix:GroupName", -1, &a->jsdl_posix__GroupName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl_posix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_get_jsdl_posix__POSIXApplication_USCOREType(struct soap *soap, struct jsdl_posix__POSIXApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_posix__POSIXApplication_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_in_jsdl_posix__POSIXApplication_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__POSIXApplication_USCOREType *a, const char *type)
{
	short soap_flag_jsdl_posix__Executable = 1, soap_flag_jsdl_posix__Argument = 1, soap_flag_jsdl_posix__Input = 1, soap_flag_jsdl_posix__Output = 1, soap_flag_jsdl_posix__Error = 1, soap_flag_jsdl_posix__WorkingDirectory = 1, soap_flag_jsdl_posix__Environment = 1, soap_flag_jsdl_posix__WallTimeLimit = 1, soap_flag_jsdl_posix__FileSizeLimit = 1, soap_flag_jsdl_posix__CoreDumpLimit = 1, soap_flag_jsdl_posix__DataSegmentLimit = 1, soap_flag_jsdl_posix__LockedMemoryLimit = 1, soap_flag_jsdl_posix__MemoryLimit = 1, soap_flag_jsdl_posix__OpenDescriptorsLimit = 1, soap_flag_jsdl_posix__PipeSizeLimit = 1, soap_flag_jsdl_posix__StackSizeLimit = 1, soap_flag_jsdl_posix__CPUTimeLimit = 1, soap_flag_jsdl_posix__ProcessCountLimit = 1, soap_flag_jsdl_posix__VirtualMemoryLimit = 1, soap_flag_jsdl_posix__ThreadCountLimit = 1, soap_flag_jsdl_posix__UserName = 1, soap_flag_jsdl_posix__GroupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl_posix__POSIXApplication_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_posix__POSIXApplication_USCOREType, sizeof(struct jsdl_posix__POSIXApplication_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl_posix__POSIXApplication_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl_posix__Executable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Executable", &a->jsdl_posix__Executable, "jsdl-posix:FileName_Type")) {
					soap_flag_jsdl_posix__Executable--;
					continue;
				}
			if (soap_flag_jsdl_posix__Argument && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl_posix__Argument_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeArgument = 0; !soap_element_begin_in(soap, "jsdl-posix:Argument", 1, NULL); a->__sizeArgument++) {
					p = (struct jsdl_posix__Argument_USCOREType *)soap_push_block(soap, sizeof(struct jsdl_posix__Argument_USCOREType));
					soap_default_jsdl_posix__Argument_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl_posix__Argument_USCOREType(soap, "jsdl-posix:Argument", p, "jsdl-posix:Argument_Type"))
						break;
					soap_flag_jsdl_posix__Argument = 0;
				}
				a->jsdl_posix__Argument = (struct jsdl_posix__Argument_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl_posix__Argument && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl_posix__Input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Input", &a->jsdl_posix__Input, "jsdl-posix:FileName_Type")) {
					soap_flag_jsdl_posix__Input--;
					continue;
				}
			if (soap_flag_jsdl_posix__Output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Output", &a->jsdl_posix__Output, "jsdl-posix:FileName_Type")) {
					soap_flag_jsdl_posix__Output--;
					continue;
				}
			if (soap_flag_jsdl_posix__Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, "jsdl-posix:Error", &a->jsdl_posix__Error, "jsdl-posix:FileName_Type")) {
					soap_flag_jsdl_posix__Error--;
					continue;
				}
			if (soap_flag_jsdl_posix__WorkingDirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__DirectoryName_USCOREType(soap, "jsdl-posix:WorkingDirectory", &a->jsdl_posix__WorkingDirectory, "jsdl-posix:DirectoryName_Type")) {
					soap_flag_jsdl_posix__WorkingDirectory--;
					continue;
				}
			if (soap_flag_jsdl_posix__Environment && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl_posix__Environment_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeEnvironment = 0; !soap_element_begin_in(soap, "jsdl-posix:Environment", 1, NULL); a->__sizeEnvironment++) {
					p = (struct jsdl_posix__Environment_USCOREType *)soap_push_block(soap, sizeof(struct jsdl_posix__Environment_USCOREType));
					soap_default_jsdl_posix__Environment_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl_posix__Environment_USCOREType(soap, "jsdl-posix:Environment", p, "jsdl-posix:Environment_Type"))
						break;
					soap_flag_jsdl_posix__Environment = 0;
				}
				a->jsdl_posix__Environment = (struct jsdl_posix__Environment_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl_posix__Environment && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl_posix__WallTimeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:WallTimeLimit", &a->jsdl_posix__WallTimeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__WallTimeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__FileSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:FileSizeLimit", &a->jsdl_posix__FileSizeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__FileSizeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__CoreDumpLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:CoreDumpLimit", &a->jsdl_posix__CoreDumpLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__CoreDumpLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__DataSegmentLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:DataSegmentLimit", &a->jsdl_posix__DataSegmentLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__DataSegmentLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__LockedMemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:LockedMemoryLimit", &a->jsdl_posix__LockedMemoryLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__LockedMemoryLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__MemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:MemoryLimit", &a->jsdl_posix__MemoryLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__MemoryLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__OpenDescriptorsLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:OpenDescriptorsLimit", &a->jsdl_posix__OpenDescriptorsLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__OpenDescriptorsLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__PipeSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:PipeSizeLimit", &a->jsdl_posix__PipeSizeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__PipeSizeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__StackSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:StackSizeLimit", &a->jsdl_posix__StackSizeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__StackSizeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__CPUTimeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:CPUTimeLimit", &a->jsdl_posix__CPUTimeLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__CPUTimeLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__ProcessCountLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:ProcessCountLimit", &a->jsdl_posix__ProcessCountLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__ProcessCountLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__VirtualMemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:VirtualMemoryLimit", &a->jsdl_posix__VirtualMemoryLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__VirtualMemoryLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__ThreadCountLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, "jsdl-posix:ThreadCountLimit", &a->jsdl_posix__ThreadCountLimit, "jsdl-posix:Limits_Type")) {
					soap_flag_jsdl_posix__ThreadCountLimit--;
					continue;
				}
			if (soap_flag_jsdl_posix__UserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__UserName_USCOREType(soap, "jsdl-posix:UserName", &a->jsdl_posix__UserName, "jsdl-posix:UserName_Type")) {
					soap_flag_jsdl_posix__UserName--;
					continue;
				}
			if (soap_flag_jsdl_posix__GroupName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl_posix__GroupName_USCOREType(soap, "jsdl-posix:GroupName", &a->jsdl_posix__GroupName, "jsdl-posix:GroupName_Type")) {
					soap_flag_jsdl_posix__GroupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__POSIXApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl_posix__POSIXApplication_USCOREType, 0, sizeof(struct jsdl_posix__POSIXApplication_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_posix__GroupName_USCOREType(struct soap *soap, struct jsdl_posix__GroupName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_posix__GroupName_USCOREType(struct soap *soap, const struct jsdl_posix__GroupName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_posix__GroupName_USCOREType(struct soap *soap, const struct jsdl_posix__GroupName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_posix__GroupName_USCOREType);
	if (soap_out_jsdl_posix__GroupName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_posix__GroupName_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_posix__GroupName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__GroupName_USCOREType * SOAP_FMAC4 soap_get_jsdl_posix__GroupName_USCOREType(struct soap *soap, struct jsdl_posix__GroupName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_posix__GroupName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__GroupName_USCOREType * SOAP_FMAC4 soap_in_jsdl_posix__GroupName_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__GroupName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__GroupName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_posix__GroupName_USCOREType, sizeof(struct jsdl_posix__GroupName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_posix__GroupName_USCOREType(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-posix:GroupName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_posix__UserName_USCOREType(struct soap *soap, struct jsdl_posix__UserName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_posix__UserName_USCOREType(struct soap *soap, const struct jsdl_posix__UserName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_posix__UserName_USCOREType(struct soap *soap, const struct jsdl_posix__UserName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_posix__UserName_USCOREType);
	if (soap_out_jsdl_posix__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_posix__UserName_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_posix__UserName_USCOREType *a, const char *type)
{
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__UserName_USCOREType * SOAP_FMAC4 soap_get_jsdl_posix__UserName_USCOREType(struct soap *soap, struct jsdl_posix__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_posix__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__UserName_USCOREType * SOAP_FMAC4 soap_in_jsdl_posix__UserName_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__UserName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_posix__UserName_USCOREType, sizeof(struct jsdl_posix__UserName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_posix__UserName_USCOREType(soap, a);
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-posix:UserName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_posix__Limits_USCOREType(struct soap *soap, struct jsdl_posix__Limits_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_posix__Limits_USCOREType(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_posix__Limits_USCOREType(struct soap *soap, const struct jsdl_posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_posix__Limits_USCOREType);
	if (soap_out_jsdl_posix__Limits_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_posix__Limits_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_get_jsdl_posix__Limits_USCOREType(struct soap *soap, struct jsdl_posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_posix__Limits_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType * SOAP_FMAC4 soap_in_jsdl_posix__Limits_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_posix__Limits_USCOREType, sizeof(struct jsdl_posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_posix__Limits_USCOREType(soap, a);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, "jsdl-posix:Limits_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_posix__DirectoryName_USCOREType(struct soap *soap, struct jsdl_posix__DirectoryName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->filesystemName);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_posix__DirectoryName_USCOREType(struct soap *soap, const struct jsdl_posix__DirectoryName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_posix__DirectoryName_USCOREType(struct soap *soap, const struct jsdl_posix__DirectoryName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType);
	if (soap_out_jsdl_posix__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_posix__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_posix__DirectoryName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__DirectoryName_USCOREType * SOAP_FMAC4 soap_get_jsdl_posix__DirectoryName_USCOREType(struct soap *soap, struct jsdl_posix__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_posix__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__DirectoryName_USCOREType * SOAP_FMAC4 soap_in_jsdl_posix__DirectoryName_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__DirectoryName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType, sizeof(struct jsdl_posix__DirectoryName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_posix__DirectoryName_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-posix:DirectoryName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_posix__FileName_USCOREType(struct soap *soap, struct jsdl_posix__FileName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->filesystemName);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_posix__FileName_USCOREType(struct soap *soap, const struct jsdl_posix__FileName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_posix__FileName_USCOREType(struct soap *soap, const struct jsdl_posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_posix__FileName_USCOREType);
	if (soap_out_jsdl_posix__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_posix__FileName_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_get_jsdl_posix__FileName_USCOREType(struct soap *soap, struct jsdl_posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_posix__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType * SOAP_FMAC4 soap_in_jsdl_posix__FileName_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_posix__FileName_USCOREType, sizeof(struct jsdl_posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_posix__FileName_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-posix:FileName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_posix__Argument_USCOREType(struct soap *soap, struct jsdl_posix__Argument_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__normalizedString(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->filesystemName);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_posix__Argument_USCOREType(struct soap *soap, const struct jsdl_posix__Argument_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__normalizedString(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_posix__Argument_USCOREType(struct soap *soap, const struct jsdl_posix__Argument_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_posix__Argument_USCOREType);
	if (soap_out_jsdl_posix__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_posix__Argument_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Argument_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_xsd__normalizedString(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Argument_USCOREType * SOAP_FMAC4 soap_get_jsdl_posix__Argument_USCOREType(struct soap *soap, struct jsdl_posix__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_posix__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Argument_USCOREType * SOAP_FMAC4 soap_in_jsdl_posix__Argument_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Argument_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_posix__Argument_USCOREType, sizeof(struct jsdl_posix__Argument_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_posix__Argument_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_xsd__normalizedString(soap, tag, &a->__item, "jsdl-posix:Argument_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl_posix__Environment_USCOREType(struct soap *soap, struct jsdl_posix__Environment_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__NCName(soap, &a->filesystemName);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl_posix__Environment_USCOREType(struct soap *soap, const struct jsdl_posix__Environment_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl_posix__Environment_USCOREType(struct soap *soap, const struct jsdl_posix__Environment_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl_posix__Environment_USCOREType);
	if (soap_out_jsdl_posix__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl_posix__Environment_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl_posix__Environment_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl_posix__Environment_USCOREType * SOAP_FMAC4 soap_get_jsdl_posix__Environment_USCOREType(struct soap *soap, struct jsdl_posix__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl_posix__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Environment_USCOREType * SOAP_FMAC4 soap_in_jsdl_posix__Environment_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl_posix__Environment_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl_posix__Environment_USCOREType, sizeof(struct jsdl_posix__Environment_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl_posix__Environment_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "jsdl-posix:Environment_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_hpcp_af__DynamicNodeStatusType(struct soap *soap, struct hpcp_af__DynamicNodeStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNodeStatus = 0;
	a->NodeStatus = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_hpcp_af__DynamicNodeStatusType(struct soap *soap, const struct hpcp_af__DynamicNodeStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NodeStatus) {
		int i;
		for (i = 0; i < a->__sizeNodeStatus; i++) {
			soap_embedded(soap, a->NodeStatus + i, SOAP_TYPE_hpcp_af__NodeStatusType);
			soap_serialize_hpcp_af__NodeStatusType(soap, a->NodeStatus + i);
		}
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_hpcp_af__DynamicNodeStatusType(struct soap *soap, const struct hpcp_af__DynamicNodeStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hpcp_af__DynamicNodeStatusType);
	if (soap_out_hpcp_af__DynamicNodeStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_hpcp_af__DynamicNodeStatusType(struct soap *soap, const char *tag, int id, const struct hpcp_af__DynamicNodeStatusType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hpcp_af__DynamicNodeStatusType), type);
	if (a->NodeStatus) {
		int i;
		for (i = 0; i < a->__sizeNodeStatus; i++)
			soap_out_hpcp_af__NodeStatusType(soap, "hpcp_af:NodeStatus", -1, a->NodeStatus + i, "");
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__DynamicNodeStatusType * SOAP_FMAC4 soap_get_hpcp_af__DynamicNodeStatusType(struct soap *soap, struct hpcp_af__DynamicNodeStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_hpcp_af__DynamicNodeStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__DynamicNodeStatusType * SOAP_FMAC4 soap_in_hpcp_af__DynamicNodeStatusType(struct soap *soap, const char *tag, struct hpcp_af__DynamicNodeStatusType *a, const char *type)
{
	short soap_flag_NodeStatus = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__DynamicNodeStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hpcp_af__DynamicNodeStatusType, sizeof(struct hpcp_af__DynamicNodeStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hpcp_af__DynamicNodeStatusType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NodeStatus && soap->error == SOAP_TAG_MISMATCH) {
				struct hpcp_af__NodeStatusType *p;
				soap_new_block(soap);
				for (a->__sizeNodeStatus = 0; !soap_element_begin_in(soap, "hpcp_af:NodeStatus", 1, NULL); a->__sizeNodeStatus++) {
					p = (struct hpcp_af__NodeStatusType *)soap_push_block(soap, sizeof(struct hpcp_af__NodeStatusType));
					soap_default_hpcp_af__NodeStatusType(soap, p);
					soap_revert(soap);
					if (!soap_in_hpcp_af__NodeStatusType(soap, "hpcp_af:NodeStatus", p, "hpcp-af:NodeStatusType"))
						break;
					soap_flag_NodeStatus = 0;
				}
				a->NodeStatus = (struct hpcp_af__NodeStatusType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_NodeStatus && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__DynamicNodeStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hpcp_af__DynamicNodeStatusType, 0, sizeof(struct hpcp_af__DynamicNodeStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_hpcp_af__ActivityIdType(struct soap *soap, struct hpcp_af__ActivityIdType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_hpcp_af__ActivityIdType(struct soap *soap, const struct hpcp_af__ActivityIdType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_hpcp_af__ActivityIdType(struct soap *soap, const struct hpcp_af__ActivityIdType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hpcp_af__ActivityIdType);
	if (soap_out_hpcp_af__ActivityIdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_hpcp_af__ActivityIdType(struct soap *soap, const char *tag, int id, const struct hpcp_af__ActivityIdType *a, const char *type)
{
	soap_set_attr(soap, "id", soap_LONG642s(soap, a->id));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hpcp_af__ActivityIdType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__ActivityIdType * SOAP_FMAC4 soap_get_hpcp_af__ActivityIdType(struct soap *soap, struct hpcp_af__ActivityIdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_hpcp_af__ActivityIdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__ActivityIdType * SOAP_FMAC4 soap_in_hpcp_af__ActivityIdType(struct soap *soap, const char *tag, struct hpcp_af__ActivityIdType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__ActivityIdType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hpcp_af__ActivityIdType, sizeof(struct hpcp_af__ActivityIdType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hpcp_af__ActivityIdType(soap, a);
	if (soap_s2LONG64(soap, soap_attr_value(soap, "id", 1), &a->id))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__ActivityIdType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hpcp_af__ActivityIdType, 0, sizeof(struct hpcp_af__ActivityIdType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_hpcp_af__CPUType(struct soap *soap, struct hpcp_af__CPUType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->used);
	soap_default_LONG64(soap, &a->free);
	soap_default_LONG64(soap, &a->load);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_hpcp_af__CPUType(struct soap *soap, const struct hpcp_af__CPUType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_hpcp_af__CPUType(struct soap *soap, const struct hpcp_af__CPUType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hpcp_af__CPUType);
	if (soap_out_hpcp_af__CPUType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_hpcp_af__CPUType(struct soap *soap, const char *tag, int id, const struct hpcp_af__CPUType *a, const char *type)
{
	soap_set_attr(soap, "used", soap_LONG642s(soap, a->used));
	soap_set_attr(soap, "free", soap_LONG642s(soap, a->free));
	soap_set_attr(soap, "load", soap_LONG642s(soap, a->load));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hpcp_af__CPUType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__CPUType * SOAP_FMAC4 soap_get_hpcp_af__CPUType(struct soap *soap, struct hpcp_af__CPUType *p, const char *tag, const char *type)
{
	if ((p = soap_in_hpcp_af__CPUType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__CPUType * SOAP_FMAC4 soap_in_hpcp_af__CPUType(struct soap *soap, const char *tag, struct hpcp_af__CPUType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__CPUType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hpcp_af__CPUType, sizeof(struct hpcp_af__CPUType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hpcp_af__CPUType(soap, a);
	if (soap_s2LONG64(soap, soap_attr_value(soap, "used", 1), &a->used))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "free", 1), &a->free))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "load", 1), &a->load))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__CPUType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hpcp_af__CPUType, 0, sizeof(struct hpcp_af__CPUType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_hpcp_af__MemoryType(struct soap *soap, struct hpcp_af__MemoryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->used);
	soap_default_LONG64(soap, &a->free);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_hpcp_af__MemoryType(struct soap *soap, const struct hpcp_af__MemoryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_hpcp_af__MemoryType(struct soap *soap, const struct hpcp_af__MemoryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hpcp_af__MemoryType);
	if (soap_out_hpcp_af__MemoryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_hpcp_af__MemoryType(struct soap *soap, const char *tag, int id, const struct hpcp_af__MemoryType *a, const char *type)
{
	soap_set_attr(soap, "used", soap_LONG642s(soap, a->used));
	soap_set_attr(soap, "free", soap_LONG642s(soap, a->free));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hpcp_af__MemoryType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__MemoryType * SOAP_FMAC4 soap_get_hpcp_af__MemoryType(struct soap *soap, struct hpcp_af__MemoryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_hpcp_af__MemoryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__MemoryType * SOAP_FMAC4 soap_in_hpcp_af__MemoryType(struct soap *soap, const char *tag, struct hpcp_af__MemoryType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__MemoryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hpcp_af__MemoryType, sizeof(struct hpcp_af__MemoryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hpcp_af__MemoryType(soap, a);
	if (soap_s2LONG64(soap, soap_attr_value(soap, "used", 1), &a->used))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "free", 1), &a->free))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__MemoryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hpcp_af__MemoryType, 0, sizeof(struct hpcp_af__MemoryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_hpcp_af__NodeStatusType(struct soap *soap, struct hpcp_af__NodeStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Memory = NULL;
	a->CPU = NULL;
	a->__sizeJob = 0;
	a->Job = NULL;
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_hpcp_af__NodeStatusType(struct soap *soap, const struct hpcp_af__NodeStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTohpcp_af__MemoryType(soap, &a->Memory);
	soap_serialize_PointerTohpcp_af__CPUType(soap, &a->CPU);
	if (a->Job) {
		int i;
		for (i = 0; i < a->__sizeJob; i++) {
			soap_embedded(soap, a->Job + i, SOAP_TYPE_hpcp_af__ActivityIdType);
			soap_serialize_hpcp_af__ActivityIdType(soap, a->Job + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_hpcp_af__NodeStatusType(struct soap *soap, const struct hpcp_af__NodeStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hpcp_af__NodeStatusType);
	if (soap_out_hpcp_af__NodeStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_hpcp_af__NodeStatusType(struct soap *soap, const char *tag, int id, const struct hpcp_af__NodeStatusType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hpcp_af__NodeStatusType), type);
	soap_out_PointerTohpcp_af__MemoryType(soap, "hpcp_af:Memory", -1, &a->Memory, "");
	soap_out_PointerTohpcp_af__CPUType(soap, "hpcp_af:CPU", -1, &a->CPU, "");
	if (a->Job) {
		int i;
		for (i = 0; i < a->__sizeJob; i++)
			soap_out_hpcp_af__ActivityIdType(soap, "hpcp_af:Job", -1, a->Job + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__NodeStatusType * SOAP_FMAC4 soap_get_hpcp_af__NodeStatusType(struct soap *soap, struct hpcp_af__NodeStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_hpcp_af__NodeStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__NodeStatusType * SOAP_FMAC4 soap_in_hpcp_af__NodeStatusType(struct soap *soap, const char *tag, struct hpcp_af__NodeStatusType *a, const char *type)
{
	short soap_flag_Memory = 1, soap_flag_CPU = 1, soap_flag_Job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__NodeStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hpcp_af__NodeStatusType, sizeof(struct hpcp_af__NodeStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hpcp_af__NodeStatusType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Memory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTohpcp_af__MemoryType(soap, "hpcp_af:Memory", &a->Memory, "hpcp-af:MemoryType")) {
					soap_flag_Memory--;
					continue;
				}
			if (soap_flag_CPU && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTohpcp_af__CPUType(soap, "hpcp_af:CPU", &a->CPU, "hpcp-af:CPUType")) {
					soap_flag_CPU--;
					continue;
				}
			if (soap_flag_Job && soap->error == SOAP_TAG_MISMATCH) {
				struct hpcp_af__ActivityIdType *p;
				soap_new_block(soap);
				for (a->__sizeJob = 0; !soap_element_begin_in(soap, "hpcp_af:Job", 1, NULL); a->__sizeJob++) {
					p = (struct hpcp_af__ActivityIdType *)soap_push_block(soap, sizeof(struct hpcp_af__ActivityIdType));
					soap_default_hpcp_af__ActivityIdType(soap, p);
					soap_revert(soap);
					if (!soap_in_hpcp_af__ActivityIdType(soap, "hpcp_af:Job", p, "hpcp-af:ActivityIdType"))
						break;
					soap_flag_Job = 0;
				}
				a->Job = (struct hpcp_af__ActivityIdType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Job && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__NodeStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hpcp_af__NodeStatusType, 0, sizeof(struct hpcp_af__NodeStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Memory > 0 || soap_flag_CPU > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_hpcp_af__ActivityIdRangeType(struct soap *soap, struct hpcp_af__ActivityIdRangeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->start);
	soap_default_LONG64(soap, &a->end);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_hpcp_af__ActivityIdRangeType(struct soap *soap, const struct hpcp_af__ActivityIdRangeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_hpcp_af__ActivityIdRangeType(struct soap *soap, const struct hpcp_af__ActivityIdRangeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hpcp_af__ActivityIdRangeType);
	if (soap_out_hpcp_af__ActivityIdRangeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_hpcp_af__ActivityIdRangeType(struct soap *soap, const char *tag, int id, const struct hpcp_af__ActivityIdRangeType *a, const char *type)
{
	soap_set_attr(soap, "start", soap_LONG642s(soap, a->start));
	soap_set_attr(soap, "end", soap_LONG642s(soap, a->end));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hpcp_af__ActivityIdRangeType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__ActivityIdRangeType * SOAP_FMAC4 soap_get_hpcp_af__ActivityIdRangeType(struct soap *soap, struct hpcp_af__ActivityIdRangeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_hpcp_af__ActivityIdRangeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__ActivityIdRangeType * SOAP_FMAC4 soap_in_hpcp_af__ActivityIdRangeType(struct soap *soap, const char *tag, struct hpcp_af__ActivityIdRangeType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__ActivityIdRangeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hpcp_af__ActivityIdRangeType, sizeof(struct hpcp_af__ActivityIdRangeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hpcp_af__ActivityIdRangeType(soap, a);
	if (soap_s2LONG64(soap, soap_attr_value(soap, "start", 1), &a->start))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "end", 1), &a->end))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__ActivityIdRangeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hpcp_af__ActivityIdRangeType, 0, sizeof(struct hpcp_af__ActivityIdRangeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_hpcp_af__DateTimeRangeType(struct soap *soap, struct hpcp_af__DateTimeRangeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->from);
	soap_default_time(soap, &a->until);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_hpcp_af__DateTimeRangeType(struct soap *soap, const struct hpcp_af__DateTimeRangeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_hpcp_af__DateTimeRangeType(struct soap *soap, const struct hpcp_af__DateTimeRangeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hpcp_af__DateTimeRangeType);
	if (soap_out_hpcp_af__DateTimeRangeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_hpcp_af__DateTimeRangeType(struct soap *soap, const char *tag, int id, const struct hpcp_af__DateTimeRangeType *a, const char *type)
{
	soap_set_attr(soap, "from", soap_dateTime2s(soap, a->from));
	soap_set_attr(soap, "until", soap_dateTime2s(soap, a->until));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hpcp_af__DateTimeRangeType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__DateTimeRangeType * SOAP_FMAC4 soap_get_hpcp_af__DateTimeRangeType(struct soap *soap, struct hpcp_af__DateTimeRangeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_hpcp_af__DateTimeRangeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__DateTimeRangeType * SOAP_FMAC4 soap_in_hpcp_af__DateTimeRangeType(struct soap *soap, const char *tag, struct hpcp_af__DateTimeRangeType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__DateTimeRangeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hpcp_af__DateTimeRangeType, sizeof(struct hpcp_af__DateTimeRangeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hpcp_af__DateTimeRangeType(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "from", 1), &a->from))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "until", 1), &a->until))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__DateTimeRangeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hpcp_af__DateTimeRangeType, 0, sizeof(struct hpcp_af__DateTimeRangeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_hpcp_af__AdvancedFilterType(struct soap *soap, struct hpcp_af__AdvancedFilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUserName = 0;
	a->UserName = NULL;
	a->__sizeOwner = 0;
	a->Owner = NULL;
	a->__sizeState = 0;
	a->State = NULL;
	a->__sizeActivityIdRange = 0;
	a->ActivityIdRange = NULL;
	a->__sizeActivityId = 0;
	a->ActivityId = NULL;
	a->__sizeDateTimeRange = 0;
	a->DateTimeRange = NULL;
	soap_default_string(soap, &a->CompactResources);
	soap_default_string(soap, &a->UsageRecordFormat);
	soap_default_string(soap, &a->NodeStatus);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_hpcp_af__AdvancedFilterType(struct soap *soap, const struct hpcp_af__AdvancedFilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->UserName) {
		int i;
		for (i = 0; i < a->__sizeUserName; i++) {
			soap_serialize_string(soap, a->UserName + i);
		}
	}
	if (a->Owner) {
		int i;
		for (i = 0; i < a->__sizeOwner; i++) {
			soap_serialize_string(soap, a->Owner + i);
		}
	}
	if (a->State) {
		int i;
		for (i = 0; i < a->__sizeState; i++) {
			soap_embedded(soap, a->State + i, SOAP_TYPE_bes__ActivityStateEnumeration);
		}
	}
	if (a->ActivityIdRange) {
		int i;
		for (i = 0; i < a->__sizeActivityIdRange; i++) {
			soap_embedded(soap, a->ActivityIdRange + i, SOAP_TYPE_hpcp_af__ActivityIdRangeType);
			soap_serialize_hpcp_af__ActivityIdRangeType(soap, a->ActivityIdRange + i);
		}
	}
	if (a->ActivityId) {
		int i;
		for (i = 0; i < a->__sizeActivityId; i++) {
			soap_serialize_string(soap, a->ActivityId + i);
		}
	}
	if (a->DateTimeRange) {
		int i;
		for (i = 0; i < a->__sizeDateTimeRange; i++) {
			soap_embedded(soap, a->DateTimeRange + i, SOAP_TYPE_hpcp_af__DateTimeRangeType);
			soap_serialize_hpcp_af__DateTimeRangeType(soap, a->DateTimeRange + i);
		}
	}
	soap_serialize_string(soap, &a->CompactResources);
	soap_serialize_string(soap, &a->UsageRecordFormat);
	soap_serialize_string(soap, &a->NodeStatus);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_hpcp_af__AdvancedFilterType(struct soap *soap, const struct hpcp_af__AdvancedFilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hpcp_af__AdvancedFilterType);
	if (soap_out_hpcp_af__AdvancedFilterType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_hpcp_af__AdvancedFilterType(struct soap *soap, const char *tag, int id, const struct hpcp_af__AdvancedFilterType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hpcp_af__AdvancedFilterType), type);
	if (a->UserName) {
		int i;
		for (i = 0; i < a->__sizeUserName; i++)
			soap_out_string(soap, "hpcp_af:UserName", -1, a->UserName + i, "");
	}
	if (a->Owner) {
		int i;
		for (i = 0; i < a->__sizeOwner; i++)
			soap_out_string(soap, "hpcp_af:Owner", -1, a->Owner + i, "");
	}
	if (a->State) {
		int i;
		for (i = 0; i < a->__sizeState; i++)
			soap_out_bes__ActivityStateEnumeration(soap, "hpcp_af:State", -1, a->State + i, "");
	}
	if (a->ActivityIdRange) {
		int i;
		for (i = 0; i < a->__sizeActivityIdRange; i++)
			soap_out_hpcp_af__ActivityIdRangeType(soap, "hpcp_af:ActivityIdRange", -1, a->ActivityIdRange + i, "");
	}
	if (a->ActivityId) {
		int i;
		for (i = 0; i < a->__sizeActivityId; i++)
			soap_out_string(soap, "hpcp_af:ActivityId", -1, a->ActivityId + i, "");
	}
	if (a->DateTimeRange) {
		int i;
		for (i = 0; i < a->__sizeDateTimeRange; i++)
			soap_out_hpcp_af__DateTimeRangeType(soap, "hpcp_af:DateTimeRange", -1, a->DateTimeRange + i, "");
	}
	soap_out_string(soap, "hpcp_af:CompactResources", -1, &a->CompactResources, "");
	soap_out_string(soap, "hpcp_af:UsageRecordFormat", -1, &a->UsageRecordFormat, "");
	soap_out_string(soap, "hpcp_af:NodeStatus", -1, &a->NodeStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct hpcp_af__AdvancedFilterType * SOAP_FMAC4 soap_get_hpcp_af__AdvancedFilterType(struct soap *soap, struct hpcp_af__AdvancedFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_hpcp_af__AdvancedFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__AdvancedFilterType * SOAP_FMAC4 soap_in_hpcp_af__AdvancedFilterType(struct soap *soap, const char *tag, struct hpcp_af__AdvancedFilterType *a, const char *type)
{
	short soap_flag_UserName = 1, soap_flag_Owner = 1, soap_flag_State = 1, soap_flag_ActivityIdRange = 1, soap_flag_ActivityId = 1, soap_flag_DateTimeRange = 1, soap_flag_CompactResources = 1, soap_flag_UsageRecordFormat = 1, soap_flag_NodeStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hpcp_af__AdvancedFilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hpcp_af__AdvancedFilterType, sizeof(struct hpcp_af__AdvancedFilterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hpcp_af__AdvancedFilterType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeUserName = 0; !soap_element_begin_in(soap, "hpcp_af:UserName", 1, NULL); a->__sizeUserName++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "hpcp_af:UserName", p, "xsd:string"))
						break;
					soap_flag_UserName = 0;
				}
				a->UserName = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_UserName && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Owner && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeOwner = 0; !soap_element_begin_in(soap, "hpcp_af:Owner", 1, NULL); a->__sizeOwner++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "hpcp_af:Owner", p, "xsd:string"))
						break;
					soap_flag_Owner = 0;
				}
				a->Owner = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Owner && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH) {
				enum bes__ActivityStateEnumeration *p;
				soap_new_block(soap);
				for (a->__sizeState = 0; !soap_element_begin_in(soap, "hpcp_af:State", 1, NULL); a->__sizeState++) {
					p = (enum bes__ActivityStateEnumeration *)soap_push_block(soap, sizeof(enum bes__ActivityStateEnumeration));
					soap_default_bes__ActivityStateEnumeration(soap, p);
					soap_revert(soap);
					if (!soap_in_bes__ActivityStateEnumeration(soap, "hpcp_af:State", p, "bes:ActivityStateEnumeration"))
						break;
					soap_flag_State = 0;
				}
				a->State = (enum bes__ActivityStateEnumeration *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_ActivityIdRange && soap->error == SOAP_TAG_MISMATCH) {
				struct hpcp_af__ActivityIdRangeType *p;
				soap_new_block(soap);
				for (a->__sizeActivityIdRange = 0; !soap_element_begin_in(soap, "hpcp_af:ActivityIdRange", 1, NULL); a->__sizeActivityIdRange++) {
					p = (struct hpcp_af__ActivityIdRangeType *)soap_push_block(soap, sizeof(struct hpcp_af__ActivityIdRangeType));
					soap_default_hpcp_af__ActivityIdRangeType(soap, p);
					soap_revert(soap);
					if (!soap_in_hpcp_af__ActivityIdRangeType(soap, "hpcp_af:ActivityIdRange", p, "hpcp-af:ActivityIdRangeType"))
						break;
					soap_flag_ActivityIdRange = 0;
				}
				a->ActivityIdRange = (struct hpcp_af__ActivityIdRangeType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ActivityIdRange && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_ActivityId && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeActivityId = 0; !soap_element_begin_in(soap, "hpcp_af:ActivityId", 1, NULL); a->__sizeActivityId++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "hpcp_af:ActivityId", p, "xsd:string"))
						break;
					soap_flag_ActivityId = 0;
				}
				a->ActivityId = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ActivityId && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_DateTimeRange && soap->error == SOAP_TAG_MISMATCH) {
				struct hpcp_af__DateTimeRangeType *p;
				soap_new_block(soap);
				for (a->__sizeDateTimeRange = 0; !soap_element_begin_in(soap, "hpcp_af:DateTimeRange", 1, NULL); a->__sizeDateTimeRange++) {
					p = (struct hpcp_af__DateTimeRangeType *)soap_push_block(soap, sizeof(struct hpcp_af__DateTimeRangeType));
					soap_default_hpcp_af__DateTimeRangeType(soap, p);
					soap_revert(soap);
					if (!soap_in_hpcp_af__DateTimeRangeType(soap, "hpcp_af:DateTimeRange", p, "hpcp-af:DateTimeRangeType"))
						break;
					soap_flag_DateTimeRange = 0;
				}
				a->DateTimeRange = (struct hpcp_af__DateTimeRangeType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_DateTimeRange && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_CompactResources && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "hpcp_af:CompactResources", &a->CompactResources, "xsd:string")) {
					soap_flag_CompactResources--;
					continue;
				}
			if (soap_flag_UsageRecordFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "hpcp_af:UsageRecordFormat", &a->UsageRecordFormat, "xsd:string")) {
					soap_flag_UsageRecordFormat--;
					continue;
				}
			if (soap_flag_NodeStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "hpcp_af:NodeStatus", &a->NodeStatus, "xsd:string")) {
					soap_flag_NodeStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct hpcp_af__AdvancedFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hpcp_af__AdvancedFilterType, 0, sizeof(struct hpcp_af__AdvancedFilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->jsdl__URI);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__SourceTarget_USCOREType(struct soap *soap, const struct jsdl__SourceTarget_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->jsdl__URI);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__SourceTarget_USCOREType(struct soap *soap, const struct jsdl__SourceTarget_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__SourceTarget_USCOREType);
	if (soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__SourceTarget_USCOREType), type);
	soap_out_xsd__anyURI(soap, "jsdl:URI", -1, &a->jsdl__URI, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get_jsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__URI = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__SourceTarget_USCOREType, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__SourceTarget_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "jsdl:URI", &a->jsdl__URI, "xsd:anyURI")) {
					soap_flag_jsdl__URI--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__SourceTarget_USCOREType, 0, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->jsdl__FileName);
	soap_default_xsd__NCName(soap, &a->jsdl__FilesystemName);
	soap_default_jsdl__CreationFlagEnumeration(soap, &a->jsdl__CreationFlag);
	a->jsdl__DeleteOnTermination = NULL;
	a->jsdl__Source = NULL;
	a->jsdl__Target = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__DataStaging_USCOREType(struct soap *soap, const struct jsdl__DataStaging_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->jsdl__FileName);
	soap_serialize_xsd__NCName(soap, &a->jsdl__FilesystemName);
	soap_serialize_PointerToxsd__boolean(soap, &a->jsdl__DeleteOnTermination);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &a->jsdl__Source);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &a->jsdl__Target);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__DataStaging_USCOREType(struct soap *soap, const struct jsdl__DataStaging_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__DataStaging_USCOREType);
	if (soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__DataStaging_USCOREType), type);
	soap_out_string(soap, "jsdl:FileName", -1, &a->jsdl__FileName, "");
	soap_out_xsd__NCName(soap, "jsdl:FilesystemName", -1, &a->jsdl__FilesystemName, "");
	soap_out_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", -1, &a->jsdl__CreationFlag, "");
	soap_out_PointerToxsd__boolean(soap, "jsdl:DeleteOnTermination", -1, &a->jsdl__DeleteOnTermination, "");
	soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", -1, &a->jsdl__Source, "");
	soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", -1, &a->jsdl__Target, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_get_jsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_in_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, struct jsdl__DataStaging_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__FileName = 1, soap_flag_jsdl__FilesystemName = 1, soap_flag_jsdl__CreationFlag = 1, soap_flag_jsdl__DeleteOnTermination = 1, soap_flag_jsdl__Source = 1, soap_flag_jsdl__Target = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__DataStaging_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__DataStaging_USCOREType, sizeof(struct jsdl__DataStaging_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__DataStaging_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:FileName", &a->jsdl__FileName, "xsd:string")) {
					soap_flag_jsdl__FileName--;
					continue;
				}
			if (soap_flag_jsdl__FilesystemName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__NCName(soap, "jsdl:FilesystemName", &a->jsdl__FilesystemName, "xsd:NCName")) {
					soap_flag_jsdl__FilesystemName--;
					continue;
				}
			if (soap_flag_jsdl__CreationFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", &a->jsdl__CreationFlag, "jsdl:CreationFlagEnumeration")) {
					soap_flag_jsdl__CreationFlag--;
					continue;
				}
			if (soap_flag_jsdl__DeleteOnTermination && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "jsdl:DeleteOnTermination", &a->jsdl__DeleteOnTermination, "xsd:boolean")) {
					soap_flag_jsdl__DeleteOnTermination--;
					continue;
				}
			if (soap_flag_jsdl__Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", &a->jsdl__Source, "jsdl:SourceTarget_Type")) {
					soap_flag_jsdl__Source--;
					continue;
				}
			if (soap_flag_jsdl__Target && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", &a->jsdl__Target, "jsdl:SourceTarget_Type")) {
					soap_flag_jsdl__Target--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__DataStaging_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__DataStaging_USCOREType, 0, sizeof(struct jsdl__DataStaging_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__FileName > 0 || soap_flag_jsdl__CreationFlag > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, &a->jsdl__OperatingSystemName);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const struct jsdl__OperatingSystemType_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const struct jsdl__OperatingSystemType_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType);
	if (soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType), type);
	soap_out_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", -1, &a->jsdl__OperatingSystemName, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, struct jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__OperatingSystemName = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__OperatingSystemType_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__OperatingSystemType_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", &a->jsdl__OperatingSystemName, "jsdl:OperatingSystemTypeEnumeration")) {
					soap_flag_jsdl__OperatingSystemName--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__OperatingSystemType_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, 0, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__OperatingSystemName > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__OperatingSystemType = NULL;
	soap_default_string(soap, &a->jsdl__OperatingSystemVersion);
	soap_default_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__OperatingSystem_USCOREType(struct soap *soap, const struct jsdl__OperatingSystem_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, &a->jsdl__OperatingSystemType);
	soap_serialize_string(soap, &a->jsdl__OperatingSystemVersion);
	soap_serialize_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__OperatingSystem_USCOREType(struct soap *soap, const struct jsdl__OperatingSystem_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystem_USCOREType);
	if (soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType), type);
	soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", -1, &a->jsdl__OperatingSystemType, "");
	soap_out_string(soap, "jsdl:OperatingSystemVersion", -1, &a->jsdl__OperatingSystemVersion, "");
	soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, struct jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__OperatingSystemType = 1, soap_flag_jsdl__OperatingSystemVersion = 1, soap_flag_jsdl__Description = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__OperatingSystem_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, sizeof(struct jsdl__OperatingSystem_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__OperatingSystem_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", &a->jsdl__OperatingSystemType, "jsdl:OperatingSystemType_Type")) {
					soap_flag_jsdl__OperatingSystemType--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystemVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:OperatingSystemVersion", &a->jsdl__OperatingSystemVersion, "xsd:string")) {
					soap_flag_jsdl__OperatingSystemVersion--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type")) {
					soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__OperatingSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, 0, sizeof(struct jsdl__OperatingSystem_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__FileSystemType = NULL;
	soap_default_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	soap_default_string(soap, &a->jsdl__MountPoint);
	a->jsdl__DiskSpace = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__FileSystem_USCOREType(struct soap *soap, const struct jsdl__FileSystem_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, &a->jsdl__FileSystemType);
	soap_serialize_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	soap_serialize_string(soap, &a->jsdl__MountPoint);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__DiskSpace);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__FileSystem_USCOREType(struct soap *soap, const struct jsdl__FileSystem_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__FileSystem_USCOREType);
	if (soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__FileSystem_USCOREType), type);
	soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", -1, &a->jsdl__FileSystemType, "");
	soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, "");
	soap_out_string(soap, "jsdl:MountPoint", -1, &a->jsdl__MountPoint, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", -1, &a->jsdl__DiskSpace, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, struct jsdl__FileSystem_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__FileSystemType = 1, soap_flag_jsdl__Description = 1, soap_flag_jsdl__MountPoint = 1, soap_flag_jsdl__DiskSpace = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__FileSystem_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__FileSystem_USCOREType, sizeof(struct jsdl__FileSystem_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__FileSystem_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileSystemType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", &a->jsdl__FileSystemType, "jsdl:FileSystemTypeEnumeration")) {
					soap_flag_jsdl__FileSystemType--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type")) {
					soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag_jsdl__MountPoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:MountPoint", &a->jsdl__MountPoint, "xsd:string")) {
					soap_flag_jsdl__MountPoint--;
					continue;
				}
			if (soap_flag_jsdl__DiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", &a->jsdl__DiskSpace, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__DiskSpace--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__FileSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__FileSystem_USCOREType, 0, sizeof(struct jsdl__FileSystem_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, &a->jsdl__CPUArchitectureName);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const struct jsdl__CPUArchitecture_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const struct jsdl__CPUArchitecture_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType);
	if (soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType), type);
	soap_out_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", -1, &a->jsdl__CPUArchitectureName, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_get_jsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_in_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, struct jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__CPUArchitectureName = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__CPUArchitecture_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__CPUArchitecture_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CPUArchitectureName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", &a->jsdl__CPUArchitectureName, "jsdl:ProcessorArchitectureEnumeration")) {
					soap_flag_jsdl__CPUArchitectureName--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__CPUArchitecture_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, 0, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__CPUArchitectureName > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeHostName = 0;
	a->jsdl__HostName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__CandidateHosts_USCOREType(struct soap *soap, const struct jsdl__CandidateHosts_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->jsdl__HostName) {
		int i;
		for (i = 0; i < a->__sizeHostName; i++) {
			soap_serialize_string(soap, a->jsdl__HostName + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__CandidateHosts_USCOREType(struct soap *soap, const struct jsdl__CandidateHosts_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__CandidateHosts_USCOREType);
	if (soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType), type);
	if (a->jsdl__HostName) {
		int i;
		for (i = 0; i < a->__sizeHostName; i++)
			soap_out_string(soap, "jsdl:HostName", -1, a->jsdl__HostName + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_get_jsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_in_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, struct jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__HostName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__CandidateHosts_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, sizeof(struct jsdl__CandidateHosts_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__CandidateHosts_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__HostName && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeHostName = 0; !soap_element_begin_in(soap, "jsdl:HostName", 1, NULL); a->__sizeHostName++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:HostName", p, "xsd:string"))
						break;
					soap_flag_jsdl__HostName = 0;
				}
				a->jsdl__HostName = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__HostName && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__CandidateHosts_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, 0, sizeof(struct jsdl__CandidateHosts_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__CandidateHosts = NULL;
	a->__sizeFileSystem = 0;
	a->jsdl__FileSystem = NULL;
	a->jsdl__ExclusiveExecution = NULL;
	a->jsdl__OperatingSystem = NULL;
	a->jsdl__CPUArchitecture = NULL;
	a->jsdl__IndividualCPUSpeed = NULL;
	a->jsdl__IndividualCPUTime = NULL;
	a->jsdl__IndividualCPUCount = NULL;
	a->jsdl__IndividualNetworkBandwidth = NULL;
	a->jsdl__IndividualPhysicalMemory = NULL;
	a->jsdl__IndividualVirtualMemory = NULL;
	a->jsdl__IndividualDiskSpace = NULL;
	a->jsdl__TotalCPUTime = NULL;
	a->jsdl__TotalCPUCount = NULL;
	a->jsdl__TotalPhysicalMemory = NULL;
	a->jsdl__TotalVirtualMemory = NULL;
	a->jsdl__TotalDiskSpace = NULL;
	a->jsdl__TotalResourceCount = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__Resources_USCOREType(struct soap *soap, const struct jsdl__Resources_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, &a->jsdl__CandidateHosts);
	if (a->jsdl__FileSystem) {
		int i;
		for (i = 0; i < a->__sizeFileSystem; i++) {
			soap_embedded(soap, a->jsdl__FileSystem + i, SOAP_TYPE_jsdl__FileSystem_USCOREType);
			soap_serialize_jsdl__FileSystem_USCOREType(soap, a->jsdl__FileSystem + i);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->jsdl__ExclusiveExecution);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &a->jsdl__OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &a->jsdl__CPUArchitecture);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualCPUSpeed);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualNetworkBandwidth);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalResourceCount);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__Resources_USCOREType(struct soap *soap, const struct jsdl__Resources_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Resources_USCOREType);
	if (soap_out_jsdl__Resources_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Resources_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Resources_USCOREType), type);
	soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", -1, &a->jsdl__CandidateHosts, "");
	if (a->jsdl__FileSystem) {
		int i;
		for (i = 0; i < a->__sizeFileSystem; i++)
			soap_out_jsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", -1, a->jsdl__FileSystem + i, "");
	}
	soap_out_PointerToxsd__boolean(soap, "jsdl:ExclusiveExecution", -1, &a->jsdl__ExclusiveExecution, "");
	soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", -1, &a->jsdl__OperatingSystem, "");
	soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", -1, &a->jsdl__CPUArchitecture, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", -1, &a->jsdl__IndividualCPUSpeed, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", -1, &a->jsdl__IndividualCPUTime, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", -1, &a->jsdl__IndividualCPUCount, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", -1, &a->jsdl__IndividualNetworkBandwidth, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", -1, &a->jsdl__IndividualPhysicalMemory, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", -1, &a->jsdl__IndividualVirtualMemory, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", -1, &a->jsdl__IndividualDiskSpace, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", -1, &a->jsdl__TotalCPUTime, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", -1, &a->jsdl__TotalCPUCount, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", -1, &a->jsdl__TotalPhysicalMemory, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", -1, &a->jsdl__TotalVirtualMemory, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", -1, &a->jsdl__TotalDiskSpace, "");
	soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", -1, &a->jsdl__TotalResourceCount, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType * SOAP_FMAC4 soap_get_jsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType * SOAP_FMAC4 soap_in_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, struct jsdl__Resources_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__CandidateHosts = 1, soap_flag_jsdl__FileSystem = 1, soap_flag_jsdl__ExclusiveExecution = 1, soap_flag_jsdl__OperatingSystem = 1, soap_flag_jsdl__CPUArchitecture = 1, soap_flag_jsdl__IndividualCPUSpeed = 1, soap_flag_jsdl__IndividualCPUTime = 1, soap_flag_jsdl__IndividualCPUCount = 1, soap_flag_jsdl__IndividualNetworkBandwidth = 1, soap_flag_jsdl__IndividualPhysicalMemory = 1, soap_flag_jsdl__IndividualVirtualMemory = 1, soap_flag_jsdl__IndividualDiskSpace = 1, soap_flag_jsdl__TotalCPUTime = 1, soap_flag_jsdl__TotalCPUCount = 1, soap_flag_jsdl__TotalPhysicalMemory = 1, soap_flag_jsdl__TotalVirtualMemory = 1, soap_flag_jsdl__TotalDiskSpace = 1, soap_flag_jsdl__TotalResourceCount = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Resources_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Resources_USCOREType, sizeof(struct jsdl__Resources_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__Resources_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CandidateHosts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", &a->jsdl__CandidateHosts, "jsdl:CandidateHosts_Type")) {
					soap_flag_jsdl__CandidateHosts--;
					continue;
				}
			if (soap_flag_jsdl__FileSystem && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__FileSystem_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeFileSystem = 0; !soap_element_begin_in(soap, "jsdl:FileSystem", 1, NULL); a->__sizeFileSystem++) {
					p = (struct jsdl__FileSystem_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__FileSystem_USCOREType));
					soap_default_jsdl__FileSystem_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", p, "jsdl:FileSystem_Type"))
						break;
					soap_flag_jsdl__FileSystem = 0;
				}
				a->jsdl__FileSystem = (struct jsdl__FileSystem_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__FileSystem && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl__ExclusiveExecution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "jsdl:ExclusiveExecution", &a->jsdl__ExclusiveExecution, "xsd:boolean")) {
					soap_flag_jsdl__ExclusiveExecution--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", &a->jsdl__OperatingSystem, "jsdl:OperatingSystem_Type")) {
					soap_flag_jsdl__OperatingSystem--;
					continue;
				}
			if (soap_flag_jsdl__CPUArchitecture && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", &a->jsdl__CPUArchitecture, "jsdl:CPUArchitecture_Type")) {
					soap_flag_jsdl__CPUArchitecture--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", &a->jsdl__IndividualCPUSpeed, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualCPUSpeed--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", &a->jsdl__IndividualCPUTime, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualCPUTime--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", &a->jsdl__IndividualCPUCount, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualCPUCount--;
					continue;
				}
			if (soap_flag_jsdl__IndividualNetworkBandwidth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", &a->jsdl__IndividualNetworkBandwidth, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualNetworkBandwidth--;
					continue;
				}
			if (soap_flag_jsdl__IndividualPhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", &a->jsdl__IndividualPhysicalMemory, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualPhysicalMemory--;
					continue;
				}
			if (soap_flag_jsdl__IndividualVirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", &a->jsdl__IndividualVirtualMemory, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualVirtualMemory--;
					continue;
				}
			if (soap_flag_jsdl__IndividualDiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", &a->jsdl__IndividualDiskSpace, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__IndividualDiskSpace--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", &a->jsdl__TotalCPUTime, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalCPUTime--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", &a->jsdl__TotalCPUCount, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalCPUCount--;
					continue;
				}
			if (soap_flag_jsdl__TotalPhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", &a->jsdl__TotalPhysicalMemory, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalPhysicalMemory--;
					continue;
				}
			if (soap_flag_jsdl__TotalVirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", &a->jsdl__TotalVirtualMemory, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalVirtualMemory--;
					continue;
				}
			if (soap_flag_jsdl__TotalDiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", &a->jsdl__TotalDiskSpace, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalDiskSpace--;
					continue;
				}
			if (soap_flag_jsdl__TotalResourceCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", &a->jsdl__TotalResourceCount, "jsdl:RangeValue_Type")) {
					soap_flag_jsdl__TotalResourceCount--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__Resources_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Resources_USCOREType, 0, sizeof(struct jsdl__Resources_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->jsdl__ApplicationName);
	soap_default_string(soap, &a->jsdl__ApplicationVersion);
	soap_default_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__Application_USCOREType(struct soap *soap, const struct jsdl__Application_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->jsdl__ApplicationName);
	soap_serialize_string(soap, &a->jsdl__ApplicationVersion);
	soap_serialize_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__Application_USCOREType(struct soap *soap, const struct jsdl__Application_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Application_USCOREType);
	if (soap_out_jsdl__Application_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Application_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Application_USCOREType), type);
	soap_out_string(soap, "jsdl:ApplicationName", -1, &a->jsdl__ApplicationName, "");
	soap_out_string(soap, "jsdl:ApplicationVersion", -1, &a->jsdl__ApplicationVersion, "");
	soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__Application_USCOREType * SOAP_FMAC4 soap_get_jsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Application_USCOREType * SOAP_FMAC4 soap_in_jsdl__Application_USCOREType(struct soap *soap, const char *tag, struct jsdl__Application_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__ApplicationName = 1, soap_flag_jsdl__ApplicationVersion = 1, soap_flag_jsdl__Description = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Application_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Application_USCOREType, sizeof(struct jsdl__Application_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__Application_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__ApplicationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:ApplicationName", &a->jsdl__ApplicationName, "xsd:string")) {
					soap_flag_jsdl__ApplicationName--;
					continue;
				}
			if (soap_flag_jsdl__ApplicationVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:ApplicationVersion", &a->jsdl__ApplicationVersion, "xsd:string")) {
					soap_flag_jsdl__ApplicationVersion--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type")) {
					soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__Application_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Application_USCOREType, 0, sizeof(struct jsdl__Application_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->jsdl__JobName);
	soap_default_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	a->__sizeJobAnnotation = 0;
	a->jsdl__JobAnnotation = NULL;
	a->__sizeJobProject = 0;
	a->jsdl__JobProject = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__JobIdentification_USCOREType(struct soap *soap, const struct jsdl__JobIdentification_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->jsdl__JobName);
	soap_serialize_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	if (a->jsdl__JobAnnotation) {
		int i;
		for (i = 0; i < a->__sizeJobAnnotation; i++) {
			soap_serialize_string(soap, a->jsdl__JobAnnotation + i);
		}
	}
	if (a->jsdl__JobProject) {
		int i;
		for (i = 0; i < a->__sizeJobProject; i++) {
			soap_serialize_string(soap, a->jsdl__JobProject + i);
		}
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__JobIdentification_USCOREType(struct soap *soap, const struct jsdl__JobIdentification_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__JobIdentification_USCOREType);
	if (soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__JobIdentification_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobIdentification_USCOREType), type);
	soap_out_string(soap, "jsdl:JobName", -1, &a->jsdl__JobName, "");
	soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, "");
	if (a->jsdl__JobAnnotation) {
		int i;
		for (i = 0; i < a->__sizeJobAnnotation; i++)
			soap_out_string(soap, "jsdl:JobAnnotation", -1, a->jsdl__JobAnnotation + i, "");
	}
	if (a->jsdl__JobProject) {
		int i;
		for (i = 0; i < a->__sizeJobProject; i++)
			soap_out_string(soap, "jsdl:JobProject", -1, a->jsdl__JobProject + i, "");
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobIdentification_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobName = 1, soap_flag_jsdl__Description = 1, soap_flag_jsdl__JobAnnotation = 1, soap_flag_jsdl__JobProject = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobIdentification_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobIdentification_USCOREType, sizeof(struct jsdl__JobIdentification_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__JobIdentification_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:JobName", &a->jsdl__JobName, "xsd:string")) {
					soap_flag_jsdl__JobName--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type")) {
					soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag_jsdl__JobAnnotation && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeJobAnnotation = 0; !soap_element_begin_in(soap, "jsdl:JobAnnotation", 1, NULL); a->__sizeJobAnnotation++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:JobAnnotation", p, "xsd:string"))
						break;
					soap_flag_jsdl__JobAnnotation = 0;
				}
				a->jsdl__JobAnnotation = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__JobAnnotation && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl__JobProject && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeJobProject = 0; !soap_element_begin_in(soap, "jsdl:JobProject", 1, NULL); a->__sizeJobProject++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:JobProject", p, "xsd:string"))
						break;
					soap_flag_jsdl__JobProject = 0;
				}
				a->jsdl__JobProject = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__JobProject && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__JobIdentification_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobIdentification_USCOREType, 0, sizeof(struct jsdl__JobIdentification_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__JobIdentification = NULL;
	a->jsdl__Application = NULL;
	a->jsdl__Resources = NULL;
	a->__sizeDataStaging = 0;
	a->jsdl__DataStaging = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__JobDescription_USCOREType(struct soap *soap, const struct jsdl__JobDescription_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, &a->jsdl__JobIdentification);
	soap_serialize_PointerTojsdl__Application_USCOREType(soap, &a->jsdl__Application);
	soap_serialize_PointerTojsdl__Resources_USCOREType(soap, &a->jsdl__Resources);
	if (a->jsdl__DataStaging) {
		int i;
		for (i = 0; i < a->__sizeDataStaging; i++) {
			soap_embedded(soap, a->jsdl__DataStaging + i, SOAP_TYPE_jsdl__DataStaging_USCOREType);
			soap_serialize_jsdl__DataStaging_USCOREType(soap, a->jsdl__DataStaging + i);
		}
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__JobDescription_USCOREType(struct soap *soap, const struct jsdl__JobDescription_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__JobDescription_USCOREType);
	if (soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__JobDescription_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobDescription_USCOREType), type);
	soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", -1, &a->jsdl__JobIdentification, "");
	soap_out_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", -1, &a->jsdl__Application, "");
	soap_out_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", -1, &a->jsdl__Resources, "");
	if (a->jsdl__DataStaging) {
		int i;
		for (i = 0; i < a->__sizeDataStaging; i++)
			soap_out_jsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", -1, a->jsdl__DataStaging + i, "");
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobDescription_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobIdentification = 1, soap_flag_jsdl__Application = 1, soap_flag_jsdl__Resources = 1, soap_flag_jsdl__DataStaging = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobDescription_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobDescription_USCOREType, sizeof(struct jsdl__JobDescription_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__JobDescription_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobIdentification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", &a->jsdl__JobIdentification, "jsdl:JobIdentification_Type")) {
					soap_flag_jsdl__JobIdentification--;
					continue;
				}
			if (soap_flag_jsdl__Application && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", &a->jsdl__Application, "jsdl:Application_Type")) {
					soap_flag_jsdl__Application--;
					continue;
				}
			if (soap_flag_jsdl__Resources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", &a->jsdl__Resources, "jsdl:Resources_Type")) {
					soap_flag_jsdl__Resources--;
					continue;
				}
			if (soap_flag_jsdl__DataStaging && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__DataStaging_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeDataStaging = 0; !soap_element_begin_in(soap, "jsdl:DataStaging", 1, NULL); a->__sizeDataStaging++) {
					p = (struct jsdl__DataStaging_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__DataStaging_USCOREType));
					soap_default_jsdl__DataStaging_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", p, "jsdl:DataStaging_Type"))
						break;
					soap_flag_jsdl__DataStaging = 0;
				}
				a->jsdl__DataStaging = (struct jsdl__DataStaging_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__DataStaging && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__JobDescription_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobDescription_USCOREType, 0, sizeof(struct jsdl__JobDescription_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__JobDescription = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__ID(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__JobDefinition_USCOREType(struct soap *soap, const struct jsdl__JobDefinition_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, &a->jsdl__JobDescription);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__JobDefinition_USCOREType(struct soap *soap, const struct jsdl__JobDefinition_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__JobDefinition_USCOREType);
	if (soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobDefinition_USCOREType), type);
	soap_out_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", -1, &a->jsdl__JobDescription, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobDefinition_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobDescription = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobDefinition_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobDefinition_USCOREType, sizeof(struct jsdl__JobDefinition_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__JobDefinition_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 0), &a->id))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", &a->jsdl__JobDescription, "jsdl:JobDescription_Type")) {
					soap_flag_jsdl__JobDescription--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__JobDefinition_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobDefinition_USCOREType, 0, sizeof(struct jsdl__JobDefinition_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDescription > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->UpperBoundedRange = NULL;
	a->LowerBoundedRange = NULL;
	a->__sizeExact = 0;
	a->Exact = NULL;
	a->__sizeRange = 0;
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__RangeValue_USCOREType(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &a->UpperBoundedRange);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &a->LowerBoundedRange);
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++) {
			soap_embedded(soap, a->Exact + i, SOAP_TYPE_jsdl__Exact_USCOREType);
			soap_serialize_jsdl__Exact_USCOREType(soap, a->Exact + i);
		}
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++) {
			soap_embedded(soap, a->Range + i, SOAP_TYPE_jsdl__Range_USCOREType);
			soap_serialize_jsdl__Range_USCOREType(soap, a->Range + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__RangeValue_USCOREType(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__RangeValue_USCOREType);
	if (soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__RangeValue_USCOREType), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, "");
	if (a->Exact) {
		int i;
		for (i = 0; i < a->__sizeExact; i++)
			soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, "");
	}
	if (a->Range) {
		int i;
		for (i = 0; i < a->__sizeRange; i++)
			soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get_jsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__RangeValue_USCOREType, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__RangeValue_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type")) {
					soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++) {
					p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH) {
				struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++) {
					p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__RangeValue_USCOREType, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->LowerBound = NULL;
	a->UpperBound = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__Range_USCOREType(struct soap *soap, const struct jsdl__Range_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &a->LowerBound);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &a->UpperBound);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__Range_USCOREType(struct soap *soap, const struct jsdl__Range_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Range_USCOREType);
	if (soap_out_jsdl__Range_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Range_USCOREType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Range_USCOREType), type);
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", -1, &a->LowerBound, "");
	soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", -1, &a->UpperBound, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct jsdl__Range_USCOREType * SOAP_FMAC4 soap_get_jsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Range_USCOREType * SOAP_FMAC4 soap_in_jsdl__Range_USCOREType(struct soap *soap, const char *tag, struct jsdl__Range_USCOREType *a, const char *type)
{
	short soap_flag_LowerBound = 1, soap_flag_UpperBound = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Range_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Range_USCOREType, sizeof(struct jsdl__Range_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__Range_USCOREType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LowerBound && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", &a->LowerBound, "jsdl:Boundary_Type")) {
					soap_flag_LowerBound--;
					continue;
				}
			if (soap_flag_UpperBound && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", &a->UpperBound, "jsdl:Boundary_Type")) {
					soap_flag_UpperBound--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct jsdl__Range_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Range_USCOREType, 0, sizeof(struct jsdl__Range_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LowerBound > 0 || soap_flag_UpperBound > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->__item);
	a->epsilon = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__Exact_USCOREType(struct soap *soap, const struct jsdl__Exact_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__item, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__Exact_USCOREType(struct soap *soap, const struct jsdl__Exact_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Exact_USCOREType);
	if (soap_out_jsdl__Exact_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Exact_USCOREType *a, const char *type)
{
	if (a->epsilon)
		soap_set_attr(soap, "epsilon", soap_double2s(soap, *a->epsilon));
	return soap_out_double(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl__Exact_USCOREType * SOAP_FMAC4 soap_get_jsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Exact_USCOREType * SOAP_FMAC4 soap_in_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, struct jsdl__Exact_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl__Exact_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Exact_USCOREType, sizeof(struct jsdl__Exact_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl__Exact_USCOREType(soap, a); {
		const char *t = soap_attr_value(soap, "epsilon", 0);
		if (t) {
			if (!(a->epsilon = (double *)soap_malloc(soap, sizeof(double)))) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, a->epsilon))
				return NULL;
		}
	}
	if (!soap_in_double(soap, tag, &a->__item, "jsdl:Exact_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->__item);
	a->exclusiveBound = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__Boundary_USCOREType(struct soap *soap, const struct jsdl__Boundary_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__item, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__Boundary_USCOREType(struct soap *soap, const struct jsdl__Boundary_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Boundary_USCOREType);
	if (soap_out_jsdl__Boundary_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Boundary_USCOREType *a, const char *type)
{
	if (a->exclusiveBound)
		soap_set_attr(soap, "exclusiveBound", soap_xsd__boolean2s(soap, *a->exclusiveBound));
	return soap_out_double(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_get_jsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_in_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, struct jsdl__Boundary_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl__Boundary_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Boundary_USCOREType, sizeof(struct jsdl__Boundary_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl__Boundary_USCOREType(soap, a); {
		const char *t = soap_attr_value(soap, "exclusiveBound", 0);
		if (t) {
			if (!(a->exclusiveBound = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean)))) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->exclusiveBound))
				return NULL;
		}
	}
	if (!soap_in_double(soap, tag, &a->__item, "jsdl:Boundary_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__ProblemActionType(struct soap *soap, struct wsa__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsa__Action = NULL;
	soap_default_xsd__anyURI(soap, &a->SoapAction);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__ProblemActionType(struct soap *soap, const struct wsa__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__AttributedURIType(soap, &a->wsa__Action);
	soap_serialize_xsd__anyURI(soap, &a->SoapAction);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__ProblemActionType(struct soap *soap, const struct wsa__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ProblemActionType);
	if (soap_out_wsa__ProblemActionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa__ProblemActionType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ProblemActionType), type);
	soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Action", -1, &a->wsa__Action, "");
	soap_out_xsd__anyURI(soap, "wsa:SoapAction", -1, &a->SoapAction, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__ProblemActionType * SOAP_FMAC4 soap_get_wsa__ProblemActionType(struct soap *soap, struct wsa__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ProblemActionType * SOAP_FMAC4 soap_in_wsa__ProblemActionType(struct soap *soap, const char *tag, struct wsa__ProblemActionType *a, const char *type)
{
	short soap_flag_wsa__Action = 1, soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ProblemActionType, sizeof(struct wsa__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ProblemActionType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__Action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Action", &a->wsa__Action, "wsa:AttributedURIType")) {
					soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "wsa:SoapAction", &a->SoapAction, "xsd:anyURI")) {
					soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ProblemActionType, 0, sizeof(struct wsa__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__AttributedQNameType(struct soap *soap, struct wsa__AttributedQNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__AttributedQNameType(struct soap *soap, const struct wsa__AttributedQNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__QName(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__AttributedQNameType(struct soap *soap, const struct wsa__AttributedQNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__AttributedQNameType);
	if (soap_out_wsa__AttributedQNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__AttributedQNameType(struct soap *soap, const char *tag, int id, const struct wsa__AttributedQNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	return soap_out_xsd__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__AttributedQNameType * SOAP_FMAC4 soap_get_wsa__AttributedQNameType(struct soap *soap, struct wsa__AttributedQNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__AttributedQNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedQNameType * SOAP_FMAC4 soap_in_wsa__AttributedQNameType(struct soap *soap, const char *tag, struct wsa__AttributedQNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedQNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__AttributedQNameType, sizeof(struct wsa__AttributedQNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__AttributedQNameType(soap, a);
	if (!soap_in_xsd__QName(soap, tag, &a->__item, "wsa:AttributedQNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__AttributedUnsignedLongType(struct soap *soap, struct wsa__AttributedUnsignedLongType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedLONG64(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__AttributedUnsignedLongType(struct soap *soap, const struct wsa__AttributedUnsignedLongType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__AttributedUnsignedLongType(struct soap *soap, const struct wsa__AttributedUnsignedLongType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__AttributedUnsignedLongType);
	if (soap_out_wsa__AttributedUnsignedLongType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__AttributedUnsignedLongType(struct soap *soap, const char *tag, int id, const struct wsa__AttributedUnsignedLongType *a, const char *type)
{
	return soap_out_unsignedLONG64(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedUnsignedLongType * SOAP_FMAC4 soap_get_wsa__AttributedUnsignedLongType(struct soap *soap, struct wsa__AttributedUnsignedLongType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__AttributedUnsignedLongType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedUnsignedLongType * SOAP_FMAC4 soap_in_wsa__AttributedUnsignedLongType(struct soap *soap, const char *tag, struct wsa__AttributedUnsignedLongType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedUnsignedLongType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__AttributedUnsignedLongType, sizeof(struct wsa__AttributedUnsignedLongType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__AttributedUnsignedLongType(soap, a);
	if (!soap_in_unsignedLONG64(soap, tag, &a->__item, "wsa:AttributedUnsignedLongType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__AttributedURIType(struct soap *soap, const struct wsa__AttributedURIType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__AttributedURIType(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__AttributedURIType);
	if (soap_out_wsa__AttributedURIType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__AttributedURIType(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get_wsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in_wsa__AttributedURIType(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__AttributedURIType, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__AttributedURIType(soap, a);
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, "wsa:AttributedURIType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__RelatesToType(struct soap *soap, struct wsa__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->__item);
	soap_default_wsa__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__RelatesToType(struct soap *soap, const struct wsa__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__RelatesToType(struct soap *soap, const struct wsa__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__RelatesToType);
	if (soap_out_wsa__RelatesToType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType);
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__RelatesToType * SOAP_FMAC4 soap_get_wsa__RelatesToType(struct soap *soap, struct wsa__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__RelatesToType * SOAP_FMAC4 soap_in_wsa__RelatesToType(struct soap *soap, const char *tag, struct wsa__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelatesToType, sizeof(struct wsa__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, "wsa:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__MetadataType(struct soap *soap, struct wsa__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__MetadataType(struct soap *soap, const struct wsa__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__MetadataType(struct soap *soap, const struct wsa__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__MetadataType);
	if (soap_out_wsa__MetadataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa__MetadataType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__MetadataType), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__MetadataType * SOAP_FMAC4 soap_get_wsa__MetadataType(struct soap *soap, struct wsa__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__MetadataType * SOAP_FMAC4 soap_in_wsa__MetadataType(struct soap *soap, const char *tag, struct wsa__MetadataType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__MetadataType, sizeof(struct wsa__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__MetadataType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__MetadataType, 0, sizeof(struct wsa__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferenceParametersType);
	if (soap_out_wsa__ReferenceParametersType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Address = NULL;
	a->wsa__ReferenceParameters = NULL;
	a->wsa__Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__AttributedURIType(soap, &a->Address);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->wsa__ReferenceParameters);
	soap_serialize_PointerTowsa__MetadataType(soap, &a->wsa__Metadata);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__EndpointReferenceType);
	if (soap_out_wsa__EndpointReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type);
	soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, "");
	soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, "");
	soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType")) {
					soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType")) {
					soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType")) {
					soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__TerminateActivityResponseType(struct soap *soap, struct bes__TerminateActivityResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityIdentifier = NULL;
	soap_default_xsd__boolean(soap, &a->Cancelled);
	a->Fault = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__TerminateActivityResponseType(struct soap *soap, const struct bes__TerminateActivityResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &a->ActivityIdentifier);
	soap_embedded(soap, &a->Cancelled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToxsd__anyType(soap, &a->Fault);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__TerminateActivityResponseType(struct soap *soap, const struct bes__TerminateActivityResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__TerminateActivityResponseType);
	if (soap_out_bes__TerminateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__TerminateActivityResponseType(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivityResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__TerminateActivityResponseType), type);
	soap_out_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", -1, &a->ActivityIdentifier, "");
	soap_out_xsd__boolean(soap, "bes:Cancelled", -1, &a->Cancelled, "");
	soap_out_PointerToxsd__anyType(soap, "bes:Fault", -1, &a->Fault, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__TerminateActivityResponseType * SOAP_FMAC4 soap_get_bes__TerminateActivityResponseType(struct soap *soap, struct bes__TerminateActivityResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__TerminateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivityResponseType * SOAP_FMAC4 soap_in_bes__TerminateActivityResponseType(struct soap *soap, const char *tag, struct bes__TerminateActivityResponseType *a, const char *type)
{
	short soap_flag_ActivityIdentifier = 1, soap_flag_Cancelled = 1, soap_flag_Fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivityResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__TerminateActivityResponseType, sizeof(struct bes__TerminateActivityResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__TerminateActivityResponseType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", &a->ActivityIdentifier, "wsa:EndpointReferenceType")) {
					soap_flag_ActivityIdentifier--;
					continue;
				}
			if (soap_flag_Cancelled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "bes:Cancelled", &a->Cancelled, "xsd:boolean")) {
					soap_flag_Cancelled--;
					continue;
				}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "bes:Fault", &a->Fault, "xsd:anyType")) {
					soap_flag_Fault--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__TerminateActivityResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__TerminateActivityResponseType, 0, sizeof(struct bes__TerminateActivityResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityIdentifier > 0 || soap_flag_Cancelled > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__GetActivityDocumentResponseType(struct soap *soap, struct bes__GetActivityDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityIdentifier = NULL;
	a->JobDefinition = NULL;
	a->Fault = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__GetActivityDocumentResponseType(struct soap *soap, const struct bes__GetActivityDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &a->ActivityIdentifier);
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &a->JobDefinition);
	soap_serialize_PointerToxsd__anyType(soap, &a->Fault);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__GetActivityDocumentResponseType(struct soap *soap, const struct bes__GetActivityDocumentResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityDocumentResponseType);
	if (soap_out_bes__GetActivityDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__GetActivityDocumentResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityDocumentResponseType), type);
	soap_out_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", -1, &a->ActivityIdentifier, "");
	soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "bes:JobDefinition", -1, &a->JobDefinition, "");
	soap_out_PointerToxsd__anyType(soap, "bes:Fault", -1, &a->Fault, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityDocumentResponseType * SOAP_FMAC4 soap_get_bes__GetActivityDocumentResponseType(struct soap *soap, struct bes__GetActivityDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentResponseType * SOAP_FMAC4 soap_in_bes__GetActivityDocumentResponseType(struct soap *soap, const char *tag, struct bes__GetActivityDocumentResponseType *a, const char *type)
{
	short soap_flag_ActivityIdentifier = 1, soap_flag_JobDefinition = 1, soap_flag_Fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityDocumentResponseType, sizeof(struct bes__GetActivityDocumentResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityDocumentResponseType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", &a->ActivityIdentifier, "wsa:EndpointReferenceType")) {
					soap_flag_ActivityIdentifier--;
					continue;
				}
			if (soap_flag_JobDefinition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, "bes:JobDefinition", &a->JobDefinition, "jsdl:JobDefinition_Type")) {
					soap_flag_JobDefinition--;
					continue;
				}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "bes:Fault", &a->Fault, "xsd:anyType")) {
					soap_flag_Fault--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityDocumentResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityDocumentResponseType, 0, sizeof(struct bes__GetActivityDocumentResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityIdentifier > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__GetActivityStatusResponseType(struct soap *soap, struct bes__GetActivityStatusResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityIdentifier = NULL;
	a->bes__ActivityStatus = NULL;
	a->Fault = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__GetActivityStatusResponseType(struct soap *soap, const struct bes__GetActivityStatusResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &a->ActivityIdentifier);
	soap_serialize_PointerTobes__ActivityStatusType(soap, &a->bes__ActivityStatus);
	soap_serialize_PointerToxsd__anyType(soap, &a->Fault);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__GetActivityStatusResponseType(struct soap *soap, const struct bes__GetActivityStatusResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityStatusResponseType);
	if (soap_out_bes__GetActivityStatusResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__GetActivityStatusResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityStatusResponseType), type);
	soap_out_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", -1, &a->ActivityIdentifier, "");
	soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->bes__ActivityStatus, "");
	soap_out_PointerToxsd__anyType(soap, "bes:Fault", -1, &a->Fault, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityStatusResponseType * SOAP_FMAC4 soap_get_bes__GetActivityStatusResponseType(struct soap *soap, struct bes__GetActivityStatusResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityStatusResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusResponseType * SOAP_FMAC4 soap_in_bes__GetActivityStatusResponseType(struct soap *soap, const char *tag, struct bes__GetActivityStatusResponseType *a, const char *type)
{
	short soap_flag_ActivityIdentifier = 1, soap_flag_bes__ActivityStatus = 1, soap_flag_Fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityStatusResponseType, sizeof(struct bes__GetActivityStatusResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityStatusResponseType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", &a->ActivityIdentifier, "wsa:EndpointReferenceType")) {
					soap_flag_ActivityIdentifier--;
					continue;
				}
			if (soap_flag_bes__ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->bes__ActivityStatus, "bes:ActivityStatusType")) {
					soap_flag_bes__ActivityStatus--;
					continue;
				}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "bes:Fault", &a->Fault, "xsd:anyType")) {
					soap_flag_Fault--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityStatusResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityStatusResponseType, 0, sizeof(struct bes__GetActivityStatusResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityIdentifier > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_bes__ActivityStateEnumeration(soap, &a->state);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__ActivityStatusType(struct soap *soap, const struct bes__ActivityStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__ActivityStatusType(struct soap *soap, const struct bes__ActivityStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__ActivityStatusType);
	if (soap_out_bes__ActivityStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__ActivityStatusType(struct soap *soap, const char *tag, int id, const struct bes__ActivityStatusType *a, const char *type)
{
	soap_set_attr(soap, "state", soap_bes__ActivityStateEnumeration2s(soap, a->state));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__ActivityStatusType), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__ActivityStatusType * SOAP_FMAC4 soap_get_bes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__ActivityStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityStatusType * SOAP_FMAC4 soap_in_bes__ActivityStatusType(struct soap *soap, const char *tag, struct bes__ActivityStatusType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__ActivityStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__ActivityStatusType, sizeof(struct bes__ActivityStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__ActivityStatusType(soap, a);
	if (soap_s2bes__ActivityStateEnumeration(soap, soap_attr_value(soap, "state", 1), &a->state))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__ActivityStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__ActivityStatusType, 0, sizeof(struct bes__ActivityStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__ActivityDocumentType(struct soap *soap, struct bes__ActivityDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__ActivityDocumentType(struct soap *soap, const struct bes__ActivityDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__ActivityDocumentType(struct soap *soap, const struct bes__ActivityDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__ActivityDocumentType);
	if (soap_out_bes__ActivityDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__ActivityDocumentType(struct soap *soap, const char *tag, int id, const struct bes__ActivityDocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__ActivityDocumentType), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__ActivityDocumentType * SOAP_FMAC4 soap_get_bes__ActivityDocumentType(struct soap *soap, struct bes__ActivityDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__ActivityDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityDocumentType * SOAP_FMAC4 soap_in_bes__ActivityDocumentType(struct soap *soap, const char *tag, struct bes__ActivityDocumentType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__ActivityDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__ActivityDocumentType, sizeof(struct bes__ActivityDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__ActivityDocumentType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__ActivityDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__ActivityDocumentType, 0, sizeof(struct bes__ActivityDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__FactoryResourceAttributesDocumentType(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__BasicResourceAttributesDocument = NULL;
	soap_default_xsd__boolean(soap, &a->IsAcceptingNewActivities);
	soap_default_string(soap, &a->CommonName);
	soap_default_string(soap, &a->LongDescription);
	soap_default_LONG64(soap, &a->TotalNumberOfActivities);
	a->__sizeActivityReference = 0;
	a->ActivityReference = NULL;
	soap_default_LONG64(soap, &a->TotalNumberOfContainedResources);
	a->__sizeContainedResource = 0;
	a->ContainedResource = NULL;
	a->__sizeNamingProfile = 0;
	a->NamingProfile = NULL;
	a->__sizeBESExtension = 0;
	a->BESExtension = NULL;
	soap_default_xsd__anyURI(soap, &a->LocalResourceManagerType);
	a->AdvancedFilter = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__FactoryResourceAttributesDocumentType(struct soap *soap, const struct bes__FactoryResourceAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__BasicResourceAttributesDocumentType(soap, &a->bes__BasicResourceAttributesDocument);
	soap_embedded(soap, &a->IsAcceptingNewActivities, SOAP_TYPE_xsd__boolean);
	soap_serialize_string(soap, &a->CommonName);
	soap_serialize_string(soap, &a->LongDescription);
	if (a->ActivityReference) {
		int i;
		for (i = 0; i < a->__sizeActivityReference; i++) {
			soap_embedded(soap, a->ActivityReference + i, SOAP_TYPE_wsa__EndpointReferenceType);
			soap_serialize_wsa__EndpointReferenceType(soap, a->ActivityReference + i);
		}
	}
	if (a->ContainedResource) {
		int i;
		for (i = 0; i < a->__sizeContainedResource; i++) {
			soap_embedded(soap, a->ContainedResource + i, SOAP_TYPE_xsd__anyType);
			soap_serialize_xsd__anyType(soap, a->ContainedResource + i);
		}
	}
	if (a->NamingProfile) {
		int i;
		for (i = 0; i < a->__sizeNamingProfile; i++) {
			soap_serialize_xsd__anyURI(soap, a->NamingProfile + i);
		}
	}
	if (a->BESExtension) {
		int i;
		for (i = 0; i < a->__sizeBESExtension; i++) {
			soap_serialize_xsd__anyURI(soap, a->BESExtension + i);
		}
	}
	soap_serialize_xsd__anyURI(soap, &a->LocalResourceManagerType);
	soap_serialize_PointerTohpcp_af__AdvancedFilterType(soap, &a->AdvancedFilter);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__FactoryResourceAttributesDocumentType(struct soap *soap, const struct bes__FactoryResourceAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__FactoryResourceAttributesDocumentType);
	if (soap_out_bes__FactoryResourceAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__FactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, const struct bes__FactoryResourceAttributesDocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__FactoryResourceAttributesDocumentType), type);
	soap_out_PointerTobes__BasicResourceAttributesDocumentType(soap, "bes:BasicResourceAttributesDocument", -1, &a->bes__BasicResourceAttributesDocument, "");
	soap_out_xsd__boolean(soap, "bes:IsAcceptingNewActivities", -1, &a->IsAcceptingNewActivities, "");
	soap_out_string(soap, "bes:CommonName", -1, &a->CommonName, "");
	soap_out_string(soap, "bes:LongDescription", -1, &a->LongDescription, "");
	soap_out_LONG64(soap, "bes:TotalNumberOfActivities", -1, &a->TotalNumberOfActivities, "");
	if (a->ActivityReference) {
		int i;
		for (i = 0; i < a->__sizeActivityReference; i++)
			soap_out_wsa__EndpointReferenceType(soap, "bes:ActivityReference", -1, a->ActivityReference + i, "");
	}
	soap_out_LONG64(soap, "bes:TotalNumberOfContainedResources", -1, &a->TotalNumberOfContainedResources, "");
	if (a->ContainedResource) {
		int i;
		for (i = 0; i < a->__sizeContainedResource; i++)
			soap_out_xsd__anyType(soap, "bes:ContainedResource", -1, a->ContainedResource + i, "");
	}
	if (a->NamingProfile) {
		int i;
		for (i = 0; i < a->__sizeNamingProfile; i++)
			soap_out_xsd__anyURI(soap, "bes:NamingProfile", -1, a->NamingProfile + i, "");
	}
	if (a->BESExtension) {
		int i;
		for (i = 0; i < a->__sizeBESExtension; i++)
			soap_out_xsd__anyURI(soap, "bes:BESExtension", -1, a->BESExtension + i, "");
	}
	soap_out_xsd__anyURI(soap, "bes:LocalResourceManagerType", -1, &a->LocalResourceManagerType, "");
	soap_out_PointerTohpcp_af__AdvancedFilterType(soap, "bes:AdvancedFilter", -1, &a->AdvancedFilter, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_get_bes__FactoryResourceAttributesDocumentType(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__FactoryResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_in_bes__FactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, struct bes__FactoryResourceAttributesDocumentType *a, const char *type)
{
	short soap_flag_bes__BasicResourceAttributesDocument = 1, soap_flag_IsAcceptingNewActivities = 1, soap_flag_CommonName = 1, soap_flag_LongDescription = 1, soap_flag_TotalNumberOfActivities = 1, soap_flag_ActivityReference = 1, soap_flag_TotalNumberOfContainedResources = 1, soap_flag_ContainedResource = 1, soap_flag_NamingProfile = 1, soap_flag_BESExtension = 1, soap_flag_LocalResourceManagerType = 1, soap_flag_AdvancedFilter = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__FactoryResourceAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__FactoryResourceAttributesDocumentType, sizeof(struct bes__FactoryResourceAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__FactoryResourceAttributesDocumentType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__BasicResourceAttributesDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__BasicResourceAttributesDocumentType(soap, "bes:BasicResourceAttributesDocument", &a->bes__BasicResourceAttributesDocument, "bes:BasicResourceAttributesDocumentType")) {
					soap_flag_bes__BasicResourceAttributesDocument--;
					continue;
				}
			if (soap_flag_IsAcceptingNewActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "bes:IsAcceptingNewActivities", &a->IsAcceptingNewActivities, "xsd:boolean")) {
					soap_flag_IsAcceptingNewActivities--;
					continue;
				}
			if (soap_flag_CommonName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:CommonName", &a->CommonName, "xsd:string")) {
					soap_flag_CommonName--;
					continue;
				}
			if (soap_flag_LongDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:LongDescription", &a->LongDescription, "xsd:string")) {
					soap_flag_LongDescription--;
					continue;
				}
			if (soap_flag_TotalNumberOfActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "bes:TotalNumberOfActivities", &a->TotalNumberOfActivities, "xsd:long")) {
					soap_flag_TotalNumberOfActivities--;
					continue;
				}
			if (soap_flag_ActivityReference && soap->error == SOAP_TAG_MISMATCH) {
				struct wsa__EndpointReferenceType *p;
				soap_new_block(soap);
				for (a->__sizeActivityReference = 0; !soap_element_begin_in(soap, "bes:ActivityReference", 1, NULL); a->__sizeActivityReference++) {
					p = (struct wsa__EndpointReferenceType *)soap_push_block(soap, sizeof(struct wsa__EndpointReferenceType));
					soap_default_wsa__EndpointReferenceType(soap, p);
					soap_revert(soap);
					if (!soap_in_wsa__EndpointReferenceType(soap, "bes:ActivityReference", p, "wsa:EndpointReferenceType"))
						break;
					soap_flag_ActivityReference = 0;
				}
				a->ActivityReference = (struct wsa__EndpointReferenceType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ActivityReference && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_TotalNumberOfContainedResources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "bes:TotalNumberOfContainedResources", &a->TotalNumberOfContainedResources, "xsd:long")) {
					soap_flag_TotalNumberOfContainedResources--;
					continue;
				}
			if (soap_flag_ContainedResource && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__sizeContainedResource = 0; !soap_element_begin_in(soap, "bes:ContainedResource", 1, NULL); a->__sizeContainedResource++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					soap_revert(soap);
					if (!soap_in_xsd__anyType(soap, "bes:ContainedResource", p, "xsd:anyType"))
						break;
					soap_flag_ContainedResource = 0;
				}
				a->ContainedResource = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ContainedResource && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_NamingProfile && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeNamingProfile = 0; !soap_element_begin_in(soap, "bes:NamingProfile", 1, NULL); a->__sizeNamingProfile++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "bes:NamingProfile", p, "xsd:anyURI"))
						break;
					soap_flag_NamingProfile = 0;
				}
				a->NamingProfile = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_NamingProfile && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_BESExtension && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeBESExtension = 0; !soap_element_begin_in(soap, "bes:BESExtension", 1, NULL); a->__sizeBESExtension++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "bes:BESExtension", p, "xsd:anyURI"))
						break;
					soap_flag_BESExtension = 0;
				}
				a->BESExtension = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_BESExtension && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_LocalResourceManagerType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "bes:LocalResourceManagerType", &a->LocalResourceManagerType, "xsd:anyURI")) {
					soap_flag_LocalResourceManagerType--;
					continue;
				}
			if (soap_flag_AdvancedFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTohpcp_af__AdvancedFilterType(soap, "bes:AdvancedFilter", &a->AdvancedFilter, "hpcp-af:AdvancedFilterType")) {
					soap_flag_AdvancedFilter--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__FactoryResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__FactoryResourceAttributesDocumentType, 0, sizeof(struct bes__FactoryResourceAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IsAcceptingNewActivities > 0 || soap_flag_TotalNumberOfActivities > 0 || soap_flag_TotalNumberOfContainedResources > 0 || soap_flag_LocalResourceManagerType > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ResourceName);
	a->OperatingSystem = NULL;
	a->CPUArchitecture = NULL;
	a->CPUCount = NULL;
	a->CPUSpeed = NULL;
	a->PhysicalMemory = NULL;
	a->VirtualMemory = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__BasicResourceAttributesDocumentType(struct soap *soap, const struct bes__BasicResourceAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ResourceName);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &a->OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &a->CPUArchitecture);
	soap_serialize_PointerTodouble(soap, &a->CPUCount);
	soap_serialize_PointerTodouble(soap, &a->CPUSpeed);
	soap_serialize_PointerTodouble(soap, &a->PhysicalMemory);
	soap_serialize_PointerTodouble(soap, &a->VirtualMemory);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__BasicResourceAttributesDocumentType(struct soap *soap, const struct bes__BasicResourceAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__BasicResourceAttributesDocumentType);
	if (soap_out_bes__BasicResourceAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__BasicResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, const struct bes__BasicResourceAttributesDocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__BasicResourceAttributesDocumentType), type);
	soap_out_string(soap, "bes:ResourceName", -1, &a->ResourceName, "");
	soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "bes:OperatingSystem", -1, &a->OperatingSystem, "");
	soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "bes:CPUArchitecture", -1, &a->CPUArchitecture, "");
	soap_out_PointerTodouble(soap, "bes:CPUCount", -1, &a->CPUCount, "");
	soap_out_PointerTodouble(soap, "bes:CPUSpeed", -1, &a->CPUSpeed, "");
	soap_out_PointerTodouble(soap, "bes:PhysicalMemory", -1, &a->PhysicalMemory, "");
	soap_out_PointerTodouble(soap, "bes:VirtualMemory", -1, &a->VirtualMemory, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType * SOAP_FMAC4 soap_get_bes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__BasicResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType * SOAP_FMAC4 soap_in_bes__BasicResourceAttributesDocumentType(struct soap *soap, const char *tag, struct bes__BasicResourceAttributesDocumentType *a, const char *type)
{
	short soap_flag_ResourceName = 1, soap_flag_OperatingSystem = 1, soap_flag_CPUArchitecture = 1, soap_flag_CPUCount = 1, soap_flag_CPUSpeed = 1, soap_flag_PhysicalMemory = 1, soap_flag_VirtualMemory = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__BasicResourceAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__BasicResourceAttributesDocumentType, sizeof(struct bes__BasicResourceAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__BasicResourceAttributesDocumentType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:ResourceName", &a->ResourceName, "xsd:string")) {
					soap_flag_ResourceName--;
					continue;
				}
			if (soap_flag_OperatingSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "bes:OperatingSystem", &a->OperatingSystem, "jsdl:OperatingSystem_Type")) {
					soap_flag_OperatingSystem--;
					continue;
				}
			if (soap_flag_CPUArchitecture && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "bes:CPUArchitecture", &a->CPUArchitecture, "jsdl:CPUArchitecture_Type")) {
					soap_flag_CPUArchitecture--;
					continue;
				}
			if (soap_flag_CPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:CPUCount", &a->CPUCount, "xsd:double")) {
					soap_flag_CPUCount--;
					continue;
				}
			if (soap_flag_CPUSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:CPUSpeed", &a->CPUSpeed, "xsd:double")) {
					soap_flag_CPUSpeed--;
					continue;
				}
			if (soap_flag_PhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:PhysicalMemory", &a->PhysicalMemory, "xsd:double")) {
					soap_flag_PhysicalMemory--;
					continue;
				}
			if (soap_flag_VirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:VirtualMemory", &a->VirtualMemory, "xsd:double")) {
					soap_flag_VirtualMemory--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__BasicResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__BasicResourceAttributesDocumentType, 0, sizeof(struct bes__BasicResourceAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeInvalidElement = 0;
	a->InvalidElement = NULL;
	soap_default_string(soap, &a->Message);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__InvalidRequestMessageFaultType(struct soap *soap, const struct bes__InvalidRequestMessageFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->InvalidElement) {
		int i;
		for (i = 0; i < a->__sizeInvalidElement; i++) {
			soap_serialize_string(soap, a->InvalidElement + i);
		}
	}
	soap_serialize_string(soap, &a->Message);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__InvalidRequestMessageFaultType(struct soap *soap, const struct bes__InvalidRequestMessageFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__InvalidRequestMessageFaultType);
	if (soap_out_bes__InvalidRequestMessageFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__InvalidRequestMessageFaultType(struct soap *soap, const char *tag, int id, const struct bes__InvalidRequestMessageFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__InvalidRequestMessageFaultType), type);
	if (a->InvalidElement) {
		int i;
		for (i = 0; i < a->__sizeInvalidElement; i++)
			soap_out_string(soap, "bes:InvalidElement", -1, a->InvalidElement + i, "");
	}
	soap_out_string(soap, "bes:Message", -1, &a->Message, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType * SOAP_FMAC4 soap_get_bes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__InvalidRequestMessageFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType * SOAP_FMAC4 soap_in_bes__InvalidRequestMessageFaultType(struct soap *soap, const char *tag, struct bes__InvalidRequestMessageFaultType *a, const char *type)
{
	short soap_flag_InvalidElement = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__InvalidRequestMessageFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__InvalidRequestMessageFaultType, sizeof(struct bes__InvalidRequestMessageFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__InvalidRequestMessageFaultType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InvalidElement && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeInvalidElement = 0; !soap_element_begin_in(soap, "bes:InvalidElement", 1, NULL); a->__sizeInvalidElement++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "bes:InvalidElement", p, "xsd:string"))
						break;
					soap_flag_InvalidElement = 0;
				}
				a->InvalidElement = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_InvalidElement && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string")) {
					soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__InvalidRequestMessageFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__InvalidRequestMessageFaultType, 0, sizeof(struct bes__InvalidRequestMessageFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__InvalidActivityIdentifierFaultType(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__InvalidActivityIdentifierFaultType(struct soap *soap, const struct bes__InvalidActivityIdentifierFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Message);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__InvalidActivityIdentifierFaultType(struct soap *soap, const struct bes__InvalidActivityIdentifierFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__InvalidActivityIdentifierFaultType);
	if (soap_out_bes__InvalidActivityIdentifierFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__InvalidActivityIdentifierFaultType(struct soap *soap, const char *tag, int id, const struct bes__InvalidActivityIdentifierFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__InvalidActivityIdentifierFaultType), type);
	soap_out_string(soap, "bes:Message", -1, &a->Message, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__InvalidActivityIdentifierFaultType * SOAP_FMAC4 soap_get_bes__InvalidActivityIdentifierFaultType(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__InvalidActivityIdentifierFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidActivityIdentifierFaultType * SOAP_FMAC4 soap_in_bes__InvalidActivityIdentifierFaultType(struct soap *soap, const char *tag, struct bes__InvalidActivityIdentifierFaultType *a, const char *type)
{
	short soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__InvalidActivityIdentifierFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__InvalidActivityIdentifierFaultType, sizeof(struct bes__InvalidActivityIdentifierFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__InvalidActivityIdentifierFaultType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string")) {
					soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__InvalidActivityIdentifierFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__InvalidActivityIdentifierFaultType, 0, sizeof(struct bes__InvalidActivityIdentifierFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityStatus = NULL;
	soap_default_string(soap, &a->Message);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, const struct bes__OperationWillBeAppliedEventuallyFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__ActivityStatusType(soap, &a->ActivityStatus);
	soap_serialize_string(soap, &a->Message);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, const struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType);
	if (soap_out_bes__OperationWillBeAppliedEventuallyFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, const char *tag, int id, const struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType), type);
	soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->ActivityStatus, "");
	soap_out_string(soap, "bes:Message", -1, &a->Message, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__OperationWillBeAppliedEventuallyFaultType * SOAP_FMAC4 soap_get_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__OperationWillBeAppliedEventuallyFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__OperationWillBeAppliedEventuallyFaultType * SOAP_FMAC4 soap_in_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, const char *tag, struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *type)
{
	short soap_flag_ActivityStatus = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__OperationWillBeAppliedEventuallyFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType, sizeof(struct bes__OperationWillBeAppliedEventuallyFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__OperationWillBeAppliedEventuallyFaultType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->ActivityStatus, "bes:ActivityStatusType")) {
					soap_flag_ActivityStatus--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string")) {
					soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__OperationWillBeAppliedEventuallyFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType, 0, sizeof(struct bes__OperationWillBeAppliedEventuallyFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityStatus > 0 || soap_flag_Message > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityStatus = NULL;
	soap_default_string(soap, &a->Message);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, const struct bes__CantApplyOperationToCurrentStateFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__ActivityStatusType(soap, &a->ActivityStatus);
	soap_serialize_string(soap, &a->Message);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, const struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType);
	if (soap_out_bes__CantApplyOperationToCurrentStateFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, const char *tag, int id, const struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType), type);
	soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->ActivityStatus, "");
	soap_out_string(soap, "bes:Message", -1, &a->Message, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__CantApplyOperationToCurrentStateFaultType * SOAP_FMAC4 soap_get_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__CantApplyOperationToCurrentStateFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CantApplyOperationToCurrentStateFaultType * SOAP_FMAC4 soap_in_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, const char *tag, struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *type)
{
	short soap_flag_ActivityStatus = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CantApplyOperationToCurrentStateFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType, sizeof(struct bes__CantApplyOperationToCurrentStateFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__CantApplyOperationToCurrentStateFaultType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->ActivityStatus, "bes:ActivityStatusType")) {
					soap_flag_ActivityStatus--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string")) {
					soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__CantApplyOperationToCurrentStateFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType, 0, sizeof(struct bes__CantApplyOperationToCurrentStateFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityStatus > 0 || soap_flag_Message > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeFeature = 0;
	a->Feature = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__UnsupportedFeatureFaultType(struct soap *soap, const struct bes__UnsupportedFeatureFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Feature) {
		int i;
		for (i = 0; i < a->__sizeFeature; i++) {
			soap_serialize_string(soap, a->Feature + i);
		}
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__UnsupportedFeatureFaultType(struct soap *soap, const struct bes__UnsupportedFeatureFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__UnsupportedFeatureFaultType);
	if (soap_out_bes__UnsupportedFeatureFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, int id, const struct bes__UnsupportedFeatureFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__UnsupportedFeatureFaultType), type);
	if (a->Feature) {
		int i;
		for (i = 0; i < a->__sizeFeature; i++)
			soap_out_string(soap, "bes:Feature", -1, a->Feature + i, "");
	}
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_get_bes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__UnsupportedFeatureFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_in_bes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, struct bes__UnsupportedFeatureFaultType *a, const char *type)
{
	short soap_flag_Feature = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__UnsupportedFeatureFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__UnsupportedFeatureFaultType, sizeof(struct bes__UnsupportedFeatureFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__UnsupportedFeatureFaultType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Feature && soap->error == SOAP_TAG_MISMATCH) {
				char **p;
				soap_new_block(soap);
				for (a->__sizeFeature = 0; !soap_element_begin_in(soap, "bes:Feature", 1, NULL); a->__sizeFeature++) {
					p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "bes:Feature", p, "xsd:string"))
						break;
					soap_flag_Feature = 0;
				}
				a->Feature = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Feature && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__UnsupportedFeatureFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__UnsupportedFeatureFaultType, 0, sizeof(struct bes__UnsupportedFeatureFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const struct bes__NotAcceptingNewActivitiesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const struct bes__NotAcceptingNewActivitiesFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType);
	if (soap_out_bes__NotAcceptingNewActivitiesFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, int id, const struct bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_get_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_in_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, struct bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__NotAcceptingNewActivitiesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__NotAcceptingNewActivitiesFaultType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__NotAcceptingNewActivitiesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType, 0, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__NotAuthorizedFaultType(struct soap *soap, const struct bes__NotAuthorizedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__NotAuthorizedFaultType(struct soap *soap, const struct bes__NotAuthorizedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__NotAuthorizedFaultType);
	if (soap_out_bes__NotAuthorizedFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__NotAuthorizedFaultType(struct soap *soap, const char *tag, int id, const struct bes__NotAuthorizedFaultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__NotAuthorizedFaultType), type);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType * SOAP_FMAC4 soap_get_bes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__NotAuthorizedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType * SOAP_FMAC4 soap_in_bes__NotAuthorizedFaultType(struct soap *soap, const char *tag, struct bes__NotAuthorizedFaultType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__NotAuthorizedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__NotAuthorizedFaultType, sizeof(struct bes__NotAuthorizedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__NotAuthorizedFaultType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__NotAuthorizedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__NotAuthorizedFaultType, 0, sizeof(struct bes__NotAuthorizedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const struct bes__GetFactoryAttributesDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const struct bes__GetFactoryAttributesDocumentResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType);
	if (soap_out_bes__GetFactoryAttributesDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_get_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetFactoryAttributesDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_in_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetFactoryAttributesDocumentResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetFactoryAttributesDocumentResponseType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetFactoryAttributesDocumentResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType, 0, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__GetFactoryAttributesDocumentType(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__GetFactoryAttributesDocumentType(struct soap *soap, const struct bes__GetFactoryAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__GetFactoryAttributesDocumentType(struct soap *soap, const struct bes__GetFactoryAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetFactoryAttributesDocumentType);
	if (soap_out_bes__GetFactoryAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, int id, const struct bes__GetFactoryAttributesDocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetFactoryAttributesDocumentType), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_get_bes__GetFactoryAttributesDocumentType(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetFactoryAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_in_bes__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetFactoryAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetFactoryAttributesDocumentType, sizeof(struct bes__GetFactoryAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetFactoryAttributesDocumentType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetFactoryAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetFactoryAttributesDocumentType, 0, sizeof(struct bes__GetFactoryAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__GetActivityDocumentsResponseType(struct soap *soap, const struct bes__GetActivityDocumentsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__GetActivityDocumentsResponseType(struct soap *soap, const struct bes__GetActivityDocumentsResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityDocumentsResponseType);
	if (soap_out_bes__GetActivityDocumentsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentsResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityDocumentsResponseType), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_get_bes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityDocumentsResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_in_bes__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentsResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityDocumentsResponseType, sizeof(struct bes__GetActivityDocumentsResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityDocumentsResponseType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityDocumentsResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityDocumentsResponseType, 0, sizeof(struct bes__GetActivityDocumentsResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__GetActivityDocumentsType(struct soap *soap, struct bes__GetActivityDocumentsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__GetActivityDocumentsType(struct soap *soap, const struct bes__GetActivityDocumentsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__GetActivityDocumentsType(struct soap *soap, const struct bes__GetActivityDocumentsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityDocumentsType);
	if (soap_out_bes__GetActivityDocumentsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__GetActivityDocumentsType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityDocumentsType), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsType * SOAP_FMAC4 soap_get_bes__GetActivityDocumentsType(struct soap *soap, struct bes__GetActivityDocumentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityDocumentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsType * SOAP_FMAC4 soap_in_bes__GetActivityDocumentsType(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityDocumentsType, sizeof(struct bes__GetActivityDocumentsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityDocumentsType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityDocumentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityDocumentsType, 0, sizeof(struct bes__GetActivityDocumentsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__TerminateActivitiesResponseType(struct soap *soap, const struct bes__TerminateActivitiesResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__TerminateActivitiesResponseType(struct soap *soap, const struct bes__TerminateActivitiesResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__TerminateActivitiesResponseType);
	if (soap_out_bes__TerminateActivitiesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__TerminateActivitiesResponseType(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivitiesResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__TerminateActivitiesResponseType), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType * SOAP_FMAC4 soap_get_bes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__TerminateActivitiesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType * SOAP_FMAC4 soap_in_bes__TerminateActivitiesResponseType(struct soap *soap, const char *tag, struct bes__TerminateActivitiesResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivitiesResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__TerminateActivitiesResponseType, sizeof(struct bes__TerminateActivitiesResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__TerminateActivitiesResponseType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__TerminateActivitiesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__TerminateActivitiesResponseType, 0, sizeof(struct bes__TerminateActivitiesResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__TerminateActivitiesType(struct soap *soap, struct bes__TerminateActivitiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__TerminateActivitiesType(struct soap *soap, const struct bes__TerminateActivitiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__TerminateActivitiesType(struct soap *soap, const struct bes__TerminateActivitiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__TerminateActivitiesType);
	if (soap_out_bes__TerminateActivitiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__TerminateActivitiesType(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivitiesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__TerminateActivitiesType), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__TerminateActivitiesType * SOAP_FMAC4 soap_get_bes__TerminateActivitiesType(struct soap *soap, struct bes__TerminateActivitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__TerminateActivitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesType * SOAP_FMAC4 soap_in_bes__TerminateActivitiesType(struct soap *soap, const char *tag, struct bes__TerminateActivitiesType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivitiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__TerminateActivitiesType, sizeof(struct bes__TerminateActivitiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__TerminateActivitiesType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__TerminateActivitiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__TerminateActivitiesType, 0, sizeof(struct bes__TerminateActivitiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__GetActivityStatusesResponseType(struct soap *soap, const struct bes__GetActivityStatusesResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__GetActivityStatusesResponseType(struct soap *soap, const struct bes__GetActivityStatusesResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityStatusesResponseType);
	if (soap_out_bes__GetActivityStatusesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__GetActivityStatusesResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusesResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityStatusesResponseType), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType * SOAP_FMAC4 soap_get_bes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityStatusesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType * SOAP_FMAC4 soap_in_bes__GetActivityStatusesResponseType(struct soap *soap, const char *tag, struct bes__GetActivityStatusesResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusesResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityStatusesResponseType, sizeof(struct bes__GetActivityStatusesResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityStatusesResponseType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityStatusesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityStatusesResponseType, 0, sizeof(struct bes__GetActivityStatusesResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__GetActivityStatusesType(struct soap *soap, struct bes__GetActivityStatusesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__GetActivityStatusesType(struct soap *soap, const struct bes__GetActivityStatusesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__GetActivityStatusesType(struct soap *soap, const struct bes__GetActivityStatusesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityStatusesType);
	if (soap_out_bes__GetActivityStatusesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__GetActivityStatusesType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityStatusesType), type);
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__GetActivityStatusesType * SOAP_FMAC4 soap_get_bes__GetActivityStatusesType(struct soap *soap, struct bes__GetActivityStatusesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityStatusesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesType * SOAP_FMAC4 soap_in_bes__GetActivityStatusesType(struct soap *soap, const char *tag, struct bes__GetActivityStatusesType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityStatusesType, sizeof(struct bes__GetActivityStatusesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityStatusesType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityStatusesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityStatusesType, 0, sizeof(struct bes__GetActivityStatusesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__CreateActivityResponseType(struct soap *soap, const struct bes__CreateActivityResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__CreateActivityResponseType(struct soap *soap, const struct bes__CreateActivityResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__CreateActivityResponseType);
	if (soap_out_bes__CreateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__CreateActivityResponseType(struct soap *soap, const char *tag, int id, const struct bes__CreateActivityResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__CreateActivityResponseType), type);
	if (a->__any)
		soap_element_result(soap, "-any");
	soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__CreateActivityResponseType * SOAP_FMAC4 soap_get_bes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__CreateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityResponseType * SOAP_FMAC4 soap_in_bes__CreateActivityResponseType(struct soap *soap, const char *tag, struct bes__CreateActivityResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CreateActivityResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__CreateActivityResponseType, sizeof(struct bes__CreateActivityResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__CreateActivityResponseType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType")) {
					soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__CreateActivityResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__CreateActivityResponseType, 0, sizeof(struct bes__CreateActivityResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_bes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__ActivityDocumentType(soap, &a->bes__ActivityDocument);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_bes__CreateActivityType(struct soap *soap, const struct bes__CreateActivityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__ActivityDocumentType(soap, &a->bes__ActivityDocument);
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++) {
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_bes__CreateActivityType(struct soap *soap, const struct bes__CreateActivityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__CreateActivityType);
	if (soap_out_bes__CreateActivityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_bes__CreateActivityType(struct soap *soap, const char *tag, int id, const struct bes__CreateActivityType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__CreateActivityType), type);
	soap_out_bes__ActivityDocumentType(soap, "bes:ActivityDocument", -1, &a->bes__ActivityDocument, "");
	if (a->__any) {
		int i;
		for (i = 0; i < a->__size; i++)
			soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct bes__CreateActivityType * SOAP_FMAC4 soap_get_bes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__CreateActivityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityType * SOAP_FMAC4 soap_in_bes__CreateActivityType(struct soap *soap, const char *tag, struct bes__CreateActivityType *a, const char *type)
{
	short soap_flag_bes__ActivityDocument = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CreateActivityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__CreateActivityType, sizeof(struct bes__CreateActivityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__CreateActivityType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__ActivityDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bes__ActivityDocumentType(soap, "bes:ActivityDocument", &a->bes__ActivityDocument, "bes:ActivityDocumentType")) {
					soap_flag_bes__ActivityDocument--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH) {
				struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++) {
					p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct bes__CreateActivityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__CreateActivityType, 0, sizeof(struct bes__CreateActivityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__ActivityDocument > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (soap_out_xsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type);
	soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, "");
	soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, "");
	soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, "");
	soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	short soap_flag_wsu__Timestamp = 1, soap_flag_UsernameToken = 1, soap_flag_BinarySecurityToken = 1, soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, "")) {
					soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, "")) {
					soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, "")) {
					soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType")) {
					soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type);
	soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, "");
	soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	short soap_flag_Modulus = 1, soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string")) {
					soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string")) {
					soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type);
	soap_out_string(soap, "ds:G", -1, &a->G, "");
	soap_out_string(soap, "ds:Y", -1, &a->Y, "");
	soap_out_string(soap, "ds:J", -1, &a->J, "");
	soap_out_string(soap, "ds:P", -1, &a->P, "");
	soap_out_string(soap, "ds:Q", -1, &a->Q, "");
	soap_out_string(soap, "ds:Seed", -1, &a->Seed, "");
	soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	short soap_flag_G = 1, soap_flag_Y = 1, soap_flag_J = 1, soap_flag_P = 1, soap_flag_Q = 1, soap_flag_Seed = 1, soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string")) {
					soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string")) {
					soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string")) {
					soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string")) {
					soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string")) {
					soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string")) {
					soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string")) {
					soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type);
	soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, "");
	soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	short soap_flag_X509IssuerName = 1, soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string")) {
					soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int")) {
					soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type);
	soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, "");
	soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, "");
	soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, "");
	soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, "");
	soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	short soap_flag_X509IssuerSerial = 1, soap_flag_X509SKI = 1, soap_flag_X509SubjectName = 1, soap_flag_X509Certificate = 1, soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType")) {
					soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string")) {
					soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string")) {
					soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string")) {
					soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string")) {
					soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type);
	soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	short soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType")) {
					soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type);
	soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, "");
	soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	short soap_flag_DSAKeyValue = 1, soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType")) {
					soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType")) {
					soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type);
	soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, "");
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	short soap_flag_c14n__InclusiveNamespaces = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, "")) {
					soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any)) {
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform) {
		int i;
		for (i = 0; i < a->__sizeTransform; i++) {
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type);
	if (a->Transform) {
		int i;
		for (i = 0; i < a->__sizeTransform; i++)
			soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	short soap_flag_Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transform && soap->error == SOAP_TAG_MISMATCH) {
				struct ds__TransformType *p;
				soap_new_block(soap);
				for (a->__sizeTransform = 0; !soap_element_begin_in(soap, "ds:Transform", 1, NULL); a->__sizeTransform++) {
					p = (struct ds__TransformType *)soap_push_block(soap, sizeof(struct ds__TransformType));
					soap_default_ds__TransformType(soap, p);
					soap_revert(soap);
					if (!soap_in_ds__TransformType(soap, "ds:Transform", p, "ds:TransformType"))
						break;
					soap_flag_Transform = 0;
				}
				a->Transform = (struct ds__TransformType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Transform && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type);
	soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, "");
	soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, "");
	soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	short soap_flag_Transforms = 1, soap_flag_DigestMethod = 1, soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType")) {
					soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType")) {
					soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string")) {
					soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type);
	soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	short soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int")) {
					soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type);
	soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	short soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, "")) {
					soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type);
	soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, "");
	soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, "");
	soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, "");
	soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, "");
	soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	short soap_flag_KeyName = 1, soap_flag_KeyValue = 1, soap_flag_RetrievalMethod = 1, soap_flag_X509Data = 1, soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string")) {
					soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType")) {
					soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType")) {
					soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType")) {
					soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, "")) {
					soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference) {
		int i;
		for (i = 0; i < a->__sizeReference; i++) {
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type);
	soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, "");
	soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, "");
	if (a->Reference) {
		int i;
		for (i = 0; i < a->__sizeReference; i++)
			soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	short soap_flag_CanonicalizationMethod = 1, soap_flag_SignatureMethod = 1, soap_flag_Reference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType")) {
					soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType")) {
					soap_flag_SignatureMethod--;
					continue;
				}
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH) {
				struct ds__ReferenceType **p;
				soap_new_block(soap);
				for (a->__sizeReference = 0; !soap_element_begin_in(soap, "ds:Reference", 1, NULL); a->__sizeReference++) {
					p = (struct ds__ReferenceType **)soap_push_block(soap, sizeof(struct ds__ReferenceType *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTods__ReferenceType(soap, "ds:Reference", p, "ds:ReferenceType"))
						break;
					soap_flag_Reference = 0;
				}
				a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type);
	soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, "");
	soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, "");
	soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	short soap_flag_SignedInfo = 1, soap_flag_SignatureValue = 1, soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType")) {
					soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string")) {
					soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType")) {
					soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type);
	soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, "");
	soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, "");
	soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	short soap_flag_Reference = 1, soap_flag_KeyIdentifier = 1, soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, "")) {
					soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, "")) {
					soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, "")) {
					soap_flag_Embedded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type);
	soap_out_string(soap, "wsse:Username", -1, &a->Username, "");
	soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, "");
	soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, "");
	soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	short soap_flag_Username = 1, soap_flag_Password = 1, soap_flag_Nonce = 1, soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string")) {
					soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, "")) {
					soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string")) {
					soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string")) {
					soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type);
	soap_out_string(soap, "wsu:Created", -1, &a->Created, "");
	soap_out_string(soap, "wsu:Expires", -1, &a->Expires, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	short soap_flag_Created = 1, soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href) {
		for (;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string")) {
					soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string")) {
					soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType))
		soap_serialize_bes__GetFactoryAttributesDocumentResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentResponseType);
	if (soap_out_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, int id, struct bes__GetFactoryAttributesDocumentResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__GetFactoryAttributesDocumentResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType ** SOAP_FMAC4 soap_get_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType ** SOAP_FMAC4 soap_in_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__GetFactoryAttributesDocumentResponseType **)soap_malloc(soap, sizeof(struct bes__GetFactoryAttributesDocumentResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__GetFactoryAttributesDocumentResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__GetFactoryAttributesDocumentResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__GetActivityDocumentsResponseType))
		soap_serialize_bes__GetActivityDocumentsResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__GetActivityDocumentsResponseType);
	if (soap_out_PointerTobes__GetActivityDocumentsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, int id, struct bes__GetActivityDocumentsResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__GetActivityDocumentsResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__GetActivityDocumentsResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType ** SOAP_FMAC4 soap_get_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__GetActivityDocumentsResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType ** SOAP_FMAC4 soap_in_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__GetActivityDocumentsResponseType **)soap_malloc(soap, sizeof(struct bes__GetActivityDocumentsResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__GetActivityDocumentsResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityDocumentsResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__GetActivityDocumentsResponseType, sizeof(struct bes__GetActivityDocumentsResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__TerminateActivitiesResponseType))
		soap_serialize_bes__TerminateActivitiesResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__TerminateActivitiesResponseType);
	if (soap_out_PointerTobes__TerminateActivitiesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, const char *tag, int id, struct bes__TerminateActivitiesResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__TerminateActivitiesResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__TerminateActivitiesResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType ** SOAP_FMAC4 soap_get_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__TerminateActivitiesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType ** SOAP_FMAC4 soap_in_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, const char *tag, struct bes__TerminateActivitiesResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__TerminateActivitiesResponseType **)soap_malloc(soap, sizeof(struct bes__TerminateActivitiesResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__TerminateActivitiesResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__TerminateActivitiesResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__TerminateActivitiesResponseType, sizeof(struct bes__TerminateActivitiesResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__GetActivityStatusesResponseType))
		soap_serialize_bes__GetActivityStatusesResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__GetActivityStatusesResponseType);
	if (soap_out_PointerTobes__GetActivityStatusesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, const char *tag, int id, struct bes__GetActivityStatusesResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__GetActivityStatusesResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__GetActivityStatusesResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType ** SOAP_FMAC4 soap_get_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__GetActivityStatusesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType ** SOAP_FMAC4 soap_in_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, const char *tag, struct bes__GetActivityStatusesResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__GetActivityStatusesResponseType **)soap_malloc(soap, sizeof(struct bes__GetActivityStatusesResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__GetActivityStatusesResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__GetActivityStatusesResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__GetActivityStatusesResponseType, sizeof(struct bes__GetActivityStatusesResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__CreateActivityResponseType))
		soap_serialize_bes__CreateActivityResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__CreateActivityResponseType);
	if (soap_out_PointerTobes__CreateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__CreateActivityResponseType(struct soap *soap, const char *tag, int id, struct bes__CreateActivityResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__CreateActivityResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__CreateActivityResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__CreateActivityResponseType ** SOAP_FMAC4 soap_get_PointerTobes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__CreateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityResponseType ** SOAP_FMAC4 soap_in_PointerTobes__CreateActivityResponseType(struct soap *soap, const char *tag, struct bes__CreateActivityResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__CreateActivityResponseType **)soap_malloc(soap, sizeof(struct bes__CreateActivityResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__CreateActivityResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__CreateActivityResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__CreateActivityResponseType, sizeof(struct bes__CreateActivityResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__CreateActivityType))
		soap_serialize_bes__CreateActivityType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__CreateActivityType);
	if (soap_out_PointerTobes__CreateActivityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__CreateActivityType(struct soap *soap, const char *tag, int id, struct bes__CreateActivityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__CreateActivityType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__CreateActivityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__CreateActivityType ** SOAP_FMAC4 soap_get_PointerTobes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__CreateActivityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityType ** SOAP_FMAC4 soap_in_PointerTobes__CreateActivityType(struct soap *soap, const char *tag, struct bes__CreateActivityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__CreateActivityType **)soap_malloc(soap, sizeof(struct bes__CreateActivityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__CreateActivityType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__CreateActivityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__CreateActivityType, sizeof(struct bes__CreateActivityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__UnsupportedFeatureFaultType))
		soap_serialize_bes__UnsupportedFeatureFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__UnsupportedFeatureFaultType);
	if (soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, int id, struct bes__UnsupportedFeatureFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__UnsupportedFeatureFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__UnsupportedFeatureFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType ** SOAP_FMAC4 soap_get_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType ** SOAP_FMAC4 soap_in_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, struct bes__UnsupportedFeatureFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__UnsupportedFeatureFaultType **)soap_malloc(soap, sizeof(struct bes__UnsupportedFeatureFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__UnsupportedFeatureFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__UnsupportedFeatureFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__UnsupportedFeatureFaultType, sizeof(struct bes__UnsupportedFeatureFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__NotAuthorizedFaultType))
		soap_serialize_bes__NotAuthorizedFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__NotAuthorizedFaultType);
	if (soap_out_PointerTobes__NotAuthorizedFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__NotAuthorizedFaultType(struct soap *soap, const char *tag, int id, struct bes__NotAuthorizedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__NotAuthorizedFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__NotAuthorizedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType ** SOAP_FMAC4 soap_get_PointerTobes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__NotAuthorizedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType ** SOAP_FMAC4 soap_in_PointerTobes__NotAuthorizedFaultType(struct soap *soap, const char *tag, struct bes__NotAuthorizedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__NotAuthorizedFaultType **)soap_malloc(soap, sizeof(struct bes__NotAuthorizedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__NotAuthorizedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__NotAuthorizedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__NotAuthorizedFaultType, sizeof(struct bes__NotAuthorizedFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType))
		soap_serialize_bes__NotAcceptingNewActivitiesFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__NotAcceptingNewActivitiesFaultType);
	if (soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, int id, struct bes__NotAcceptingNewActivitiesFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__NotAcceptingNewActivitiesFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType ** SOAP_FMAC4 soap_get_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType ** SOAP_FMAC4 soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, struct bes__NotAcceptingNewActivitiesFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__NotAcceptingNewActivitiesFaultType **)soap_malloc(soap, sizeof(struct bes__NotAcceptingNewActivitiesFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__NotAcceptingNewActivitiesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__InvalidRequestMessageFaultType))
		soap_serialize_bes__InvalidRequestMessageFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__InvalidRequestMessageFaultType);
	if (soap_out_PointerTobes__InvalidRequestMessageFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, const char *tag, int id, struct bes__InvalidRequestMessageFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__InvalidRequestMessageFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__InvalidRequestMessageFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType ** SOAP_FMAC4 soap_get_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__InvalidRequestMessageFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType ** SOAP_FMAC4 soap_in_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, const char *tag, struct bes__InvalidRequestMessageFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__InvalidRequestMessageFaultType **)soap_malloc(soap, sizeof(struct bes__InvalidRequestMessageFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__InvalidRequestMessageFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__InvalidRequestMessageFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__InvalidRequestMessageFaultType, sizeof(struct bes__InvalidRequestMessageFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__FaultTo))
		soap_serialize__wsa__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__FaultTo);
	if (soap_out_PointerTo_wsa__FaultTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsa__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__ReplyTo))
		soap_serialize__wsa__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__ReplyTo);
	if (soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsa__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__From))
		soap_serialize__wsa__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__From);
	if (soap_out_PointerTo_wsa__From(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsa__From(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsa__From(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__RelatesTo))
		soap_serialize__wsa__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__RelatesTo);
	if (soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__RelatesToType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__RelatesToType **)soap_malloc(soap, sizeof(struct wsa__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsa__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct wsa__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__RelatesToType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__URI(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__URI(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__URI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__URI);
	if (soap_out__jsdl__URI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__URI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__URI);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__URI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__URI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__URI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__URI, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__FilesystemName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__FilesystemName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__FilesystemName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__FilesystemName);
	if (soap_out__jsdl__FilesystemName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__FilesystemName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__FilesystemName);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__FilesystemName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__FilesystemName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__FilesystemName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__FilesystemName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__FileName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__FileName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__FileName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__FileName);
	if (soap_out__jsdl__FileName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__FileName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__FileName);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__FileName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__FileName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__FileName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__FileName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__MountPoint(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__MountPoint(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__MountPoint(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__MountPoint);
	if (soap_out__jsdl__MountPoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__MountPoint(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__MountPoint);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__MountPoint(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__MountPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__MountPoint(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__MountPoint, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__OperatingSystemVersion(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__OperatingSystemVersion(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__OperatingSystemVersion(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__OperatingSystemVersion);
	if (soap_out__jsdl__OperatingSystemVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__OperatingSystemVersion(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__OperatingSystemVersion);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__OperatingSystemVersion(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__OperatingSystemVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__OperatingSystemVersion(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__OperatingSystemVersion, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__HostName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__HostName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__HostName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__HostName);
	if (soap_out__jsdl__HostName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__HostName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__HostName);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__HostName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__HostName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__HostName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__HostName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__ApplicationVersion(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__ApplicationVersion(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__ApplicationVersion(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__ApplicationVersion);
	if (soap_out__jsdl__ApplicationVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__ApplicationVersion(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__ApplicationVersion);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__ApplicationVersion(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__ApplicationVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__ApplicationVersion(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__ApplicationVersion, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__ApplicationName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__ApplicationName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__ApplicationName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__ApplicationName);
	if (soap_out__jsdl__ApplicationName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__ApplicationName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__ApplicationName);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__ApplicationName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__ApplicationName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__ApplicationName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__ApplicationName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__JobProject(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__JobProject(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__JobProject(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobProject);
	if (soap_out__jsdl__JobProject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__JobProject(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__JobProject);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__JobProject(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__JobProject(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__JobProject, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__JobAnnotation(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__JobAnnotation(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__JobAnnotation(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobAnnotation);
	if (soap_out__jsdl__JobAnnotation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__JobAnnotation(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__JobAnnotation);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__JobAnnotation(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__JobAnnotation(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__JobAnnotation, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__Description(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__Description(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__Description(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Description);
	if (soap_out__jsdl__Description(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__Description(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__Description);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__Description(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__Description(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__Description, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__jsdl__JobName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__jsdl__JobName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__jsdl__JobName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobName);
	if (soap_out__jsdl__JobName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__jsdl__JobName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__JobName);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__jsdl__JobName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__jsdl__JobName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__JobName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_hpcpa__UserName_USCOREType(struct soap *soap, struct jsdl_hpcpa__UserName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType))
		soap_serialize_jsdl_hpcpa__UserName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_hpcpa__UserName_USCOREType(struct soap *soap, struct jsdl_hpcpa__UserName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_hpcpa__UserName_USCOREType);
	if (soap_out_PointerTojsdl_hpcpa__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_hpcpa__UserName_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_hpcpa__UserName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_hpcpa__UserName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_hpcpa__UserName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_hpcpa__UserName_USCOREType(struct soap *soap, struct jsdl_hpcpa__UserName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_hpcpa__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__UserName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_hpcpa__UserName_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__UserName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_hpcpa__UserName_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_hpcpa__UserName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_hpcpa__UserName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_hpcpa__UserName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_hpcpa__UserName_USCOREType, sizeof(struct jsdl_hpcpa__UserName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_hpcpa__Environment_USCOREType(struct soap *soap, struct jsdl_hpcpa__Environment_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType))
		soap_serialize_jsdl_hpcpa__Environment_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_hpcpa__Environment_USCOREType(struct soap *soap, struct jsdl_hpcpa__Environment_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_hpcpa__Environment_USCOREType);
	if (soap_out_PointerTojsdl_hpcpa__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_hpcpa__Environment_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_hpcpa__Environment_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_hpcpa__Environment_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_hpcpa__Environment_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_hpcpa__Environment_USCOREType(struct soap *soap, struct jsdl_hpcpa__Environment_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_hpcpa__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__Environment_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_hpcpa__Environment_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__Environment_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_hpcpa__Environment_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_hpcpa__Environment_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_hpcpa__Environment_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_hpcpa__Environment_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_hpcpa__Environment_USCOREType, sizeof(struct jsdl_hpcpa__Environment_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, struct jsdl_hpcpa__DirectoryName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType))
		soap_serialize_jsdl_hpcpa__DirectoryName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, struct jsdl_hpcpa__DirectoryName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_hpcpa__DirectoryName_USCOREType);
	if (soap_out_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_hpcpa__DirectoryName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_hpcpa__DirectoryName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_hpcpa__DirectoryName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, struct jsdl_hpcpa__DirectoryName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_hpcpa__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__DirectoryName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_hpcpa__DirectoryName_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__DirectoryName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_hpcpa__DirectoryName_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_hpcpa__DirectoryName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_hpcpa__DirectoryName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_hpcpa__DirectoryName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_hpcpa__DirectoryName_USCOREType, sizeof(struct jsdl_hpcpa__DirectoryName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_hpcpa__Argument_USCOREType(struct soap *soap, struct jsdl_hpcpa__Argument_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType))
		soap_serialize_jsdl_hpcpa__Argument_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_hpcpa__Argument_USCOREType(struct soap *soap, struct jsdl_hpcpa__Argument_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_hpcpa__Argument_USCOREType);
	if (soap_out_PointerTojsdl_hpcpa__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_hpcpa__Argument_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_hpcpa__Argument_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_hpcpa__Argument_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_hpcpa__Argument_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_hpcpa__Argument_USCOREType(struct soap *soap, struct jsdl_hpcpa__Argument_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_hpcpa__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__Argument_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_hpcpa__Argument_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__Argument_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_hpcpa__Argument_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_hpcpa__Argument_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_hpcpa__Argument_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_hpcpa__Argument_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_hpcpa__Argument_USCOREType, sizeof(struct jsdl_hpcpa__Argument_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_hpcpa__FileName_USCOREType(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType))
		soap_serialize_jsdl_hpcpa__FileName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_hpcpa__FileName_USCOREType(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_hpcpa__FileName_USCOREType);
	if (soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_hpcpa__FileName_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_hpcpa__FileName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_hpcpa__FileName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_hpcpa__FileName_USCOREType(struct soap *soap, struct jsdl_hpcpa__FileName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_hpcpa__FileName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_hpcpa__FileName_USCOREType(struct soap *soap, const char *tag, struct jsdl_hpcpa__FileName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_hpcpa__FileName_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_hpcpa__FileName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_hpcpa__FileName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_hpcpa__FileName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_hpcpa__FileName_USCOREType, sizeof(struct jsdl_hpcpa__FileName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_posix__GroupName_USCOREType(struct soap *soap, struct jsdl_posix__GroupName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_posix__GroupName_USCOREType))
		soap_serialize_jsdl_posix__GroupName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_posix__GroupName_USCOREType(struct soap *soap, struct jsdl_posix__GroupName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_posix__GroupName_USCOREType);
	if (soap_out_PointerTojsdl_posix__GroupName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_posix__GroupName_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_posix__GroupName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_posix__GroupName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_posix__GroupName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_posix__GroupName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_posix__GroupName_USCOREType(struct soap *soap, struct jsdl_posix__GroupName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_posix__GroupName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__GroupName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_posix__GroupName_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__GroupName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_posix__GroupName_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_posix__GroupName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_posix__GroupName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__GroupName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_posix__GroupName_USCOREType, sizeof(struct jsdl_posix__GroupName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_posix__UserName_USCOREType(struct soap *soap, struct jsdl_posix__UserName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_posix__UserName_USCOREType))
		soap_serialize_jsdl_posix__UserName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_posix__UserName_USCOREType(struct soap *soap, struct jsdl_posix__UserName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_posix__UserName_USCOREType);
	if (soap_out_PointerTojsdl_posix__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_posix__UserName_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_posix__UserName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_posix__UserName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_posix__UserName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_posix__UserName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_posix__UserName_USCOREType(struct soap *soap, struct jsdl_posix__UserName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_posix__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__UserName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_posix__UserName_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__UserName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_posix__UserName_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_posix__UserName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_posix__UserName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__UserName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_posix__UserName_USCOREType, sizeof(struct jsdl_posix__UserName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_posix__Limits_USCOREType(struct soap *soap, struct jsdl_posix__Limits_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_posix__Limits_USCOREType))
		soap_serialize_jsdl_posix__Limits_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_posix__Limits_USCOREType(struct soap *soap, struct jsdl_posix__Limits_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_posix__Limits_USCOREType);
	if (soap_out_PointerTojsdl_posix__Limits_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_posix__Limits_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_posix__Limits_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_posix__Limits_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_posix__Limits_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_posix__Limits_USCOREType(struct soap *soap, struct jsdl_posix__Limits_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_posix__Limits_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Limits_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_posix__Limits_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__Limits_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_posix__Limits_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_posix__Limits_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_posix__Limits_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__Limits_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_posix__Limits_USCOREType, sizeof(struct jsdl_posix__Limits_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_posix__Environment_USCOREType(struct soap *soap, struct jsdl_posix__Environment_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_posix__Environment_USCOREType))
		soap_serialize_jsdl_posix__Environment_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_posix__Environment_USCOREType(struct soap *soap, struct jsdl_posix__Environment_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_posix__Environment_USCOREType);
	if (soap_out_PointerTojsdl_posix__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_posix__Environment_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_posix__Environment_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_posix__Environment_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_posix__Environment_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_posix__Environment_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_posix__Environment_USCOREType(struct soap *soap, struct jsdl_posix__Environment_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_posix__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Environment_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_posix__Environment_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__Environment_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_posix__Environment_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_posix__Environment_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_posix__Environment_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__Environment_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_posix__Environment_USCOREType, sizeof(struct jsdl_posix__Environment_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_posix__DirectoryName_USCOREType(struct soap *soap, struct jsdl_posix__DirectoryName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType))
		soap_serialize_jsdl_posix__DirectoryName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_posix__DirectoryName_USCOREType(struct soap *soap, struct jsdl_posix__DirectoryName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_posix__DirectoryName_USCOREType);
	if (soap_out_PointerTojsdl_posix__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_posix__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_posix__DirectoryName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_posix__DirectoryName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_posix__DirectoryName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_posix__DirectoryName_USCOREType(struct soap *soap, struct jsdl_posix__DirectoryName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_posix__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__DirectoryName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_posix__DirectoryName_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__DirectoryName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_posix__DirectoryName_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_posix__DirectoryName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_posix__DirectoryName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__DirectoryName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_posix__DirectoryName_USCOREType, sizeof(struct jsdl_posix__DirectoryName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_posix__Argument_USCOREType(struct soap *soap, struct jsdl_posix__Argument_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_posix__Argument_USCOREType))
		soap_serialize_jsdl_posix__Argument_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_posix__Argument_USCOREType(struct soap *soap, struct jsdl_posix__Argument_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_posix__Argument_USCOREType);
	if (soap_out_PointerTojsdl_posix__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_posix__Argument_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_posix__Argument_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_posix__Argument_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_posix__Argument_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_posix__Argument_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_posix__Argument_USCOREType(struct soap *soap, struct jsdl_posix__Argument_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_posix__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__Argument_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_posix__Argument_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__Argument_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_posix__Argument_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_posix__Argument_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_posix__Argument_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__Argument_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_posix__Argument_USCOREType, sizeof(struct jsdl_posix__Argument_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl_posix__FileName_USCOREType(struct soap *soap, struct jsdl_posix__FileName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl_posix__FileName_USCOREType))
		soap_serialize_jsdl_posix__FileName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl_posix__FileName_USCOREType(struct soap *soap, struct jsdl_posix__FileName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl_posix__FileName_USCOREType);
	if (soap_out_PointerTojsdl_posix__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl_posix__FileName_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl_posix__FileName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl_posix__FileName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl_posix__FileName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl_posix__FileName_USCOREType(struct soap *soap, struct jsdl_posix__FileName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl_posix__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl_posix__FileName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl_posix__FileName_USCOREType(struct soap *soap, const char *tag, struct jsdl_posix__FileName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl_posix__FileName_USCOREType **)soap_malloc(soap, sizeof(struct jsdl_posix__FileName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl_posix__FileName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl_posix__FileName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl_posix__FileName_USCOREType, sizeof(struct jsdl_posix__FileName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTohpcp_af__NodeStatusType(struct soap *soap, struct hpcp_af__NodeStatusType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_hpcp_af__NodeStatusType))
		soap_serialize_hpcp_af__NodeStatusType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTohpcp_af__NodeStatusType(struct soap *soap, struct hpcp_af__NodeStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTohpcp_af__NodeStatusType);
	if (soap_out_PointerTohpcp_af__NodeStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTohpcp_af__NodeStatusType(struct soap *soap, const char *tag, int id, struct hpcp_af__NodeStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_hpcp_af__NodeStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_hpcp_af__NodeStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct hpcp_af__NodeStatusType ** SOAP_FMAC4 soap_get_PointerTohpcp_af__NodeStatusType(struct soap *soap, struct hpcp_af__NodeStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohpcp_af__NodeStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__NodeStatusType ** SOAP_FMAC4 soap_in_PointerTohpcp_af__NodeStatusType(struct soap *soap, const char *tag, struct hpcp_af__NodeStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct hpcp_af__NodeStatusType **)soap_malloc(soap, sizeof(struct hpcp_af__NodeStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_hpcp_af__NodeStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct hpcp_af__NodeStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_hpcp_af__NodeStatusType, sizeof(struct hpcp_af__NodeStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTohpcp_af__ActivityIdType(struct soap *soap, struct hpcp_af__ActivityIdType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_hpcp_af__ActivityIdType))
		soap_serialize_hpcp_af__ActivityIdType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTohpcp_af__ActivityIdType(struct soap *soap, struct hpcp_af__ActivityIdType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTohpcp_af__ActivityIdType);
	if (soap_out_PointerTohpcp_af__ActivityIdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTohpcp_af__ActivityIdType(struct soap *soap, const char *tag, int id, struct hpcp_af__ActivityIdType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_hpcp_af__ActivityIdType);
	if (id < 0)
		return soap->error;
	return soap_out_hpcp_af__ActivityIdType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct hpcp_af__ActivityIdType ** SOAP_FMAC4 soap_get_PointerTohpcp_af__ActivityIdType(struct soap *soap, struct hpcp_af__ActivityIdType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohpcp_af__ActivityIdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__ActivityIdType ** SOAP_FMAC4 soap_in_PointerTohpcp_af__ActivityIdType(struct soap *soap, const char *tag, struct hpcp_af__ActivityIdType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct hpcp_af__ActivityIdType **)soap_malloc(soap, sizeof(struct hpcp_af__ActivityIdType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_hpcp_af__ActivityIdType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct hpcp_af__ActivityIdType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_hpcp_af__ActivityIdType, sizeof(struct hpcp_af__ActivityIdType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTohpcp_af__CPUType(struct soap *soap, struct hpcp_af__CPUType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_hpcp_af__CPUType))
		soap_serialize_hpcp_af__CPUType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTohpcp_af__CPUType(struct soap *soap, struct hpcp_af__CPUType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTohpcp_af__CPUType);
	if (soap_out_PointerTohpcp_af__CPUType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTohpcp_af__CPUType(struct soap *soap, const char *tag, int id, struct hpcp_af__CPUType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_hpcp_af__CPUType);
	if (id < 0)
		return soap->error;
	return soap_out_hpcp_af__CPUType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct hpcp_af__CPUType ** SOAP_FMAC4 soap_get_PointerTohpcp_af__CPUType(struct soap *soap, struct hpcp_af__CPUType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohpcp_af__CPUType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__CPUType ** SOAP_FMAC4 soap_in_PointerTohpcp_af__CPUType(struct soap *soap, const char *tag, struct hpcp_af__CPUType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct hpcp_af__CPUType **)soap_malloc(soap, sizeof(struct hpcp_af__CPUType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_hpcp_af__CPUType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct hpcp_af__CPUType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_hpcp_af__CPUType, sizeof(struct hpcp_af__CPUType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTohpcp_af__MemoryType(struct soap *soap, struct hpcp_af__MemoryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_hpcp_af__MemoryType))
		soap_serialize_hpcp_af__MemoryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTohpcp_af__MemoryType(struct soap *soap, struct hpcp_af__MemoryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTohpcp_af__MemoryType);
	if (soap_out_PointerTohpcp_af__MemoryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTohpcp_af__MemoryType(struct soap *soap, const char *tag, int id, struct hpcp_af__MemoryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_hpcp_af__MemoryType);
	if (id < 0)
		return soap->error;
	return soap_out_hpcp_af__MemoryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct hpcp_af__MemoryType ** SOAP_FMAC4 soap_get_PointerTohpcp_af__MemoryType(struct soap *soap, struct hpcp_af__MemoryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohpcp_af__MemoryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__MemoryType ** SOAP_FMAC4 soap_in_PointerTohpcp_af__MemoryType(struct soap *soap, const char *tag, struct hpcp_af__MemoryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct hpcp_af__MemoryType **)soap_malloc(soap, sizeof(struct hpcp_af__MemoryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_hpcp_af__MemoryType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct hpcp_af__MemoryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_hpcp_af__MemoryType, sizeof(struct hpcp_af__MemoryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTohpcp_af__DateTimeRangeType(struct soap *soap, struct hpcp_af__DateTimeRangeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_hpcp_af__DateTimeRangeType))
		soap_serialize_hpcp_af__DateTimeRangeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTohpcp_af__DateTimeRangeType(struct soap *soap, struct hpcp_af__DateTimeRangeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTohpcp_af__DateTimeRangeType);
	if (soap_out_PointerTohpcp_af__DateTimeRangeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTohpcp_af__DateTimeRangeType(struct soap *soap, const char *tag, int id, struct hpcp_af__DateTimeRangeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_hpcp_af__DateTimeRangeType);
	if (id < 0)
		return soap->error;
	return soap_out_hpcp_af__DateTimeRangeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct hpcp_af__DateTimeRangeType ** SOAP_FMAC4 soap_get_PointerTohpcp_af__DateTimeRangeType(struct soap *soap, struct hpcp_af__DateTimeRangeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohpcp_af__DateTimeRangeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__DateTimeRangeType ** SOAP_FMAC4 soap_in_PointerTohpcp_af__DateTimeRangeType(struct soap *soap, const char *tag, struct hpcp_af__DateTimeRangeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct hpcp_af__DateTimeRangeType **)soap_malloc(soap, sizeof(struct hpcp_af__DateTimeRangeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_hpcp_af__DateTimeRangeType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct hpcp_af__DateTimeRangeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_hpcp_af__DateTimeRangeType, sizeof(struct hpcp_af__DateTimeRangeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTohpcp_af__ActivityIdRangeType(struct soap *soap, struct hpcp_af__ActivityIdRangeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_hpcp_af__ActivityIdRangeType))
		soap_serialize_hpcp_af__ActivityIdRangeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTohpcp_af__ActivityIdRangeType(struct soap *soap, struct hpcp_af__ActivityIdRangeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTohpcp_af__ActivityIdRangeType);
	if (soap_out_PointerTohpcp_af__ActivityIdRangeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTohpcp_af__ActivityIdRangeType(struct soap *soap, const char *tag, int id, struct hpcp_af__ActivityIdRangeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_hpcp_af__ActivityIdRangeType);
	if (id < 0)
		return soap->error;
	return soap_out_hpcp_af__ActivityIdRangeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct hpcp_af__ActivityIdRangeType ** SOAP_FMAC4 soap_get_PointerTohpcp_af__ActivityIdRangeType(struct soap *soap, struct hpcp_af__ActivityIdRangeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohpcp_af__ActivityIdRangeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__ActivityIdRangeType ** SOAP_FMAC4 soap_in_PointerTohpcp_af__ActivityIdRangeType(struct soap *soap, const char *tag, struct hpcp_af__ActivityIdRangeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct hpcp_af__ActivityIdRangeType **)soap_malloc(soap, sizeof(struct hpcp_af__ActivityIdRangeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_hpcp_af__ActivityIdRangeType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct hpcp_af__ActivityIdRangeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_hpcp_af__ActivityIdRangeType, sizeof(struct hpcp_af__ActivityIdRangeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__ActivityStateEnumeration(struct soap *soap, enum bes__ActivityStateEnumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bes__ActivityStateEnumeration);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__ActivityStateEnumeration(struct soap *soap, enum bes__ActivityStateEnumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__ActivityStateEnumeration);
	if (soap_out_PointerTobes__ActivityStateEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__ActivityStateEnumeration(struct soap *soap, const char *tag, int id, enum bes__ActivityStateEnumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__ActivityStateEnumeration);
	if (id < 0)
		return soap->error;
	return soap_out_bes__ActivityStateEnumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum bes__ActivityStateEnumeration ** SOAP_FMAC4 soap_get_PointerTobes__ActivityStateEnumeration(struct soap *soap, enum bes__ActivityStateEnumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__ActivityStateEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum bes__ActivityStateEnumeration ** SOAP_FMAC4 soap_in_PointerTobes__ActivityStateEnumeration(struct soap *soap, const char *tag, enum bes__ActivityStateEnumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum bes__ActivityStateEnumeration **)soap_malloc(soap, sizeof(enum bes__ActivityStateEnumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__ActivityStateEnumeration(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum bes__ActivityStateEnumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__ActivityStateEnumeration, sizeof(enum bes__ActivityStateEnumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__SourceTarget_USCOREType))
		soap_serialize_jsdl__SourceTarget_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType);
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__SourceTarget_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__SourceTarget_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, struct jsdl__SourceTarget_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__SourceTarget_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__SourceTarget_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__SourceTarget_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__SourceTarget_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__SourceTarget_USCOREType, sizeof(struct jsdl__SourceTarget_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType))
		soap_serialize_jsdl__OperatingSystemType_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__OperatingSystemType_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, struct jsdl__OperatingSystemType_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__OperatingSystemType_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__OperatingSystemType_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__OperatingSystemType_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration);
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, enum jsdl__FileSystemTypeEnumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum jsdl__FileSystemTypeEnumeration **)soap_malloc(soap, sizeof(enum jsdl__FileSystemTypeEnumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum jsdl__FileSystemTypeEnumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__RangeValue_USCOREType))
		soap_serialize_jsdl__RangeValue_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType);
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__RangeValue_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__RangeValue_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__RangeValue_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__RangeValue_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__RangeValue_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__RangeValue_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__RangeValue_USCOREType, sizeof(struct jsdl__RangeValue_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__FileSystem_USCOREType))
		soap_serialize_jsdl__FileSystem_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType);
	if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__FileSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__FileSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, struct jsdl__FileSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__FileSystem_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__FileSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__FileSystem_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__FileSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__FileSystem_USCOREType, sizeof(struct jsdl__FileSystem_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType))
		soap_serialize_jsdl__CandidateHosts_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType);
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__CandidateHosts_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__CandidateHosts_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, struct jsdl__CandidateHosts_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__CandidateHosts_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__CandidateHosts_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__CandidateHosts_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, sizeof(struct jsdl__CandidateHosts_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__DataStaging_USCOREType))
		soap_serialize_jsdl__DataStaging_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType);
	if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__DataStaging_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__DataStaging_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, struct jsdl__DataStaging_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__DataStaging_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__DataStaging_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__DataStaging_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__DataStaging_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__DataStaging_USCOREType, sizeof(struct jsdl__DataStaging_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Resources_USCOREType))
		soap_serialize_jsdl__Resources_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Resources_USCOREType);
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Resources_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Resources_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Resources_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, struct jsdl__Resources_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Resources_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Resources_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__Resources_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__Resources_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Resources_USCOREType, sizeof(struct jsdl__Resources_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Application_USCOREType))
		soap_serialize_jsdl__Application_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Application_USCOREType);
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Application_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Application_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Application_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Application_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Application_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, struct jsdl__Application_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Application_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Application_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__Application_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__Application_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Application_USCOREType, sizeof(struct jsdl__Application_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobIdentification_USCOREType))
		soap_serialize_jsdl__JobIdentification_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType);
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__JobIdentification_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobIdentification_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobIdentification_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__JobIdentification_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__JobIdentification_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__JobIdentification_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__JobIdentification_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobIdentification_USCOREType, sizeof(struct jsdl__JobIdentification_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobDescription_USCOREType))
		soap_serialize_jsdl__JobDescription_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType);
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__JobDescription_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobDescription_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobDescription_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__JobDescription_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__JobDescription_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__JobDescription_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__JobDescription_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobDescription_USCOREType, sizeof(struct jsdl__JobDescription_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Range_USCOREType))
		soap_serialize_jsdl__Range_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Range_USCOREType);
	if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Range_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Range_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Range_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Range_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Range_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, struct jsdl__Range_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Range_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Range_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__Range_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__Range_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Range_USCOREType, sizeof(struct jsdl__Range_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Exact_USCOREType))
		soap_serialize_jsdl__Exact_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Exact_USCOREType);
	if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Exact_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Exact_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Exact_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, struct jsdl__Exact_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Exact_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Exact_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__Exact_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__Exact_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Exact_USCOREType, sizeof(struct jsdl__Exact_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Boundary_USCOREType))
		soap_serialize_jsdl__Boundary_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Boundary_USCOREType);
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Boundary_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Boundary_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Boundary_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, struct jsdl__Boundary_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Boundary_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Boundary_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__Boundary_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__Boundary_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Boundary_USCOREType, sizeof(struct jsdl__Boundary_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTowsa__MetadataType(struct soap *soap, struct wsa__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__MetadataType))
		soap_serialize_wsa__MetadataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTowsa__MetadataType(struct soap *soap, struct wsa__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__MetadataType);
	if (soap_out_PointerTowsa__MetadataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTowsa__MetadataType(struct soap *soap, const char *tag, int id, struct wsa__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa__MetadataType(struct soap *soap, struct wsa__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa__MetadataType(struct soap *soap, const char *tag, struct wsa__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__MetadataType **)soap_malloc(soap, sizeof(struct wsa__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_wsa__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct wsa__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__MetadataType, sizeof(struct wsa__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		soap_serialize_wsa__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ReferenceParametersType);
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTowsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__AttributedURIType))
		soap_serialize_wsa__AttributedURIType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTowsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__AttributedURIType);
	if (soap_out_PointerTowsa__AttributedURIType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTowsa__AttributedURIType(struct soap *soap, const char *tag, int id, struct wsa__AttributedURIType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__AttributedURIType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__AttributedURIType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__AttributedURIType ** SOAP_FMAC4 soap_get_PointerTowsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType ** SOAP_FMAC4 soap_in_PointerTowsa__AttributedURIType(struct soap *soap, const char *tag, struct wsa__AttributedURIType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__AttributedURIType **)soap_malloc(soap, sizeof(struct wsa__AttributedURIType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_wsa__AttributedURIType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct wsa__AttributedURIType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__AttributedURIType, sizeof(struct wsa__AttributedURIType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobDefinition_USCOREType))
		soap_serialize_jsdl__JobDefinition_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType);
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__JobDefinition_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobDefinition_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobDefinition_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__JobDefinition_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__JobDefinition_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__JobDefinition_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__JobDefinition_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobDefinition_USCOREType, sizeof(struct jsdl__JobDefinition_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTohpcp_af__AdvancedFilterType(struct soap *soap, struct hpcp_af__AdvancedFilterType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_hpcp_af__AdvancedFilterType))
		soap_serialize_hpcp_af__AdvancedFilterType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTohpcp_af__AdvancedFilterType(struct soap *soap, struct hpcp_af__AdvancedFilterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTohpcp_af__AdvancedFilterType);
	if (soap_out_PointerTohpcp_af__AdvancedFilterType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTohpcp_af__AdvancedFilterType(struct soap *soap, const char *tag, int id, struct hpcp_af__AdvancedFilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_hpcp_af__AdvancedFilterType);
	if (id < 0)
		return soap->error;
	return soap_out_hpcp_af__AdvancedFilterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct hpcp_af__AdvancedFilterType ** SOAP_FMAC4 soap_get_PointerTohpcp_af__AdvancedFilterType(struct soap *soap, struct hpcp_af__AdvancedFilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohpcp_af__AdvancedFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct hpcp_af__AdvancedFilterType ** SOAP_FMAC4 soap_in_PointerTohpcp_af__AdvancedFilterType(struct soap *soap, const char *tag, struct hpcp_af__AdvancedFilterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct hpcp_af__AdvancedFilterType **)soap_malloc(soap, sizeof(struct hpcp_af__AdvancedFilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_hpcp_af__AdvancedFilterType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct hpcp_af__AdvancedFilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_hpcp_af__AdvancedFilterType, sizeof(struct hpcp_af__AdvancedFilterType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4
soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4
soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTowsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__EndpointReferenceType))
		soap_serialize_wsa__EndpointReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTowsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__EndpointReferenceType);
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTowsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_wsa__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__BasicResourceAttributesDocumentType))
		soap_serialize_bes__BasicResourceAttributesDocumentType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__BasicResourceAttributesDocumentType);
	if (soap_out_PointerTobes__BasicResourceAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, struct bes__BasicResourceAttributesDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__BasicResourceAttributesDocumentType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__BasicResourceAttributesDocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType ** SOAP_FMAC4 soap_get_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__BasicResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType ** SOAP_FMAC4 soap_in_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, const char *tag, struct bes__BasicResourceAttributesDocumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__BasicResourceAttributesDocumentType **)soap_malloc(soap, sizeof(struct bes__BasicResourceAttributesDocumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__BasicResourceAttributesDocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__BasicResourceAttributesDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__BasicResourceAttributesDocumentType, sizeof(struct bes__BasicResourceAttributesDocumentType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4
soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4
soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType))
		soap_serialize_jsdl__CPUArchitecture_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType);
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__CPUArchitecture_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, struct jsdl__CPUArchitecture_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__CPUArchitecture_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__CPUArchitecture_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__CPUArchitecture_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType))
		soap_serialize_jsdl__OperatingSystem_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__OperatingSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__OperatingSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, struct jsdl__OperatingSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__OperatingSystem_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__OperatingSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct jsdl__OperatingSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, sizeof(struct jsdl__OperatingSystem_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTobes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__ActivityStatusType))
		soap_serialize_bes__ActivityStatusType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTobes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__ActivityStatusType);
	if (soap_out_PointerTobes__ActivityStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTobes__ActivityStatusType(struct soap *soap, const char *tag, int id, struct bes__ActivityStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__ActivityStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__ActivityStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__ActivityStatusType ** SOAP_FMAC4 soap_get_PointerTobes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__ActivityStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityStatusType ** SOAP_FMAC4 soap_in_PointerTobes__ActivityStatusType(struct soap *soap, const char *tag, struct bes__ActivityStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__ActivityStatusType **)soap_malloc(soap, sizeof(struct bes__ActivityStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_bes__ActivityStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct bes__ActivityStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__ActivityStatusType, sizeof(struct bes__ActivityStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4
soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4
soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_jsdl__Description_USCOREType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_jsdl__Description_USCOREType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_jsdl__Description_USCOREType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Description_USCOREType);
	if (soap_out_jsdl__Description_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_jsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_jsdl__Description_USCOREType);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_jsdl__Description_USCOREType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_jsdl__Description_USCOREType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_jsdl__Description_USCOREType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__FaultCodesOpenEnumType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__FaultCodesOpenEnumType);
	if (soap_out_wsa__FaultCodesOpenEnumType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_wsa__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_wsa__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wsa__FaultCodesOpenEnumType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_wsa__RelationshipTypeOpenEnum(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_wsa__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_wsa__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__RelationshipTypeOpenEnum);
	if (soap_out_wsa__RelationshipTypeOpenEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_wsa__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_wsa__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_wsa__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wsa__RelationshipTypeOpenEnum, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		soap_serialize_xsd__anyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, struct soap_dom_element *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct soap_dom_element ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct soap_dom_element ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, struct soap_dom_element **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct soap_dom_element **)soap_malloc(soap, sizeof(struct soap_dom_element *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_xsd__anyType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct soap_dom_element **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(struct soap_dom_element), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_xsd__normalizedString(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_xsd__normalizedString(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_xsd__normalizedString(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__normalizedString);
	if (soap_out_xsd__normalizedString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_xsd__normalizedString(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__normalizedString);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_xsd__normalizedString(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__normalizedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_xsd__normalizedString(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__normalizedString, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_xsd__nonNegativeInteger(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_xsd__anyURI(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_xsd__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_xsd__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_xsd__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_xsd__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_xsd__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_xsd__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_xsd__NCName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_xsd__ID(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_xsd__ID(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_xsd__ID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_xsd__ID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__ID);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_xsd__ID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_xsd__ID(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__ID, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4
soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4
soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4
soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4
soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

#ifdef __cplusplus
}
#endif

/* End of soapC.c */
