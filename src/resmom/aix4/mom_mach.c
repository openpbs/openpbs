/*
 * Copyright (C) 1994-2017 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *  
 * This file is part of the PBS Professional ("PBS Pro") software.
 * 
 * Open Source License Information:
 *  
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free 
 * Software Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *  
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.
 *  
 * You should have received a copy of the GNU Affero General Public License along 
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *  
 * Commercial License Information: 
 * 
 * The PBS Pro software is licensed under the terms of the GNU Affero General 
 * Public License agreement ("AGPL"), except where a separate commercial license 
 * agreement for PBS Pro version 14 or later has been executed in writing with Altair.
 *  
 * Altair’s dual-license business model allows companies, individuals, and 
 * organizations to create proprietary derivative works of PBS Pro and distribute 
 * them - whether embedded or bundled with other software - under a commercial 
 * license agreement.
 * 
 * Use of Altair’s trademarks, including but not limited to "PBS™", 
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's 
 * trademark licensing policies.
 *
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <ctype.h>
#include <procinfo.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <sys/uio.h>
#include <pwd.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/statfs.h>
#include <sys/vminfo.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <nlist.h>
#include <cf.h>
#include <sys/cfgodm.h>
#include <sys/systemcfg.h>

#include "pbs_error.h"
#include "portability.h"
#include "list_link.h"
#include "server_limits.h"
#include "attribute.h"
#include "resource.h"
#include "job.h"
#include "log.h"
#include "resmon.h"
#include "mom_func.h"
#include "../rm_dep.h"
#include "mom_mach.h"
#if	IBM_HPS
#include <ntbl.h>
#include "dis.h"
#include "avltree.h"
#elif	IBM_AIXIB
#include <nrt.h>
#include <rsct/ct_adapter_types.h>
#include "dis.h"
#include "avltree.h"
#include "mom_server.h"
#endif	/* IBM_HPS || IBM_AIXIB */
#include "placementsets.h"
#include "mom_vnode.h"
#include "rpp.h"

/**
 * @file
 * @brief
 *	System dependent code to gather information for the resource
 *	monitor for an IBM 590 running AIX4.
 *
 * @par	Resources known by this code:
 *		cput		cpu time for a pid or session
 *		mem		memory size for a pid or session in KB
 *		ncpus		number of cpus
 *		resi		resident memory size for a pid or session in KB
 *		sessions	list of sessions in the system
 *		pids		list of pids in a session
 *		nsessions	number of sessions in the system
 *		nusers		number of users in the system
 *		totmem		total memory size in KB
 *		availmem	available memory size in KB
 *		size		size of a file or filesystem in KB
 *		idletime	seconds of idle time (see mom_main.c)
 *		walltime	wall clock time for a pid
 *		loadave		current load average
 *
 */


#ifndef TRUE
#define FALSE	0
#define TRUE	1
#endif	/* TRUE */

#define TBL_INC 20

/*
 ** external functions and data
 */
extern	struct	config		*search(struct config *, char *);
extern	struct	rm_attribute	*momgetattr(char *);
extern	int			rm_errno;
extern	unsigned	int	reqnum;
extern	char	*ret_string;
extern 	double	 cputfactor;
extern	double	 wallfactor;
extern  pid_t	 mom_pid;
extern  int	 num_acpus;
extern  int	 num_pcpus;
extern	int	exiting_tasks;

/*
 ** local functions
 */
char	*physmem	(struct rm_attribute *attrib);
static char	*resi		(struct rm_attribute *attrib);
static char	*totmem		(struct rm_attribute *attrib);
static char	*availmem	(struct rm_attribute *attrib);
static char	*walltime	(struct rm_attribute *attrib);
static char	*ncpus		(struct rm_attribute *attrib);

extern char	*loadave	(struct rm_attribute *attrib);
extern char	*nullproc	(struct rm_attribute *attrib);

/*
 ** local resource list storage
 */
struct	config	dependent_config[] = {
	{ "resi",	resi },
	{ "totmem",	totmem },
	{ "physmem",	physmem },
	{ "availmem",	availmem },
	{ "loadave",	loadave },
	{ "ncpus",	ncpus },
	{ "walltime",	walltime },
	{ NULL,		nullproc },
};

/* local data */


struct nlist nl[] = {
	{ "avenrun" }
};

#define	KSYM_LOAD	0
#define	ASIZE		20

time_t			wait_time = 10;
int			kd = -1;
int			mom_does_chkpnt = 0;
int			proctot = 0;
struct	procsinfo	*proc_tbl = NULL;
char			**swap_dev = NULL;
int			nproc = 0;
static uint	 	realmem;
static long		page_size;
static int		myproc_max = 0;	   /* entries in Proc_lnks  */
pbs_plinks	       *Proc_lnks = NULL;  /* process links table head */
static time_t   sampletime_ceil;
static time_t   sampletime_floor;

extern	time_t	time_now;

extern	char	extra_parm[];
extern	char	no_parm[];
char		nokernel[] = "kernel not available";
char		noproc[] = "process %d does not exist";

#if	IBM_HPS

/**
 * @brief
 * 	This is the code used to setup HPS for a job.  It uses the
 * 	function pointers job_join_extra, job_join_read etc.  The
 * 	sequence is as follows:
 *
 * 	All nodes call hps_status to get the status of the windows on
 *	all available adapters.  The status is communicated back to
 * 	MS in the JOIN_JOB reply.  When all nodes have sent their window
 * 	status, MS sends the window status for all nodes to each node in
 * 	a SETUP_JOB message.  Each node calls hps_setup to use the
 * 	window status to search for two available windows per task.
 * 	A call to ntbl_load_table is done for each adapter chosen.
 * 	When the job is deleted, hps_cleanup is called to unload the
 * 	switch tables.
 */

static int
xntbl_adapter_resources(int version, char *adapter, ADAPTER_RESOURCES *res)
{
	int	ret;
	/* bug 10352: IBM umask problem */
	mode_t	oldmask;
	oldmask = umask(022);
	umask(oldmask);
	/* bug 10352: IBM umask problem */

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))

	if (QA_testing & PBSQA_NTBL_ADAPTER)
		return NTBL_EIO;

	ret = ntbl_adapter_resources(version, adapter, res);
	/* bug 10352: IBM umask problem */
	umask(oldmask);
	/* bug 10352: IBM umask problem */
	return ret;
}

static int
xntbl_status_adapter(int version, char *adapter, int *window_count,
	struct NTBL_STATUS **status)
{
	int	ret;
	/* bug 10352: IBM umask problem */
	mode_t	oldmask;
	oldmask = umask(022);
	umask(oldmask);
	/* bug 10352: IBM umask problem */

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))

	if (QA_testing & PBSQA_NTBL_STATUS)
		return NTBL_EADAPTER;

	ret = ntbl_status_adapter(version, adapter, window_count, status);
	/* bug 10352: IBM umask problem */
	umask(oldmask);
	/* bug 10352: IBM umask problem */
	return ret;
}

static int
xntbl_load_table(int version, char *adapter, unsigned short netid,
	uid_t uid, pid_t pid, unsigned short jobkey, char *desc,
	unsigned long long *mem, int table_size, NTBL **table)
{
	int	ret;
	/* bug 10352: IBM umask problem */
	mode_t	oldmask;
	oldmask = umask(022);
	umask(oldmask);
	/* bug 10352: IBM umask problem */

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))
	DBPRT(("%s: loading %s %s key=%d uid=%d\n", __func__, adapter, desc,
		(int)jobkey, (int)uid))

#ifdef DEBUG
	int	i;

	for (i=0; i<table_size; i++) {
		DBPRT(("\t%d task %d window %d lid %d\n", i,
			(int)table[i]->task_id,
			(int)table[i]->window_id,
			(int)table[i]->lid))
	}
#endif

	if (QA_testing & PBSQA_NTBL_LOAD)
		return NTBL_EIOCTL;

	ret = ntbl_load_table(version, adapter, netid, uid, pid, jobkey,
		desc, mem, table_size, table);
	/* bug 10352: IBM umask problem */
	umask(oldmask);
	/* bug 10352: IBM umask problem */
	return ret;
}

static int
xntbl_unload_window(int version, char *adapter, unsigned short jobkey,
	unsigned short winid)
{
	int	ret;
	/* bug 10352: IBM umask problem */
	mode_t	oldmask;
	oldmask = umask(022);
	umask(oldmask);
	/* bug 10352: IBM umask problem */

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))

	if (QA_testing & PBSQA_NTBL_UNLOAD)
		return NTBL_ACTIVE_STATE;

	ret = ntbl_unload_window(version, adapter, jobkey, winid);
	/* bug 10352: IBM umask problem */
	umask(oldmask);
	/* bug 10352: IBM umask problem */
	return ret;
}

static int
xntbl_clean_window(int version, char *adapter, enum CLEAN_OPTION option,
	unsigned short winid)
{
	int	ret;
	/* bug 10352: IBM umask problem */
	mode_t	oldmask;
	oldmask = umask(022);
	umask(oldmask);
	/* bug 10352: IBM umask problem */

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))

	if (QA_testing & PBSQA_NTBL_CLEAN)
		return NTBL_BUSY_STATE;

	ret = ntbl_clean_window(version, adapter, option, winid);
	/* bug 10352: IBM umask problem */
	umask(oldmask);
	/* bug 10352: IBM umask problem */
	return ret;
}

/*
 **	This is the loop limit for the adapter number.
 **	This allows for adapter names: sni0, sni1, sni2, sni3.
 */
#define	ANUM	4

/*
 **	This is the maximum number of adapters to allocate for redundancy.
 */
#define	MAX_ALLOCS	2


/*
 **	Structure to save the results of ntbl_status_adapter.
 */
struct	hps_winfo {
	char	*adapter;	/* adapter name "sniX" */
	int	net_id;		/* network id */
	int	lid;		/* logical id */
	int	*win;		/* malloc'ed array of window id's */
	int	*key;		/* malloc'ed array of key id's */
};
#define	WINFO	struct  hps_winfo

#elif	IBM_AIXIB	/* end of IBM_HPS section */

/**
 * @page	AIXIB	AIX InfiniBand
 * This is the code used to setup AIX InfiniBand for a job.  It uses the
 * function pointers job_join_extra, job_join_read etc.  The
 * sequence is as follows:
 *
 * All nodes call aixib_status to get the status of the windows on
 * all available adapters.  The status is communicated back to
 * MS in the JOIN_JOB reply.  When all nodes have sent their window
 * status, MS sends the window status for all nodes to each node in
 * a SETUP_JOB message.  Each node calls aixib_setup to use the
 * window status to search for two available windows per task.
 * A call to nrt_load_table is done for each adapter/netid chosen.
 * When the job is deleted, aixib_cleanup is called to unload the
 * switch tables.
 *
 * I checked the umask value before and after the call to
 * nrt_adapter_resources and there was no problem like bug 10352.
 */

/**
 * Shown in nrt.h but not defined.  The value for RSCT_NAM_CONNECT_UP
 * is 1 based on experiment.
 */
#ifndef	RSCT_NAM_CONNECT_UP
#define	RSCT_NAM_CONNECT_UP	1
#endif

/**
 * @brief
 * 	Wrapper function for nrt_adapter_resources.
 * 	Check the QA_testing value before calling the real function.
 */
static int
xnrt_adapter_resources(int version, char *adapter, uint16_t atype,
	adap_resources_t *res)
{
	int	ret;

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))

	if (QA_testing & PBSQA_NTBL_ADAPTER)
		return NRT_PNSDAPI;

	ret = nrt_adapter_resources(version, adapter, atype, res);
	if ((ret == NRT_SUCCESS) && (QA_testing & PBSQA_NTBL_NOPORTS))
		res->num_spigots = 0;
	return ret;
}

/**
 * @brief
 * 	Wrapper function for nrt_status_adapter.
 * 	Check the QA_testing value before calling the real function.
 */
static int
xnrt_status_adapter(int version, char *adapter, uint16_t atype,
	uint16_t *window_count, nrt_status_t **status)
{
	int	ret;

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))

	if (QA_testing & PBSQA_NTBL_STATUS)
		return NRT_EADAPTER;

	ret = nrt_status_adapter(version, adapter, atype,
		window_count, status);
	return ret;
}

/**
 * Wrapper function for nrt_load_table_rdma.
 * Print values for debugging and check the QA_testing value before
 * calling the real function.
 */
static int
xnrt_load_table_rdma(int version, char *adapter, uint16_t atype,
	uint64_t netid, uid_t uid, pid_t pid, ushort jobkey,
	char *desc, uint usebulk, uint bulk, int table_size,
	nrt_creator_per_task_input_t *table)
{
	int	ret;

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))
	DBPRT(("%s: net %llu %s key=%d uid=%d\n", __func__, netid, desc,
		(int)jobkey, (int)uid))

#ifdef DEBUG
	int	i;

	for (i=0; i<table_size; i++) {
		DBPRT(("\t%d task %d win %d node %u adap %s lid %d "
			"port %d lmc %d\n", i,
			(int)table[i].ib_per_task.task_id,
			(int)table[i].ib_per_task.win_id,
			table[i].ib_per_task.node_number,
			table[i].ib_per_task.device_name,
			(int)table[i].ib_per_task.base_lid,
			(int)table[i].ib_per_task.port_id,
			(int)table[i].ib_per_task.lmc))
	}
#endif

	if (QA_testing & PBSQA_NTBL_LOAD)
		return NRT_EINVAL;

	ret = nrt_load_table_rdma(version, adapter, atype, netid, uid,
		pid, jobkey, desc, usebulk, bulk, table_size, table);
	return ret;
}

/**
 * @brief
 * 	Wrapper function for nrt_unload_window.
 * 	Check the QA_testing value before calling the real function.
 */
static int
xnrt_unload_window(int version, char *adapter, uint16_t atype,
	ushort jobkey, ushort winid)
{
	int	ret;

	DBPRT(("%s: entry version %d adapter %s key %hu win %hu\n",
		__func__, version, adapter, jobkey, winid))

	if (QA_testing & PBSQA_NTBL_UNLOAD)
		return NRT_WRONG_WINDOW_STATE;

	ret = nrt_unload_window(version, adapter, atype, jobkey, winid);
	return ret;
}

#if 0
/**
 * @brief
 * 	Wrapper function for nrt_unload_window.
 * 	Print values for debugging.
 * 	Don't need this for now.
 */
static int
xnrt_rdma_jobs(int version, char *adapter, uint16_t atype,
	uint16_t *job_count, uint16_t **job_keys)
{
	int	ret;

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))

	ret = nrt_rdma_jobs(version, adapter, atype,
		job_count, job_keys);
#ifdef DEBUG
	if (ret == NRT_SUCCESS) {
		int	i;

		printf("%s: keys ", __func__);
		for (i=0; i<(int)*job_count; i++)
			printf(" %d", (*job_keys)[i]);
		printf(" END\n");
	}
#endif

	return ret;
}

/**
 * Wrapper function for xnrt_clean_window.
 * Don't need this for now because there is no way to double check
 * that a window belongs to a particular job.
 */
static int
xnrt_clean_window(int version, char *adapter, uint16_t atype,
	clean_option_t liok, ushort winid)
{
	int	ret;

	DBPRT(("%s: entry version %d adapter %s\n", __func__, version, adapter))

	if (QA_testing & PBSQA_NTBL_CLEAN)
		return NRT_EADAPTYPE;

	ret = nrt_clean_window(version, adapter, atype, liok, winid);
	return ret;
}
#endif	/* end of #if 0 block */

/**
 *	This is the loop limit for the adapter number.
 *	This allows for adapter names: iba0, iba1, ... iba7.
 */
#define	ANUM	8

/**
 *	This is the biggest number of networks we will expect.
 */
#define	MAX_ALLOCS	4


/**
 *	Structure to save the results of nrt_status_adapter.
 */
struct	aixib_winfo {
	char		*adapter;		/* adapter devicename */
	uint32_t	node;			/* node number */
	uint8_t		ports;			/* number of ports */
	uint16_t	lid[MAX_SPIGOTS];	/* logical id per port */
	uint64_t	netid[MAX_SPIGOTS];	/* network id per port */
	uint8_t		lmc[MAX_SPIGOTS];	/* logical mask per port */
	uint8_t		portid[MAX_SPIGOTS];	/* port id */
	int		numwin;			/* number of windows */
	int		*win;			/* malloc'ed array of winid's */
	int		*key;			/* malloc'ed array of keyid's */
};
#define	WINFO	struct  aixib_winfo

/**
 * Array to save the active adapter names.
 * @see dep_initialize
 */
char	ib_adapter[ANUM][NRT_MAX_DEVICENAME_SIZE];
int	ib_num = 0;

#endif	/* IBM_AIXIB */

/*
 ** Now here are common functions between HPS and AIXIB.
 */
#if	defined(IBM_HPS) || defined(IBM_AIXIB)

/**
 * List of all jobs local to MOM.
 */
extern pbs_list_head	svr_alljobs;

/**
 * Values for flag passed to make_jobkey.
 */
enum makekey_option {
	INUSE_CONTINUE,
	INUSE_FAIL
};

/**
 * Limit for how many keys to check when trying to find
 * a unique key.
 */
#define	KEY_MAX	USHRT_MAX

/**
 * @brief
 * 	Create the network job key for a job.
 *
 * The original method of creating a job key was to use the initial numeric
 * part of the PBS jobid.  This would not work with an array job so now
 * both the numeric jobid and the subjobid (if it exists) are used together
 * to form an initial job key.  This is then checked against the existing
 * job keys.  If the chosen key already is in use, it is incremented and
 * checked again.  Once a choice is made, it is saved in the job structure.
 *
 * @param[in]	pjob		job pointer
 * @param[in]	option		return an error if the first key is in use
 * 
 * @return	int
 * @retval	-1		error
 * @retval	key		Success
 *
 */
static int
make_jobkey(job *pjob, enum makekey_option option)
{
	char	*number, *cp;
	int	i, key;
	int	subjob;
	int	try, ret;
	job		*pj;
	attribute	*jobarray;
	int		*keyp;
	WINFO		**wp;
	AVL_IX_DESC	keyx;
	AVL_IX_REC	keyrec;

	DBPRT(("%s: entered\n", __func__))
	if (pjob == NULL)
		return -1;

	if (pjob->ji_extended.ji_ext.ji_keysaved) {
		DBPRT(("%s: use saved value %d\n", __func__,
			pjob->ji_extended.ji_ext.ji_jobkey))
		return pjob->ji_extended.ji_ext.ji_jobkey;
	}

	/*
	 * The initial key value comes from the jobid and array number.
	 */
	number = pjob->ji_qs.ji_jobid;
	errno = 0;
	key = (int)strtol(number, &cp, 10);
	if (errno != 0)		/* trouble converting jobid */
		return -1;

	jobarray = &pjob->ji_wattr[(int)JOB_ATR_array_index];
	if (jobarray->at_flags & ATR_VFLAG_SET) {
		/* this is a sub job of an Array Job */
		subjob = (int)strtol(jobarray->at_val.at_str, &cp, 10);
		if (errno != 0)		/* trouble converting subjob */
			return -1;
		key *= (subjob+1);
	}

	/*
	 * Setup AVL tree to hold existing keys to check against.
	 * The keyp pointer gives an easy way to plug a key into
	 * the key field of keyrec.
	 */
	memset(&keyrec, 0, sizeof(keyrec));
	keyp = (int *)keyrec.key;
	avl_create_index(&keyx, AVL_COUNT_DUPS, sizeof(int));

	/*
	 * If I am mother superior, add keys from other MOMs.
	 */
	if (pjob->ji_hosts[0].hn_node == pjob->ji_nodeid) {
		for (i=0; i<pjob->ji_numnodes; i++) {
			hnodent	*np = &pjob->ji_hosts[i];
			int	j, *keys;

			if (np->hn_setup == NULL)
				continue;

			wp = (WINFO **)np->hn_setup;
			keys = wp[0]->key;
			if (keys == NULL)
				continue;

			for (j=0; keys[j] != -1; j++) {
				DBPRT(("%s: node %d[%d] %d\n", __func__,
					i, j, keys[j]))
				*keyp = keys[j];
				if (avl_add_key(&keyrec, &keyx) != AVL_IX_OK) {
					/* probably out of memory */
					DBPRT(("%s: add key failed!\n", __func__))
					goto done;
				}
			}
		}
	}

	/* add keys from local jobs */
	for (pj = (job *)GET_NEXT(svr_alljobs); pj != NULL;
		pj = (job *)GET_NEXT(pj->ji_alljobs)) {
		if (pj == pjob)		/* skip myself */
			continue;
		if (pj->ji_extended.ji_ext.ji_keysaved == 0)
			continue;	/* no key */

		DBPRT(("%s: local %d\n", __func__,
			pj->ji_extended.ji_ext.ji_jobkey))
		*keyp = pj->ji_extended.ji_ext.ji_jobkey;
		if (avl_add_key(&keyrec, &keyx) != AVL_IX_OK) {
			DBPRT(("%s: add key failed!\n", __func__))
			goto done; 	/* probably out of mem */
		}
	}

	/* now find a key */
	ret = -1;
	for (try=0; try<=KEY_MAX; try++) {
		/*
		 * Change the value into a job key.  This is dependent on the
		 * network lib we are using.
		 */
#if	IBM_HPS
		/* truncate to be less than 0xFFF0 */
		key = (key % 0xffef) + 1;
#elif	IBM_AIXIB
		/* truncate to USHRT_MAX */
		key = key & USHRT_MAX;
#else
		/* place holder for now */
		key = 0;
#endif
		DBPRT(("%s: try %d key %d\n", __func__, try, key))

		*keyp = key;	/* see if key exists */
		if (avl_find_key(&keyrec, &keyx) != AVL_IX_OK) {
			pjob->ji_extended.ji_ext.ji_jobkey = key;
			pjob->ji_extended.ji_ext.ji_keysaved = 1;
			(void)job_save(pjob, SAVEJOB_QUICK);
			ret = key;
			goto done;
		}

		/*
		 * The key we picked conflicts with an existing
		 * key.  If we are not allowed to generate another
		 * key to try again, we have to fail.  The ret value
		 * has been initialized to -1 to reflect this.
		 */
		DBPRT(("%s: MATCH %d\n", __func__, key))
		if (option == INUSE_FAIL)
			goto done;

		key++;		/* generate next key */
	}
	log_joberr(-1, __func__, "all job keys are in use",
		pjob->ji_qs.ji_jobid);

done:
	avl_destroy_index(&keyx);
	return ret;
}

/**
 * @brief
 * 	Free memory holding WINFO info for a node.
 *
 * @param[in] pjob - job pointer
 * @param[in] np - pointer to hnodent structure
 *
 * @return 	Void
 *
 */
void
switch_freenode(job *pjob, hnodent *np)
{
	int	j;
	WINFO	**wp;

	if (np->hn_setup == NULL)
		return;

	wp = (WINFO **)np->hn_setup;
	for (j=0; j<ANUM; j++) {
		if (wp[j]->adapter != NULL)
			free(wp[j]->adapter);
		if (wp[j]->win != NULL)
			free(wp[j]->win);
		free(wp[j]->key);
		free(wp[j]);
	}
	free(np->hn_setup);
	np->hn_setup = NULL;
	return;
}

/**
 * @brief
 * 	Free memory holding WINFO setup info.
 *
 * @param[in] pjob - job pointer
 *
 * @return	Void
 *
 */
void
switch_free(job *pjob)
{
	int		i;

	DBPRT(("%s: entry\n", __func__))
	if (pjob->ji_setup != NULL) {
		int	**awins = (int **)pjob->ji_setup;

		for (i=0; i<MAX_ALLOCS; i++) {
			if (awins[i] != NULL)
				free(awins[i]);
		}
		free(pjob->ji_setup);
		pjob->ji_setup = NULL;
	}

	/* look at node entries */
	if (pjob->ji_hosts != NULL) {
		for (i=0; i<pjob->ji_numnodes; i++) {
			switch_freenode(pjob, &pjob->ji_hosts[i]);
		}
	}

	return;
}

/**
 * @brief
 * 	Read the list of job keys that exist on this node
 * 	and store them in np->hn_setup[0].key
 *
 * @param[in]	stream	RPP stream to read
 * @param[in]	np	pointer to node we are reading from
 *
 * @return	int
 * @retval	DIS error code	error
 * @retval	DIS_SUCCESS	Success
 *
 * Protocol used to send the key info.
 * @verbatim
 *	keycount	int
 *	jobkey0		int
 *	jobkey1		int
 *	...
 * @endverbatim
 */
int
read_keys(int stream, hnodent *np)
{
	int	i, ret, numkey;
	int	*keys, key;
	WINFO	*wp;

	ret = rpp_rcommit(stream, TRUE);
	if (ret) {	/* check if end-of-message has been reached */
		DBPRT(("%s: NOT SENT from %s\n", __func__, np->hn_host))
		return DIS_SUCCESS;
	}

	/* read the number of keys */
	numkey = disrsi(stream, &ret);
	if (ret != DIS_SUCCESS)
		return ret;

	DBPRT(("%s: numkey %d\n", __func__, numkey))
	if (numkey == 0)		/* none to save */
		return DIS_SUCCESS;

	keys = calloc(numkey+1, sizeof(*keys));
	if (keys == NULL)
		return DIS_NOMALLOC;

	DBPRT(("%s: keys ", __func__))
	for (i=0; i<numkey; i++) {
		key = disrsi(stream, &ret);
		if (ret != DIS_SUCCESS) {
			free(keys);
			return ret;
		}

		DBPRT(("%d ", key))
		keys[i] = key;
	}
	DBPRT(("END\n"))
	keys[numkey] = -1;	/* mark end of list */

	wp = ((WINFO **)np->hn_setup)[0];
	wp->key = keys;

	return DIS_SUCCESS;
}

/**
 * @brief
 * 	Send the network keys inuse on the local system.  These
 * 	will be ignored by MOMs that don't support array jobs.
 *
 * @param[in]	pjob	pointer to job being started
 * @param[in]	stream	RPP stream to write on
 *
 * @return 	int
 * @retval	DIS error code	error
 * @retval	DIS_SUCCESS	Success
 *
 * Protocol used to send the key info.
 * @verbatim
 *	keycount	int
 *	jobkey0		int
 *	jobkey1		int
 *	...
 * @endverbatim
 */
int
write_keys(job *pjob, int stream)
{
	job	*pj;
	int	ret, numkey;

	/* count the keys we need to send */
	numkey = 0;
	for (pj = (job *)GET_NEXT(svr_alljobs); pj != NULL;
		pj = (job *)GET_NEXT(pj->ji_alljobs)) {
		if (pj == pjob)		/* skip myself */
			continue;
		if (pj->ji_extended.ji_ext.ji_keysaved == 0)	/* no key */
			continue;
		numkey++;
	}
	ret = diswsi(stream, numkey);
	if (ret != DIS_SUCCESS)
		return ret;
	if (numkey == 0)
		return DIS_SUCCESS;

	/* send the keys */
	for (pj = (job *)GET_NEXT(svr_alljobs); pj != NULL;
		pj = (job *)GET_NEXT(pj->ji_alljobs)) {
		if (pj == pjob)		/* skip myself */
			continue;
		if (pj->ji_extended.ji_ext.ji_keysaved == 0)	/* no key */
			continue;

		ret = diswsi(stream, pj->ji_extended.ji_ext.ji_jobkey);
		if (ret != DIS_SUCCESS)
			return ret;
	}
	return DIS_SUCCESS;
}

#endif	/* common to IBM_HPS and IBM_AIXIB */


#if	IBM_HPS
/**
 * @brief
 * 	Unload HPS.
 *
 * @param[in] pjob - job pointer
 *
 * Call ntbl_status_adapter to find windows owned by a job based
 * on the description.  Call ntbl_unload_window for each window.
 * If that fails, call ntbl_clean_window.
 *
 * @return 	int
 * @retval	PBSE_NONE 		Success
 * @retval	PBSE_INTERNAL		error
 *
 */
int
hps_cleanup(job *pjob)
{
	char		adap[30];
	char		*jobid = pjob->ji_qs.ji_jobid;
	int		i, ret;
	int		windows;
	int		key;
	struct	NTBL_STATUS	*astat, *ap, *tp;

	DBPRT(("%s: entry\n", __func__))

	if (pjob->ji_extended.ji_ext.ji_keysaved)
		key = pjob->ji_extended.ji_ext.ji_jobkey;
	else {
		DBPRT(("%s: NO SAVED KEY\n", __func__))
		return PBSE_INTERNAL;
	}

	for (i=0; i<ANUM; i++) {
		int		found = 0, did = 0;

		sprintf(adap, "sni%d", i);
		ret = xntbl_status_adapter(NTBL_VERSION, adap,
			&windows, &astat);
		if (ret != NTBL_SUCCESS) {
			if (ret != NTBL_EADAPTER) {
				sprintf(log_buffer,
					"ntbl_status_adapter(%s) err %d",
					adap, ret);
				log_joberr(errno, __func__, log_buffer, jobid);
			}
			continue;
		}

		ap = astat;
		while (ap != NULL) {
			switch (ap->rc) {
				case NTBL_LOADED_STATE:
				case NTBL_DISABLED_STATE:
				case NTBL_ACTIVE_STATE:
				case NTBL_BUSY_STATE:
					/*
					 ** The description is valid; compare to
					 ** the jobid to see if this is for PBS.
					 */
					if (strcmp(ap->description, jobid) != 0)
						break;

					found++;
					did++;
					ret = xntbl_unload_window(NTBL_VERSION, adap,
						(unsigned short)key, ap->window_id);
					if (ret == NTBL_SUCCESS)
						break;

					sprintf(log_buffer,
						"ntbl_unload_window(%s) err %d",
						adap, ret);
					log_joberr(errno, __func__, log_buffer, jobid);

					ret = xntbl_clean_window(NTBL_VERSION, adap,
						ALWAYS_KILL, ap->window_id);
					if (ret == NTBL_SUCCESS)
						break;

					sprintf(log_buffer,
						"ntbl_clean_window(%s) err %d",
						adap, ret);
					log_joberr(errno, __func__, log_buffer, jobid);
					did--;

					break;

				default:
					break;
			}

			tp=ap->next;
			free(ap);
			ap=tp;
		}
		sprintf(log_buffer, "%s(%s): %d windows, %d unloaded",
			__func__, adap, found, did);
		log_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB, LOG_DEBUG,
			jobid, log_buffer);
	}

	return PBSE_NONE;
}

/**
 * @brief
 * 	Get status for all possible adapters.
 * 
 * @param[in] pjob - job pointer
 * @param[in] np - pointer to hnodent structure
 *
 * @return	int
 * @retval	0				Success
 * @retval 	ENOMEM(12)			out of memory
 * @retval	PBSE_IBMSPSWITCH(15097) 	IBM SP Switch error 
 */
int
hps_status(job *pjob, hnodent *np)
{
	char		adap[30];
	char		*jobid = pjob->ji_qs.ji_jobid;
	int		did, i, j, ret;
	int		windows;
	ADAPTER_RESOURCES	res;
	struct	NTBL_STATUS	*astat, *ap, *tp;
	struct	hps_winfo	*wp;

	DBPRT(("%s: entry\n", __func__))

	/* allocate array of hps_winfo pointers */
	np->hn_setup = calloc(ANUM, sizeof(struct hps_winfo *));
	if (np->hn_setup == NULL)
		return ENOMEM;

	DBPRT(("%s: pick %d windows\n", __func__, np->hn_nprocs))
	for (did=0, i=0; i<ANUM; i++) {
		sprintf(adap, "sni%d", i);
		ret = xntbl_adapter_resources(NTBL_VERSION, adap, &res);
		if (ret != NTBL_SUCCESS) {
			if (ret != NTBL_EADAPTER) {
				sprintf(log_buffer,
					"ntbl_adapter_resources(%s) err %d",
					adap, ret);
				log_joberr(errno, __func__, log_buffer, jobid);
			}
			continue;
		}
		free(res.window_list);	/* don't need window_list */
		if (res.window_count < np->hn_nprocs) {
			sprintf(log_buffer,
				"%s: need %d windows, only %d exist",
				adap, np->hn_nprocs, res.window_count);
			log_joberr(-1, __func__, log_buffer, jobid);
			continue;
		}

		wp = (struct hps_winfo *)malloc(sizeof(struct hps_winfo));
		if (wp == NULL)
			return ENOMEM;
		memset(wp, 0, sizeof(*wp));

		wp->win = (int *)calloc(np->hn_nprocs, sizeof(int));
		if (wp->win == NULL) {
			free(wp);
			return ENOMEM;
		}

		ret = xntbl_status_adapter(NTBL_VERSION, adap,
			&windows, &astat);
		if (ret != NTBL_SUCCESS) {
			sprintf(log_buffer,
				"ntbl_status_adapter(%s) err %d",
				adap, ret);
			log_joberr(errno, __func__, log_buffer, jobid);
			free(wp->win);
			free(wp);
			continue;
		}

		DBPRT(("%s: %s netid %d lid %d\n", __func__, adap,
			(int)res.network_id, (int)res.lid))
		wp->adapter = strdup(adap);
		if (wp->adapter == NULL) {
			free(wp->win);
			free(wp);
			return ENOMEM;
		}
		wp->net_id = (int)res.network_id;
		wp->lid = (int)res.lid;

		DBPRT(("%s: %d window ids: ", __func__, np->hn_nprocs))
		j = 0;
		ap = astat;
		while (ap != NULL) {
			if (j == np->hn_nprocs)
				break;
			if (ap->rc == NTBL_UNLOADED_STATE) {
				wp->win[j++] = (int)ap->window_id;
				DBPRT(("%d ", (int)ap->window_id))
			}
			tp = ap->next;
			free(ap);
			ap = tp;
		}
		DBPRT(("\n"))

		if (j < np->hn_nprocs) {
			sprintf(log_buffer,
				"%s: need %d windows, only %d found",
				adap, np->hn_nprocs, j);
			log_joberr(-1, __func__, log_buffer, jobid);
			free(wp->win);
			free(wp->adapter);
			free(wp);
			continue;
		}
		((struct hps_winfo **)np->hn_setup)[did++] = wp;
	}

	if (did == 0) {
		free(np->hn_setup);
		np->hn_setup = NULL;
		log_joberr(-1, __func__,
			"no available windows on any HPS adapter", jobid);
		return PBSE_IBMSPSWITCH;
	}

	return 0;
}

/**
 * @brief
 * 	Write HPS setup info saved by hps_status back to MS.
 * 	If there are less than ANUM adapters, a NULL string will be sent
 * 	for the adapter name.
 *
 * A list of job keys in use on the local mom will be added after all
 * the adapter info.  The IM_JOINX_IBMHPS version number is not changed
 * even though the protocol is different because this would cause any
 * HPS MOM that does not support array jobs to reject the message completely.
 * Using the same version number will work because an HPS MOM that does not
 * support array jobs will simply ignore the extra information.  An HPS MOM
 * that does support array jobs reading from an HPS MOM that does not support
 * array jobs can detect the end of data.
 *
 * @see hps_read
 *
 * @param[in] 	pjob  	job pointer
 * @param[in]   stream  stream (fd)
 * @param[in]   np      pointer to hnodent structure
 * 
 * @return      int
 * @retval      DIS error code  error
 * @retval      DIS_SUCCESS     Success
 *
 * Protocol used to send the setup info.
 * @verbatim
 *	version		int
 *	adaptername1	string
 *		netid	int
 *		lid	int
 *		win1	int
 *		...
 *		winN	int
 *	adaptername2	string
 *		...
 *	keycount	int
 *	jobkey0		int
 *	jobkey1		int
 *	...
 * @endverbatim
 */
int
hps_ack(job *pjob, hnodent *np, int stream)
{
	int	i, j, ret, numkey;
	struct	hps_winfo	**winfo;
	job	*pj;

	DBPRT(("%s: entry\n", __func__))
	ret = diswsi(stream, IM_JOINX_IBMHPS);
	if (ret != DIS_SUCCESS)
		goto done;

	winfo = (struct hps_winfo **)np->hn_setup;
	for (i=0; i<ANUM; i++) {
		struct	hps_winfo	*wp = winfo[i];

		if (wp == NULL) {
			ret = diswst(stream, "");
			if (ret != DIS_SUCCESS)
				goto done;
			break;
		}
		ret = diswst(stream, wp->adapter);
		if (ret != DIS_SUCCESS)
			goto done;
		ret = diswsi(stream, wp->net_id);
		if (ret != DIS_SUCCESS)
			goto done;
		ret = diswsi(stream, wp->lid);
		if (ret != DIS_SUCCESS)
			goto done;

		for (j=0; j<np->hn_nprocs; j++) {
			ret = diswsi(stream, wp->win[j]);
			if (ret != DIS_SUCCESS)
				goto done;
		}
	}

	ret = write_keys(pjob, stream);
	if (ret != DIS_SUCCESS)
		goto done;

	return DIS_SUCCESS;

done:
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return ret;
}

/**
 * @brief
 * 	Read the extra information being sent by a sister with hps_ack after
 * 	a good JOIN_JOB reply.
 * 	I am mother superior.
 *
 * @see hps_ack
 *
 * @param[in] pjob - job pointer
 * @param[in] np - pointer to hnodent structure
 * @param[in] stream - fd
 *
 * @return 	int
 * @retval	DIS_SUCCESS		Success
 * @retval	DIS_* error code	Error
 */
int
hps_read(job *pjob, hnodent *np, int stream)
{
	int	i, j, ret;
	int	*keys;
	int	version;
	char	*adapter;
	struct	hps_winfo	*wp;

	DBPRT(("%s: entry\n", __func__))

	keys = NULL;
	version = disrsi(stream, &ret);
	if (ret != DIS_SUCCESS)
		goto err;
	/*
	 ** Check the type of extra information being sent.
	 ** If I don't understand it, don't accept the job.
	 */
	if (version != IM_JOINX_IBMHPS) {
		sprintf(log_buffer, "received version %d from %s, "
			"expected %d", version, np->hn_host, IM_JOINX_IBMHPS);
		log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
		return DIS_PROTO;
	}

	/*
	 ** Remove any old information then read the new data.
	 */
	switch_freenode(pjob, np);

	/* allocate array of hps_winfo pointers */
	np->hn_setup = calloc(ANUM, sizeof(struct hps_winfo *));
	if (np->hn_setup == NULL)
		return DIS_NOMALLOC;

	for (i=0; i<ANUM; i++) {
		adapter = disrst(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;

		if (adapter == NULL || *adapter == '\0') {
			DBPRT(("%s: adapter = NULL\n", __func__))
			break;
		}

		wp = (struct hps_winfo *)malloc(sizeof(struct hps_winfo));
		if (wp == NULL)
			return DIS_NOMALLOC;

		memset(wp, 0, sizeof(*wp));
		((struct hps_winfo **)np->hn_setup)[i] = wp;

		wp->adapter = adapter;
		wp->net_id = disrsi(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;
		wp->lid = disrsi(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;

		DBPRT(("%s: %s netid %d lid %d\n", __func__, adapter,
			wp->net_id, wp->lid))

		wp->win = (int *)calloc(np->hn_nprocs, sizeof(int));
		if (wp->win == NULL)
			return DIS_NOMALLOC;

		DBPRT(("%s: read %d window ids: ", __func__, np->hn_nprocs))
		for (j=0; j<np->hn_nprocs; j++) {
			wp->win[j] = disrsi(stream, &ret);
			if (ret != DIS_SUCCESS)
				goto err;
			DBPRT(("%d ", wp->win[j]))
		}
		DBPRT(("\n"))
	}
	DBPRT(("%s: got %d adapters\n", __func__, i))

	ret = read_keys(stream, np);
	if (ret != DIS_SUCCESS)
		goto err;

	return DIS_SUCCESS;

err:
	/*
	 ** Getting here means we had a read failure.
	 */
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return ret;
}

/**
 * @brief
 * 	Called from send_sisters.  I am Mother Superior.
 * 	Send the complete set of window id's for HPS setup.
 *
 * A new element is added to support array jobs.  The job key
 * is chosen by MS and sent off to all the sisters at the end
 * of this message.
 *
 * @see send_sisters
 *
 * @param[in] pjob - job pointer
 * @param[in] np - pointer to hnodent structure
 * @param[in] stream - fd
 *
 * @return      int
 * @retval      DIS_SUCCESS             Success
 * @retval      PBSE_ error code        Error
 */
int
hps_send(job *pjob, hnodent *xp, int stream)
{
	int	i, j, k, ret, key;
	struct	hps_winfo	**winfo;

	DBPRT(("%s: entry send to host %s\n", __func__, xp->hn_host))
	ret = diswsi(stream, IM_JOINX_IBMHPS);
	if (ret != DIS_SUCCESS)
		goto done;

	/* send all the windows ids */
	for (i=0; i<pjob->ji_numnodes; i++) {
		hnodent *np = &pjob->ji_hosts[i];

		if (xp == np) {	/* don't need to send node's own info */
			DBPRT(("%s: skip info from self\n", __func__))
			continue;
		}

		winfo = (struct hps_winfo **)np->hn_setup;
		for (j=0; j<ANUM; j++) {
			struct	hps_winfo	*wp = winfo[j];

			if (wp == NULL) {
				ret = diswst(stream, "");
				if (ret != DIS_SUCCESS)
					goto done;
				break;
			}
			DBPRT(("%s: send %d info from %d %s net %d lid %d\n",
				__func__, xp->hn_node, np->hn_node,
				wp->adapter, wp->net_id, wp->lid))
			ret = diswst(stream, wp->adapter);
			if (ret != DIS_SUCCESS)
				goto done;
			ret = diswsi(stream, wp->net_id);
			if (ret != DIS_SUCCESS)
				goto done;
			ret = diswsi(stream, wp->lid);
			if (ret != DIS_SUCCESS)
				goto done;

			for (k=0; k<np->hn_nprocs; k++) {
				ret = diswsi(stream, wp->win[k]);
				if (ret != DIS_SUCCESS)
					goto done;
			}
		}
	}

	/*
	 * Generate the key for the job and send it.
	 */
	key = make_jobkey(pjob, INUSE_CONTINUE);
	if (key <= 0) {
		log_joberr(-1, __func__, "could not create job key",
			pjob->ji_qs.ji_jobid);
		return PBSE_INTERNAL;
	}

	ret = diswsi(stream, key);
	if (ret != DIS_SUCCESS)
		goto done;

	return DIS_SUCCESS;

done:
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return ret;
}

/**
 * @brief
 * 	Free space for NTBL info.
 */
void
freetable(NTBL **table, int n)
{
	int	i;

	for (i=0; i<n; i++) {
		if (table[i] == NULL)
			break;
		free(table[i]);
	}
	free(table);
}

/**
 * @brief
 * 	Called to read the window id's for HPS setup.
 * 	The stream parameter will not be used by Mother Superior.
 * 	She uses the information saved in the job structure.
 *
 * @param[in] pjob - job pointer
 * @param[in] stream - fd
 *
 * @return	int
 * @retval	PBSE_NONE	Success
 * @retval 	PBS error code	Error
 */
int
hps_setup(job *pjob, int stream)
{
	char	*jobid = pjob->ji_qs.ji_jobid;
	int	i, j, k, ret;
	int	version;
	char	*adapter;
	struct	hps_winfo	*wp, *winfo0;
	NTBL	**table;
	int	ts, tablemax;
	unsigned long long	mem = 0;
	int	key;
	int	did = 0;
	hnodent *node0;
	int	**awins;
	int	netid[ANUM];


	DBPRT(("%s: entry stream %d\n", __func__, stream))
	/*
	 ** Check if I am Mother Superior.  If not, read in
	 ** information from stream.
	 */
	if (pjob->ji_hosts[0].hn_node != pjob->ji_nodeid) {
		version = disrsi(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;
		/*
		 ** Check the type of extra information being sent.
		 ** If I don't understand it, don't accept the job.
		 */
		if (version != IM_JOINX_IBMHPS) {
			sprintf(log_buffer, "received version %d from %s, "
				"expected %d", version, IM_JOINX_IBMHPS);
			log_joberr(-1, __func__, log_buffer, jobid);
			return PBSE_NOSUP;
		}

		for (i=0; i<pjob->ji_numnodes; i++) {
			hnodent *np = &pjob->ji_hosts[i];

			if (np->hn_node == pjob->ji_nodeid)	/* skip me */
				continue;

			DBPRT(("%s: reading for node %d\n", __func__, np->hn_node))
			/*
			 ** Remove any old information then read the new data.
			 */
			switch_freenode(pjob, np);

			/* allocate array of hps_winfo pointers */
			np->hn_setup = calloc(ANUM, sizeof(struct hps_winfo *));
			if (np->hn_setup == NULL)
				return ENOMEM;

			for (j=0; j<ANUM; j++) {
				adapter = disrst(stream, &ret);
				if (ret != DIS_SUCCESS)
					goto err;

				if (adapter == NULL || *adapter == '\0') {
					DBPRT(("%s: adapter = NULL\n", __func__))
					break;
				}

				wp = (struct hps_winfo *)
					malloc(sizeof(struct hps_winfo));
				if (wp == NULL) {
					free(adapter);
					return ENOMEM;
				}

				/*
				 ** Zero the new structure and point the
				 ** array entry in hn_setup so it can be
				 ** cleaned up.
				 */
				memset(wp, 0, sizeof(struct hps_winfo));
				((struct hps_winfo **)np->hn_setup)[j] = wp;

				wp->adapter = adapter;
				wp->net_id = disrsi(stream, &ret);
				if (ret != DIS_SUCCESS)
					goto err;
				wp->lid = disrsi(stream, &ret);
				if (ret != DIS_SUCCESS)
					goto err;
				DBPRT(("%s: %s netid %d lid %d\n", __func__, adapter,
					wp->net_id, wp->lid))

				wp->win = (int *)calloc(np->hn_nprocs,
					sizeof(int));
				if (wp->win == NULL) {
					free(adapter);
					free(wp);
					return ENOMEM;
				}

				DBPRT(("%s: read %d window ids: ", __func__,
					np->hn_nprocs))
				for (k=0; k<np->hn_nprocs; k++) {
					wp->win[k] = disrsi(stream, &ret);
					if (ret != DIS_SUCCESS)
						goto err;
					DBPRT(("%d ", wp->win[k]))
				}
				DBPRT(("\n"))
			}
			DBPRT(("%s: node %d got %d adapters\n", __func__,
				np->hn_node, j))
		}
		/**
		 * Now read the jobkey if it has been sent.  If it has
		 * not been sent, the MS is an HPS MOM that does not
		 * support array jobs which means
		 * the job is not an array job.  We could still have a
		 * problem if keys have been generated using the conflict
		 * detection algorithm @see make_jobkey.
		 * Set the flag to fail if there is a conflict.
		 */
		key = disrsi(stream, &ret);
		if (ret == DIS_EOD) {
			DBPRT(("%s: NOT SENT - make it\n", __func__))
			key = make_jobkey(pjob, INUSE_FAIL);
			if (key <= 0) {
				log_joberr(-1, __func__,
					"could not create local job key",
					jobid);
				return PBSE_INTERNAL;
			}
		} else if (ret == DIS_SUCCESS) {
			pjob->ji_extended.ji_ext.ji_keysaved = 1;
			pjob->ji_extended.ji_ext.ji_jobkey = key;
			(void)job_save(pjob, SAVEJOB_QUICK);
		} else
			goto err;
	} else {
		/*
		 * I am mother superior.
		 * In a multi-node job, the jobkey will have already created
		 * in hps_send.  If not, create it here.
		 */
		if (pjob->ji_extended.ji_ext.ji_keysaved)
			key = pjob->ji_extended.ji_ext.ji_jobkey;
		else {
			key = make_jobkey(pjob, INUSE_CONTINUE);
			if (key <= 0) {
				log_joberr(-1, __func__,
					"could not create job key", jobid);
				return PBSE_INTERNAL;
			}
		}
	}

	/*
	 ** Now we have the information to do the HPS setup.
	 ** Free any old setup info.
	 */
	if (pjob->ji_setup != NULL) {
		int	**awins = (int **)pjob->ji_setup;

		DBPRT(("%s: free old ji_setup\n", __func__))
		for (i=0; i<MAX_ALLOCS; i++) {
			if (awins[i] != NULL)
				free(awins[i]);
		}
		free(pjob->ji_setup);
		pjob->ji_setup = NULL;
	}

	/*
	 ** Allocate array to hold table information for the environment.
	 ** It will be NULL terminated.
	 */
	awins = (int **)calloc(MAX_ALLOCS+1, sizeof(awins));
	if (awins == NULL)
		return ENOMEM;
	pjob->ji_setup = (void *)awins;

	/*
	 ** Loop over adapters for node 0.
	 ** Compile information for this adapter from all the other
	 ** nodes and make the ntbl_load_table call.
	 */
	DBPRT(("%s: setup key %d\n", __func__, key))
	node0 = &pjob->ji_hosts[0];

	/*
	 ** Initialize netid to -1 which will never match a real
	 ** netid since they are unsigned.
	 ** The compare is done between netid[] and (struct hps_winfo).net_id
	 ** which are both signed integers.  The net_id field is filled
	 ** in from the HPS status structure which is an unsigned short.
	 */
	for (i=0; i<ANUM; i++)
		netid[i] = -1;

	for (i=0; i<ANUM; i++) {
		/*
		 ** Only need a maximum of MAX_ALLOCS adapters for redundancy.
		 */
		if (did == MAX_ALLOCS)
			break;

		winfo0 = ((struct hps_winfo **)node0->hn_setup)[i];

		if (winfo0->adapter == NULL)
			break;

		DBPRT(("%s: %s netid %d lid %d\n", __func__, winfo0->adapter,
			winfo0->net_id, winfo0->lid))

		/*
		 ** Check to see if we have already loaded this netid.
		 */
		for (j=0; j < i; j++) {
			if (netid[j] == winfo0->net_id)
				break;
		}
		if (j < i) {
			DBPRT(("%s: skip netid %d\n", __func__, winfo0->net_id))
			continue;
		}

		ts = 0;
		tablemax = pjob->ji_numnodes * 10;
		table = (NTBL **)calloc(tablemax, sizeof(NTBL *));
		if (table == NULL)
			return ENOMEM;

		/*
		 ** For each node, find matching adapter.
		 ** We must find this adapter on all nodes before
		 ** loading the table.
		 */
		adapter = NULL;
		for (j=0; j<pjob->ji_numnodes; j++) {
			hnodent *np = &pjob->ji_hosts[j];

			for (k=0; k<ANUM; k++) {
				wp = ((struct hps_winfo **)np->hn_setup)[k];

				if (wp->adapter == NULL)
					break;

				if (winfo0->net_id != wp->net_id)
					continue;
				if (strcmp(winfo0->adapter, wp->adapter) != 0)
					continue;

				/*
				 ** remember if this is my adapter
				 */
				if (np->hn_node == pjob->ji_nodeid)
					adapter = wp->adapter;
				break;
			}
			if (k == ANUM) {
				DBPRT(("%s: node %d adapter %s net_id %d "
					"not found\n", __func__, j,
					winfo0->adapter, winfo0->net_id))
				break;
			}

			for (k=0; k<np->hn_nprocs; k++) {
				table[ts] = (NTBL *)malloc(sizeof(NTBL));
				if (table[ts] == NULL)
					break;
				table[ts]->lid = wp->lid;
				table[ts]->task_id = ts;
				table[ts++]->window_id = wp->win[k];

				/* see if we need bigger table */
				if (ts == tablemax) {
					void	*hold;

					tablemax *= 2;
					hold = realloc(table,
						tablemax * sizeof(NTBL *));
					if (hold == NULL)
						break;
					table = (NTBL **)hold;
				}
			}
			if (k < np->hn_nprocs) {	/* no memory */
				freetable(table, ts);
				break;
			}
		}
		if (j < pjob->ji_numnodes) {
			freetable(table, ts);
			DBPRT(("%s: not all nodes have net_id %d\n",
				__func__, winfo0->net_id))
			continue;
		}

		/* save table info for the environment */
		awins[did] = (int *)calloc(ts + 2, sizeof(*awins));
		if (awins[did] == NULL) {
			freetable(table, ts);
			break;
		}

		/* the adapter name is "sniX" so save X */
		awins[did][0] = atoi(&adapter[3]);
		for (k=0; k<ts; k++)
			awins[did][k+1] = table[k]->window_id;
		awins[did][k+1] = -1;
		did++;

		/* Now we make the ntbl_load_table call.  */
		ret = xntbl_load_table(NTBL_VERSION, adapter,
			(unsigned short)winfo0->net_id,
			(uid_t)pjob->ji_qs.ji_un.ji_momt.ji_exuid,
			(pid_t)mom_pid, (unsigned short)key, jobid,
			&mem, ts, table);
		freetable(table, ts);
		if (ret != NTBL_SUCCESS) {
			sprintf(log_buffer,
				"ntbl_load_table(%s) key %d err %d",
				adapter, key, ret);
			log_joberr(errno, __func__, log_buffer, jobid);
			return PBSE_IBMSPSWITCH;
		}
		netid[i] = winfo0->net_id;
		sprintf(log_buffer, "ntbl_load_table(%s) %d windows, key %d",
			adapter, ts, key);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_DEBUG,
			jobid, log_buffer);
	}
	DBPRT(("%s: setup %d adapters\n", __func__, did))
	return (did == 0 ? PBSE_IBMSPSWITCH : PBSE_NONE);

err:
	/*
	 ** Getting here means we had a read failure.
	 */
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return PBSE_DISPROTO;
}

#elif	IBM_AIXIB

/**
 * @brief
 * 	Unload InfiniBand windows for a job.
 *
 * This will be different from the HPS unload since the nrt API
 * does not have the description to track the job id.  In this
 * case, we will just do the unload on all windows and depend
 * on the job_key to not match for windows owned by other jobs.
 *
 * @see dep_initialize
 *
 * @param[in] pjob - job pointer
 *
 * @return	int
 * @retval	PBSE_NONE	Success
 * @retval	PBSE error code	Error
 *
 */
int
aixib_cleanup(job *pjob)
{
	char		*jobid = pjob->ji_qs.ji_jobid;
	int		i, j, ret;
	uint16_t	windows;
	int		key;
	nrt_status_t	*astat, *ap;

	DBPRT(("%s: entry\n", __func__))

	if (pjob->ji_extended.ji_ext.ji_keysaved)
		key = pjob->ji_extended.ji_ext.ji_jobkey;
	else {
		DBPRT(("%s: NO SAVED KEY\n", __func__))
		return PBSE_NONE;
	}

	for (i=0; i<ib_num; i++) {
		int		found = 0, did = 0;
		char		*adap = ib_adapter[i];

		ret = xnrt_status_adapter(NRT_VERSION, adap,
			RSCT_DEVTYPE_INFINIBAND, &windows, &astat);
		if (ret != NRT_SUCCESS) {
			if (ret != NRT_EADAPTER) {
				sprintf(log_buffer,
					"nrt_status_adapter(%s) err %d",
					adap, ret);
				log_joberr(errno, __func__, log_buffer, jobid);
			}
			continue;
		}

		DBPRT(("%s: status returned %hu windows to check\n",
			__func__, windows))
		for (j=0; j<windows; j++) {
			ap = &astat[j];

			switch (ap->state) {
				case NRT_WIN_READY:
				case NRT_WIN_RUNNING:
					ret = xnrt_unload_window(NRT_VERSION, adap,
						RSCT_DEVTYPE_INFINIBAND,
						key, ap->window_id);
					if (ret == NRT_EINVAL) { /* wrong jobid */
						DBPRT(("%s: win %hu wrong jobid\n",
							__func__, ap->window_id))
						break;
					}

					found++;
					if (ret == NRT_SUCCESS) {
						did++;
						break;
					}

					sprintf(log_buffer,
						"nrt_unload_window(%s) err %d",
						adap, ret);
					log_joberr(errno, __func__, log_buffer, jobid);
					break;

				default:
					break;
			}
		}
		free(astat);
		sprintf(log_buffer, "%s(%s): %d windows, %d unloaded",
			__func__, adap, found, did);
		DBPRT(("%s\n", log_buffer))
		log_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB, LOG_DEBUG,
			jobid, log_buffer);
	}

	return PBSE_NONE;
}

/**
 * @brief
 * 	Get status for all possible adapters.
 *
 * @param[in] pjob - job pointer
 * @param[in] np - pointer to hnodent structure
 *
 * @return	int
 * @retval	PBSE_NONE		SUCCESS
 * @retval	PBSE_IBMSPSWITCH 15097  error
 * @see dep_initialize
 */
int
aixib_status(job *pjob, hnodent *np)
{
	char		*jobid = pjob->ji_qs.ji_jobid;
	int		did, i, j, k, ret;
	uint16_t		windows;
	adap_resources_t	res;
	nrt_status_t		*astat;
	struct	aixib_winfo	*wp;

	DBPRT(("%s: entry\n", __func__))

	/* allocate array of aixib_winfo pointers */
	np->hn_setup = calloc(ANUM, sizeof(struct aixib_winfo *));
	if (np->hn_setup == NULL)
		return ENOMEM;

	DBPRT(("%s: pick %d windows\n", __func__, np->hn_nprocs))
	for (did=0, i=0; i<ib_num; i++) {
		char	*adap = ib_adapter[i];
		int	ports = 0;

		ret = xnrt_adapter_resources(NRT_VERSION, adap,
			RSCT_DEVTYPE_INFINIBAND, &res);
		if (ret != NRT_SUCCESS) {
			sprintf(log_buffer,
				"nrt_adapter_resources(%s) err %d",
				adap, ret);
			log_joberr(errno, __func__, log_buffer, jobid);
			continue;
		}
		free(res.window_list);	/* don't need window_list */

		/*
		 * Check if adapter has any ports configured.
		 * Don't count anything not in state RSCT_NAM_CONNECT_UP.
		 */
		for (j=0; j<res.num_spigots; j++) {
			if (res.status_vec[j] == RSCT_NAM_CONNECT_UP)
				ports++;
		}
		if (ports == 0) {
			sprintf(log_buffer, "InfiniBand adapter %s has no "
				"network spigots configured", adap);
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB,
				LOG_WARNING, jobid, log_buffer);			
			continue;
		}

		wp = (struct aixib_winfo *)malloc(sizeof(struct aixib_winfo));
		if (wp == NULL)
			return ENOMEM;
		memset(wp, 0, sizeof(*wp));

		wp->win = (int *)calloc(res.window_count, sizeof(int));
		if (wp->win == NULL) {
			free(wp);
			return ENOMEM;
		}

		ret = xnrt_status_adapter(NRT_VERSION, adap,
			RSCT_DEVTYPE_INFINIBAND, &windows, &astat);
		if (ret != NRT_SUCCESS) {
			sprintf(log_buffer,
				"nrt_status_adapter(%s) err %d",
				adap, ret);
			log_joberr(errno, __func__, log_buffer, jobid);
			free(wp->win);
			free(wp);
			continue;
		}

		wp->adapter = strdup(adap);
		if (wp->adapter == NULL) {
			free(wp->win);
			free(wp);
			free(astat);
			return ENOMEM;
		}

		wp->node = res.node_number;
		ports = 0;
		for (j=0; j<res.num_spigots; j++) {
			if (res.status_vec[j] != RSCT_NAM_CONNECT_UP) {
				DBPRT(("%s: %s port %d NOT UP\n", __func__, adap,
					(int)res.spigot_id[j]))
				continue;
			}
			DBPRT(("%s: %s netid %llu lid %d\n", __func__, adap,
				res.network_id[j], (int)res.lid[j]))
			wp->netid[ports] = res.network_id[j];
			wp->lid[ports] = res.lid[j];
			wp->lmc[ports] = res.lmc[j];
			wp->portid[ports++] = res.spigot_id[j];
		}
		wp->ports = ports;

		DBPRT(("%s: window ids: ", __func__))
		k = 0;
		for (j=0; j<windows; j++) {
			if (astat[j].state == NRT_WIN_AVAILABLE) {
				wp->win[k++] = (int)astat[j].window_id;
				DBPRT(("%d ", (int)astat[j].window_id))
			}
		}
		DBPRT(("\n\ttotal %d\n", k))
		wp->numwin = k;
		free(astat);

		((struct aixib_winfo **)np->hn_setup)[did++] = wp;
	}

	if (did == 0) {
		free(np->hn_setup);
		np->hn_setup = NULL;
		log_joberr(-1, __func__,
			"no available windows on any InfiniBand adapter",
			jobid);
		return PBSE_IBMSPSWITCH;
	}

	return PBSE_NONE;
}

/**
 * @brief
 * 	Write InfiniBand setup info saved by aixib_status back to MS.
 * 	If there are less than ANUM adapters, a NULL string will be sent
 * 	for the adapter name.
 *
 * @param[in] pjob - job pointer
 * @param[in] np - pointer to hnodent structure
 * @param[in] stream - fd
 *
 * @return      int
 * @retval      DIS_SUCCESS             Success
 * @retval      DIS_* error code        Error
 *
 * @see aixib_read
 *
 * A list of job keys in use on the local mom will be added after all
 * the adapter info.  The IM_JOINX_IBMHPS version number is not changed
 * even though the protocol is different because this would cause any
 * IB MOM that does not support array jobs to reject the message completely.
 * Using the same version number will work because an IB MOM that does not
 * support array jobs will simply ignore the extra information.  An IB MOM
 * that does support array jobs reading from an IB MOM that does not support
 * array jobs can detect the end of data.
 *
 *
 * Protocol used to send the setup info.
 * @verbatim
 *	version		int
 *	adaptername1	string
 *		node	uint
 *		ports	uchar
 *			lid	ushort
 *			netid	ulonglong
 *			lmc	uchar
 *			portid	uchar
 *		numwin	int
 *		win1	int
 *		...
 *		winN	int
 *	adaptername2	string
 *		...
 *	keycount	int
 *	jobkey0		int
 *	jobkey1		int
 *	...
 * @endverbatim
 */
int
aixib_ack(job *pjob, hnodent *np, int stream)
{
	int	i, j, ret;
	job	*pj;
	struct	aixib_winfo	**winfo;

	DBPRT(("%s: entry\n", __func__))
	ret = diswsi(stream, IM_JOINX_AIXIB);
	if (ret != DIS_SUCCESS)
		goto done;

	winfo = (struct aixib_winfo **)np->hn_setup;
	for (i=0; i<ANUM; i++) {
		struct	aixib_winfo	*wp = winfo[i];

		if (wp == NULL) {
			ret = diswst(stream, "");
			if (ret != DIS_SUCCESS)
				goto done;
			break;
		}
		ret = diswst(stream, wp->adapter);
		if (ret != DIS_SUCCESS)
			goto done;
		ret = diswui(stream, wp->node);
		if (ret != DIS_SUCCESS)
			goto done;
		ret = diswuc(stream, wp->ports);
		if (ret != DIS_SUCCESS)
			goto done;

		/* write all netid/port info */
		for (j=0; j<wp->ports; j++) {
			ret = diswus(stream, wp->lid[j]);
			if (ret != DIS_SUCCESS)
				goto done;
			ret = diswull(stream, wp->netid[j]);
			if (ret != DIS_SUCCESS)
				goto done;
			ret = diswuc(stream, wp->lmc[j]);
			if (ret != DIS_SUCCESS)
				goto done;
			ret = diswuc(stream, wp->portid[j]);
			if (ret != DIS_SUCCESS)
				goto done;
		}
		ret = diswsi(stream, wp->numwin);
		if (ret != DIS_SUCCESS)
			goto done;

		/* here's all the free windows */
		for (j=0; j<wp->numwin; j++) {
			ret = diswsi(stream, wp->win[j]);
			if (ret != DIS_SUCCESS)
				goto done;
		}
	}

	ret = write_keys(pjob, stream);
	if (ret != DIS_SUCCESS)
		goto done;

	return DIS_SUCCESS;

done:
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return ret;
}

/**
 * @brief
 * 	Read the extra information being sent by a sister with aixib_ack after
 * 	a good JOIN_JOB reply.
 * 	I am mother superior.
 *
 * @param[in] pjob - job pointer
 * @param[in] np - pointer to hnodent structure
 * @param[in] stream - fd
 *
 * @return      int
 * @retval      DIS_SUCCESS             Success
 * @retval      DIS_* error code        Error
 *
 * @see aixib_ack
 */
int
aixib_read(job *pjob, hnodent *np, int stream)
{
	int	i, j, ret;
	int	version;
	char	*adapter;
	struct	aixib_winfo	*wp;

	DBPRT(("%s: entry\n", __func__))
	version = disrsi(stream, &ret);
	if (ret != DIS_SUCCESS)
		goto err;
	/*
	 ** Check the type of extra information being sent.
	 ** If I don't understand it, don't accept the job.
	 */
	if (version != IM_JOINX_AIXIB) {
		sprintf(log_buffer, "received version %d from %s, "
			"expected %d", version, np->hn_host, IM_JOINX_AIXIB);
		log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
		return DIS_PROTO;
	}

	/*
	 ** Remove any old information then read the new data.
	 */
	switch_freenode(pjob, np);

	/* allocate array of aixib_winfo pointers */
	np->hn_setup = calloc(ANUM, sizeof(struct aixib_winfo *));
	if (np->hn_setup == NULL)
		return DIS_NOMALLOC;

	for (i=0; i<ANUM; i++) {
		adapter = disrst(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;

		if (adapter == NULL || *adapter == '\0') {
			DBPRT(("%s: adapter = NULL\n", __func__))
			break;
		}

		wp = (struct aixib_winfo *)malloc(sizeof(struct aixib_winfo));
		if (wp == NULL)
			return DIS_NOMALLOC;
		memset(wp, 0, sizeof(*wp));
		((struct aixib_winfo **)np->hn_setup)[i] = wp;

		wp->adapter = adapter;
		wp->node = disrui(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;
		wp->ports = disruc(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;
		if (wp->ports > MAX_SPIGOTS) {
			DBPRT(("%s: bad ports value %d\n", (int)wp->ports))
			return DIS_HUGEVAL;
		}

		for (j=0; j<wp->ports; j++) {
			wp->lid[j] = disrus(stream, &ret);
			if (ret != DIS_SUCCESS)
				goto err;
			wp->netid[j] = disrull(stream, &ret);
			if (ret != DIS_SUCCESS)
				goto err;
			wp->lmc[j] = disruc(stream, &ret);
			if (ret != DIS_SUCCESS)
				goto err;
			wp->portid[j] = disruc(stream, &ret);
			if (ret != DIS_SUCCESS)
				goto err;
			DBPRT(("%s: %s(%d) port %d netid %llu lid %d lmc %d\n",
				__func__, adapter, j, (int)wp->portid[j],
				wp->netid[j], wp->lid[j], wp->lmc[j]))
		}
		wp->numwin = disrsi(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;

		wp->win = (int *)calloc(wp->numwin, sizeof(int));
		if (wp->win == NULL)
			return DIS_NOMALLOC;

		DBPRT(("%s: read %d window ids: ", __func__, wp->numwin))
		for (j=0; j<wp->numwin; j++) {
			wp->win[j] = disrsi(stream, &ret);
			if (ret != DIS_SUCCESS)
				goto err;
			DBPRT(("%d ", wp->win[j]))
		}
		DBPRT(("\n"))
	}
	DBPRT(("%s: got %d adapters\n", __func__, i))

	ret = read_keys(stream, np);
	if (ret != DIS_SUCCESS)
		goto err;

	return DIS_SUCCESS;

err:
	/*
	 ** Getting here means we had a read failure.
	 */
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return ret;
}

/**
 * @brief
 * Send the complete set of window id's for InfiniBand setup.
 * Called from send_sisters.  I am Mother Superior.
 *
 * A new element is added to support array jobs.  The job key
 * is chosen by MS and sent off to all the sisters at the end
 * of this message.
 *
 * @param[in] pjob - job pointer
 * @param[in] np - pointer to hnodent structure
 * @param[in] stream - fd
 *
 * @return      int
 * @retval      DIS_SUCCESS             Success
 * @retval      DIS_* error code        Error
 *
 * @see send_sisters
 */
int
aixib_send(job *pjob, hnodent *xp, int stream)
{
	int	i, j, k, ret, key;
	struct	aixib_winfo	**winfo;

	DBPRT(("%s: entry send to host %s\n", __func__, xp->hn_host))
	ret = diswsi(stream, IM_JOINX_IBMHPS);
	if (ret != DIS_SUCCESS)
		goto done;

	/* send all the windows ids */
	for (i=0; i<pjob->ji_numnodes; i++) {
		hnodent *np = &pjob->ji_hosts[i];

		if (xp == np) {	/* don't need to send node's own info */
			DBPRT(("%s: skip info from self\n", __func__))
			continue;
		}

		winfo = (struct aixib_winfo **)np->hn_setup;
		for (j=0; j<ANUM; j++) {
			struct	aixib_winfo	*wp = winfo[j];

			if (wp == NULL) {
				ret = diswst(stream, "");
				if (ret != DIS_SUCCESS)
					goto done;
				break;
			}
			DBPRT(("%s: send %d info from %d %s nodenum %d\n",
				__func__, xp->hn_node, np->hn_node,
				wp->adapter, wp->node))
			ret = diswst(stream, wp->adapter);
			if (ret != DIS_SUCCESS)
				goto done;
			ret = diswui(stream, wp->node);
			if (ret != DIS_SUCCESS)
				goto done;
			ret = diswuc(stream, wp->ports);
			if (ret != DIS_SUCCESS)
				goto done;

			/* port information */
			for (k=0; k<wp->ports; k++) {
				ret = diswus(stream, wp->lid[k]);
				if (ret != DIS_SUCCESS)
					goto done;
				ret = diswull(stream, wp->netid[k]);
				if (ret != DIS_SUCCESS)
					goto done;
				ret = diswuc(stream, wp->lmc[k]);
				if (ret != DIS_SUCCESS)
					goto done;
				ret = diswuc(stream, wp->portid[k]);
				if (ret != DIS_SUCCESS)
					goto done;
				DBPRT(("%d\tport %d lid %d netid %llu lmc %d\n",
					k, (int)wp->portid[k], (int)wp->lid[k],
					wp->netid[k], (int)wp->lmc[k]))
			}
			ret = diswsi(stream, wp->numwin);
			if (ret != DIS_SUCCESS)
				goto done;

			/* window id's */
			for (k=0; k < wp->numwin; k++) {
				ret = diswsi(stream, wp->win[k]);
				if (ret != DIS_SUCCESS)
					goto done;
			}
		}
	}
	key = make_jobkey(pjob, INUSE_CONTINUE);
	if (key < 0) {
		log_joberr(-1, __func__, "could not create job key",
			pjob->ji_qs.ji_jobid);
		return PBSE_INTERNAL;
	}

	ret = diswsi(stream, key);
	if (ret != DIS_SUCCESS)
		goto done;

	return DIS_SUCCESS;

done:
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return ret;
}

struct	ainfo {
	struct	aixib_winfo	*ai_winfo;
	int	ai_portindex;
};

/**
 * @brief
 * 	Called to read the window id's for InfiniBand setup.
 * 	The stream parameter will not be used by Mother Superior.
 * 	She uses the information saved in the job structure.
 *
 * @param[in] pjob - job pointer
 * @param[in] stream - stream to read
 *
 * Once all the information is available, calculate the
 * window set to be used for each load.  A call to load
 * the switch has one network id and a window for each
 * task in the job.
 *
 * @see dep_initialize
 *
 * @return 	int
 * @retval	PBSE_NONE		SUCCESS
 * @retval 	PBSE_NOSUP		Feature/function not supported
 * @retval	ENOMEM			Out of memory
 * @retval	DIS_HUGEVAL		Tried to write floating point infinity
 * @retval	PBSE_INTERNAL 		internal server error occurred
 * @retval	PBSE_IBMSPSWITCH	IBM SP Switch error
 * @retval	PBSE_DISPROTO		Bad DIS based Request Protocol 
 */		
int
aixib_setup(job *pjob, int stream)
{
	char	*jobid = pjob->ji_qs.ji_jobid;
	int	i, j, k, ret;
	int	node, portindex;
	int	version;
	char	*adapter;
	struct	aixib_winfo	*wp;
	nrt_creator_per_task_input_t	*table;
	int	ts, jobprocs, jobwins, instances;
	int	key;
	int	did = 0;
	int	did_adapters = 0;
	int	**awins;
	uint64_t	netid[ANUM*MAX_ALLOCS];	/* possible nets */
	int		numnets = 0;	/* how many networks there are */
	int		allocnets;	/* how many networks we use */
	int	net;
	struct	ainfo	adaps[ANUM];
	int	aidx, numadaps;
	hnodent	*mynode;


	DBPRT(("%s: entry stream %d\n", __func__, stream))
	/*
	 ** Check if I am Mother Superior.  If not, read in
	 ** information from stream.
	 */
	if (pjob->ji_hosts[0].hn_node != pjob->ji_nodeid) {
		version = disrsi(stream, &ret);
		if (ret != DIS_SUCCESS)
			goto err;
		/*
		 ** Check the type of extra information being sent.
		 ** If I don't understand it, don't accept the job.
		 */
		if (version != IM_JOINX_AIXIB) {
			sprintf(log_buffer, "received version %d from %s, "
				"expected %d", version, IM_JOINX_AIXIB);
			log_joberr(-1, __func__, log_buffer, jobid);
			return PBSE_NOSUP;
		}

		for (i=0; i<pjob->ji_numnodes; i++) {
			hnodent *np = &pjob->ji_hosts[i];

			if (np->hn_node == pjob->ji_nodeid)	/* skip me */
				continue;

			DBPRT(("%s: reading for node %d\n", __func__, np->hn_node))
			/*
			 ** Remove any old information then read the new data.
			 */
			switch_freenode(pjob, np);

			/* allocate array of aixib_winfo pointers */
			np->hn_setup = calloc(ANUM,
				sizeof(struct aixib_winfo *));
			if (np->hn_setup == NULL)
				return ENOMEM;

			for (j=0; j<ANUM; j++) {
				adapter = disrst(stream, &ret);
				if (ret != DIS_SUCCESS)
					goto err;

				if (adapter == NULL || *adapter == '\0') {
					DBPRT(("%s: adapter = NULL\n", __func__))
					break;
				}

				wp = (struct aixib_winfo *)
					malloc(sizeof(struct aixib_winfo));
				if (wp == NULL) {
					free(adapter);
					return ENOMEM;
				}

				/*
				 ** Zero the new structure and point the
				 ** array entry in hn_setup so it can be
				 ** cleaned up.
				 */
				memset(wp, 0, sizeof(struct aixib_winfo));
				((struct aixib_winfo **)np->hn_setup)[j] = wp;

				wp->adapter = adapter;
				wp->node = disrui(stream, &ret);
				if (ret != DIS_SUCCESS)
					goto err;
				wp->ports = disruc(stream, &ret);
				if (ret != DIS_SUCCESS)
					goto err;
				if (wp->ports > MAX_SPIGOTS) {
					DBPRT(("%s: bad ports value %d\n",
						(int)wp->ports))
					return DIS_HUGEVAL;
				}

				for (k=0; k<wp->ports; k++) {
					wp->lid[k] = disrus(stream, &ret);
					if (ret != DIS_SUCCESS)
						goto err;
					wp->netid[k] = disrull(stream, &ret);
					if (ret != DIS_SUCCESS)
						goto err;
					wp->lmc[k] = disruc(stream, &ret);
					if (ret != DIS_SUCCESS)
						goto err;
					wp->portid[k] = disruc(stream, &ret);
					if (ret != DIS_SUCCESS)
						goto err;
					DBPRT(("%s: %s(%d) port %d netid %llu "
						"lid %d lmc %d\n", __func__,
						adapter, k, (int)wp->portid[k],
						wp->netid[k],
						wp->lid[k], wp->lmc[k]))
				}
				wp->numwin = disrsi(stream, &ret);
				if (ret != DIS_SUCCESS)
					goto err;

				wp->win = (int *)calloc(wp->numwin,
					sizeof(int));
				if (wp->win == NULL)
					return ENOMEM;

				DBPRT(("%s: read %d window ids: ", __func__,
					wp->numwin))
				for (k=0; k<wp->numwin; k++) {
					wp->win[k] = disrsi(stream, &ret);
					if (ret != DIS_SUCCESS)
						goto err;
					DBPRT(("%d ", wp->win[k]))
				}
				DBPRT(("\n"))
			}
			DBPRT(("%s: node %d got %d adapters\n", __func__,
				np->hn_node, j))
		}
		/**
		 * Now read the jobkey if it has been sent.  If it has
		 * not been sent, the MS is an IB MOM that does not
		 * support array jobs which means
		 * the job is not an array job.  We could still have a
		 * problem if keys have been generated using the conflict
		 * detection algorithm @see make_jobkey.
		 * Set the flag to fail if there is a conflict.
		 */
		key = disrsi(stream, &ret);
		if (ret == DIS_EOD) {
			DBPRT(("%s: NOT SENT - make it\n", __func__))
			key = make_jobkey(pjob, INUSE_FAIL);
			if (key < 0) {
				log_joberr(-1, __func__,
					"could not create local job key",
					jobid);
				return PBSE_INTERNAL;
			}
		} else if (ret == DIS_SUCCESS) {
			pjob->ji_extended.ji_ext.ji_keysaved = 1;
			pjob->ji_extended.ji_ext.ji_jobkey = key;
			(void)job_save(pjob, SAVEJOB_QUICK);
		} else
			goto err;
	} else {
		/*
		 * I am mother superior.
		 * In a multi-node job, the jobkey will have already created
		 * in aixib_send.  If not, create it here.
		 */
		if (pjob->ji_extended.ji_ext.ji_keysaved)
			key = pjob->ji_extended.ji_ext.ji_jobkey;
		else {
			key = make_jobkey(pjob, INUSE_CONTINUE);
			if (key < 0) {
				log_joberr(-1, __func__,
					"could not create job key",
					jobid);
				return PBSE_INTERNAL;
			}
		}
	}

	/*
	 ** Now we have the information to do the InfiniBand setup.
	 ** Free any old setup info.
	 */
	if (pjob->ji_setup != NULL) {
		int	**awins = (int **)pjob->ji_setup;

		DBPRT(("%s: free old ji_setup\n", __func__))
		for (i=0; i<MAX_ALLOCS; i++) {
			if (awins[i] != NULL)
				free(awins[i]);
		}
		free(pjob->ji_setup);
		pjob->ji_setup = NULL;
	}

	/*
	 ** For best performance, we want to load a window per process
	 ** from all networks.  Each adapter has a number of ports that
	 ** each give access to a network.
	 */
	jobprocs = 0;
	jobwins = 0;
	for (node=0; node<pjob->ji_numnodes; node++) {
		hnodent	*np = &pjob->ji_hosts[node];

		/* Count the total number of processes across all nodes. */
		jobprocs += np->hn_nprocs;
		
		DBPRT(("%s: node %d \n", __func__,
			np->hn_node )

		for (i=0; i<ANUM; i++) {
			/* info for adapter i */
			wp = ((struct aixib_winfo **)np->hn_setup)[i];
			if (wp->adapter == NULL)
				break;	/* out of adapters */

			/*
			 ** Look through the ports to get all the netid's.
			 */
			for (j=0; j<wp->ports; j++) {
				for (k=0; k < numnets; k++) {
					if (netid[k] == wp->netid[j])
						break;	/* already seen */
				}
				if (k == numnets)	/* another net */
					netid[numnets++] = wp->netid[j];
			}
		}
	}

	if (numnets == 0) {
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_WARNING,
			jobid, "no InfiniBand networks found");
		return PBSE_IBMSPSWITCH;
	}
	if (jobprocs == 0)
		return PBSE_INTERNAL;

	/*
	 ** Instances - windows per process per network
	 ** The default and minimum is 1.
	 */
	instances = (jobwins == 0) ? 1 : ((jobwins / jobprocs) / numnets);
	if (instances < 1)
		instances = 1;

	if (jobwins > 0 && jobwins <= jobprocs)		/* doing sn_single */
		allocnets = 1;
	else				/* sn_all */
		allocnets = numnets * instances;

	/*
	 ** Allocate array to hold table information for the environment.
	 ** It will be NULL terminated.
	 */
	awins = (int **)calloc(allocnets + 1, sizeof(awins));
	if (awins == NULL)
		return ENOMEM;
	pjob->ji_setup = (void *)awins;

	table = (nrt_creator_per_task_input_t *)calloc(jobprocs+1,
		sizeof(nrt_creator_per_task_input_t));
	if (table == NULL)
		return ENOMEM;

	/*
	 ** Loop over each network.
	 */
	for (net=0; net < allocnets; net++) {
		/*
		 ** Calculate the network index even if we use each
		 ** network more than once.
		 */
		uint64_t	currnet = netid[net % numnets];
		ts = 0;		/* restart load table */
		did_adapters = 0;

		DBPRT(("%s: net %llu\n", __func__, currnet))

		/*
		 ** Save table info for the environment.
		 */
		awins[net] = (int *)calloc(jobprocs*2 + 1, sizeof(*awins));
		if (awins[did] == NULL)
			break;

		mynode = NULL;
		for (node=0; node<pjob->ji_numnodes; node++) {
			hnodent	*np = &pjob->ji_hosts[node];

			/*
			 ** remember if this is me.
			 */
			if (np->hn_node == pjob->ji_nodeid)
				mynode = np;

			/*
			 ** For each node, get the information for all adapters
			 ** that have this network.
			 */
			numadaps = 0;
			for (i=0; i<ANUM; i++) {
				/* info for adapter i */
				wp = ((struct aixib_winfo **)np->hn_setup)[i];
				if (wp->adapter == NULL)
					break;	/* out of adapters */

				for (portindex=0; portindex<wp->ports;
					portindex++) {
					if (currnet == wp->netid[portindex])
						break;
				}
				if (portindex == wp->ports) {
					DBPRT(("%s: %s doesn't have net %llu\n",
						__func__, wp->adapter, currnet))
					continue;
				}

				adaps[numadaps].ai_portindex = portindex;
				adaps[numadaps++].ai_winfo = wp;

				DBPRT(("%s: %s port %d lid %d\n", __func__,
					wp->adapter,
					wp->portid[portindex],
					wp->lid[portindex]))
			}

			/* This network is unavailable on this node */
			if (numadaps == 0)
				break;

			/*
			 ** For each process on the node, pick a window.
			 */
			aidx = 0;
			for (i=0; i<np->hn_nprocs; i++) {
				int	ii = adaps[aidx].ai_portindex;
				wp = adaps[aidx].ai_winfo;

				/*
				 ** Pick one window for tasks on this node.
				 */
				for (k=0; k<wp->numwin; k++) {
					/* check if available */
					if (wp->win[k] >= 0)
						break;
				}
				if (k == wp->numwin)	/* none free */
					break;

				table[ts].ib_per_task.task_id = ts;
				table[ts].ib_per_task.win_id = wp->win[k];
				table[ts].ib_per_task.base_lid = wp->lid[ii];
				table[ts].ib_per_task.node_number = wp->node;
				strncpy(table[ts].ib_per_task.device_name,
					wp->adapter, NRT_MAX_DEVICENAME_SIZE);
				table[ts].ib_per_task.lmc = wp->lmc[ii];
				table[ts].ib_per_task.port_id = wp->portid[ii];

				/*
				 ** Save an array for each network with
				 ** two numbers for each process:
				 **   the adapter number
				 **   the window number
				 */
				awins[net][ts*2] = atoi(&wp->adapter[3]);
				awins[net][ts*2+1] = wp->win[k];

				/*
				 ** Having allocated this window, we need
				 ** to mark it used so we won't double
				 ** book it.  Use -1 for this because
				 ** winid's from the status call are
				 ** unsigned and will never be negative.
				 */
				wp->win[k] = -1;

				ts++;
				aidx = (aidx + 1) % numadaps;
			}

			/* we didn't find enough windows */
			if (i < np->hn_nprocs) {
				DBPRT(("%s: node %d adapter %s netid %llu "
					"only %d of %d windows found\n", __func__,
					node, wp->adapter, currnet,
					i, np->hn_nprocs))
				break;
			}
		}
		awins[net][ts*2] = -1;

		/*
		 ** If the loop across nodes did not complete,
		 ** or a table entry was not found for each mpiproc,
		 ** or (safety check) mynode is still NULL,
		 ** skip the loads for this network.
		 */
		if (node < pjob->ji_numnodes ||
			ts < jobprocs ||
			mynode == NULL) {
			DBPRT(("%s: not all nodes were loaded\n", __func__))
			continue;
		}

		/*
		 * Do a load on each local adapter that has this netid.
		 */
		for (i=0; i<ANUM; i++) {
			/* info for adapter i */
			wp = ((struct aixib_winfo **)mynode->hn_setup)[i];
			if (wp->adapter == NULL)
				break;	/* out of adapters */

			for (portindex=0; portindex<wp->ports; portindex++) {
				if (currnet == wp->netid[portindex])
					break;
			}
			if (portindex == wp->ports) {
				DBPRT(("%s: %s doesn't have net %llu\n",
					__func__, wp->adapter, currnet))
				continue;
			}

			/*
			 * Now we make the nrt_load_table_rdma call.
			 * We ignore the error NRT_ALREADY_LOADED
			 * because IBM "broke binary compatability"
			 * with NRT_VERSION 520.
			 */
			ret = xnrt_load_table_rdma(NRT_VERSION, wp->adapter,
				RSCT_DEVTYPE_INFINIBAND, currnet,
				(uid_t)pjob->ji_qs.ji_un.ji_momt.ji_exuid,
				(pid_t)mom_pid, (ushort)key, jobid,
				0, 0, ts, table);
			if ((ret != NRT_SUCCESS) &&
				(ret != NRT_ALREADY_LOADED)) {
				free(table);
				sprintf(log_buffer, "nrt_load_table_rdma(%s) "
					"key %d err %d", wp->adapter, key, ret);
				log_joberr(errno, __func__, log_buffer, jobid);
				return PBSE_IBMSPSWITCH;
			}
			sprintf(log_buffer, "nrt_load_table_rdma(%s) %d "
				"windows, key %d", wp->adapter,
				ts, key);
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_DEBUG,
				jobid, log_buffer);
			did_adapters++;
		}

		DBPRT(("%s: net %llu setup %d adapters\n", __func__,
			currnet, did_adapters))
		/*
		 * If we could load any adpaters for this network,
		 * say we did it.
		 */
		if (did_adapters > 0)
			did++;
	}

	free(table);
	if (did == 0) {
		sprintf(log_buffer, "could not load %d windows",
			(jobwins > 0) ? jobwins : jobprocs);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_WARNING,
			jobid, log_buffer);
		return PBSE_IBMSPSWITCH;
	}

	return PBSE_NONE;

err:
	/*
	 ** Getting here means we had a read failure.
	 */
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return PBSE_DISPROTO;
}

#endif

/**
 * @brief
 * 	sys_pcpu_count() -  Count the physical cpus(cores) in the AIX system.
 *
 * @return	int
 * @retval	pcpus (physical cpu count)	Success
 * 
 * Linkage scope - static
 *
 * @see		dep_initialize().
 */
static int
sys_pcpu_count()
{
	int pcpus = sysconf(_SC_NPROCESSORS_ONLN);
#if defined(__SMT_ENABLED) /* built-in macro in AIX version >= 5.3 */
	/*
	 * check if the built-in MACRO __SMT_ENABLED is defined
	 * (which is in <sys/systemcfg.h>). If yes, then this version
	 * of AIX supports SMT feature. If SMT is enabled, then divide
	 * logical cpus by the no. of SMT per cpu to get the pcpus.
	 */
	if (__SMT_ENABLED()) {
		int smtpc = _system_configuration.smt_threads;
		pcpus = (int)(pcpus / smtpc);
	}
#endif /* __SMT_ENABLED */
	return (pcpus);
}

/**
 * @brief 
 *	Called from machine independent code to do any machine
 * 	dependent initialization.
 * 	For InfiniBand, the network is checked and a log message
 * 	is generated.
 *
 * @par Side-effects:
 * The globals ib_num and ib_adapter are set here and used in
 * other functions so non-existent adapters are not constantly
 * being checked for status.  This apprently causes system log
 * message which alarm administrators.
 *
 * @see ib_num
 * @see ib_adapter
 * @see aixib_status
 * @see aixib_cleanup
 *
 * @return	Void
 *
 */
void
dep_initialize()
{
	int	i, rc, len;
	char	line[200], *dev;
	char	*swapfil = "/etc/swapspaces";
	FILE	*fil;
	struct CuAt * obj;
	int	      qty;

	if (swap_dev == NULL) {
		swap_dev = (char **)calloc(10, sizeof(char *));
		if (swap_dev == NULL)
			goto outofmem;
	}

	page_size = sysconf(_SC_PAGESIZE);

	if ((fil = fopen(swapfil, "r")) == NULL)
		log_err(errno, __func__, swapfil);
	else {
		char **tmpswap_dev;

		for (i=0; fgets(line, sizeof(line), fil);) {
			if (line[0] == '*')
				continue;
			len = strlen(line);
			if (line[len-1] == '\n')
				line[--len] = '\0';
			if ((dev = strstr(line, "/dev/")) == NULL)
				continue;
			DBPRT(("%s: swapdev(%d) %s\n", __func__, i, dev))
			tmpswap_dev = realloc(swap_dev, (i+2)*sizeof(char *));
			if (tmpswap_dev == NULL)
				goto outofmem;
			swap_dev = tmpswap_dev;
			swap_dev[i] = strdup(dev);
			if (swap_dev[i++] == NULL)
				goto outofmem;
		}
		swap_dev[i] = NULL;
		fclose(fil);
	}

	if ((kd = open("/dev/kmem", O_RDONLY)) == -1) {
		log_err(errno, __func__, "open");
		return;
	}

	/* insure /dev/kmem closed on exec */

	if ((i = fcntl(kd,  F_GETFD)) == -1) {
		log_err(errno, __func__, "F_GETFD");
	}
	i |= FD_CLOEXEC;
	if (fcntl(kd, F_SETFD, i) == -1) {
		log_err(errno, __func__, "F_SETFD");
	}

	proc_tbl = malloc(ASIZE*sizeof(struct procsinfo));
	if (proc_tbl == NULL)
		goto outofmem;
	proctot = ASIZE;

	rc = knlist(nl, sizeof(nl)/sizeof(struct nlist), sizeof(struct nlist));
	if (rc == -1) {
		log_err(errno, __func__, "knlist");
		return;
	}
#ifdef	DEBUG
	for (i=0; i<sizeof(nl)/sizeof(struct nlist); i++)
		printf("%s: %s @ %x\n", __func__, nl[i].n_name, nl[i].n_value);
#endif

	/*	The original version of the following code was
	 *	supplied by Lloyd Caldwell, U of Utah
	 */
	if (odm_initialize() == 0) {
		DBPRT(("odm_initialize returned ok\n"))
		obj = getattr("sys0", "realmem", 0, &qty) ;
		if (obj == NULL) {
			/*
			 * In this case we try setting a default path
			 * to find the object.
			 */
			char	*oldpath = odm_set_path("/etc/objrepos");

			if (oldpath == (char *)-1)
				log_err(odmerrno, __func__, "odm_set_path");
			else {
				obj = getattr("sys0", "realmem", 0, &qty) ;
				if (obj == NULL)
					log_err(odmerrno, __func__, "getattr");
				else
					realmem = atoi(obj->value);
				free(oldpath);
			}
		} else {
			realmem = atoi(obj->value);	/* in KB */
		}

		if (odm_terminate()) {
			log_err(odmerrno, __func__, "odm_terminate for realmem");
			DBPRT(("odm_terminate failed\n"))
		}
	} else {
		DBPRT(("odm_initialize failed\n"))
		log_err(odmerrno, __func__, "odm_initialize for realmem");
	}

	/*
	 ** No longer want to look at physical processors, only
	 ** what is available in our partition.
	 */
	/*	num_pcpus = sysconf(_SC_NPROCESSORS_CONF); */
	num_pcpus = num_acpus = sys_pcpu_count();

#if	IBM_HPS
	job_join_extra = hps_status;
	job_join_ack = hps_ack;
	job_join_read = hps_read;
	job_setup_send = hps_send;
	job_setup_final = hps_setup;
	job_clean_extra = hps_cleanup;
	job_free_extra = switch_free;
	job_free_node = switch_freenode;
#elif	IBM_AIXIB
	job_join_extra = aixib_status;
	job_join_ack = aixib_ack;
	job_join_read = aixib_read;
	job_setup_send = aixib_send;
	job_setup_final = aixib_setup;
	job_clean_extra = aixib_cleanup;
	job_free_extra = switch_free;
	job_free_node = switch_freenode;
	/*
	 **	Log infiniband information.
	 */
	{
		adap_resources_t	res;
		int			ret, i, j, k;
		int			net_cnt = 0;
		int			win_cnt = 0;
		int			rerr = 1;	/* error case */
		uint64_t	netid[ANUM*MAX_ALLOCS];	/* possible nets */
		int		numnets = 0;	/* how many networks there are */
		char		count[128];	/* string value of resources */
		char		*adap;
		extern vnl_t	*vnlp;
		char		*attr;

		ib_num = 0;
		for (i=0; i<ANUM; i++) {
			adap = ib_adapter[ib_num];

			sprintf(adap, "iba%d", i);
			ret = xnrt_adapter_resources(NRT_VERSION, adap,
				RSCT_DEVTYPE_INFINIBAND, &res);
			if (ret != NRT_SUCCESS) {
				if (ret != NRT_EADAPTER) {
					sprintf(log_buffer,
						"nrt_adapter_resources(%s) err %d",
						adap, ret);
					log_err(errno, __func__, log_buffer);
				}
				continue;
			}
			free(res.window_list);	/* don't need window_list */

			/* increment adapter count */
			ib_num++;

			/* if there are no spigots, don't increment window count */
			if (res.num_spigots == 0) {
				sprintf(log_buffer, "WARNING: InfiniBand adapter %s "
					"has no network spigots configured", adap);
				log_event(PBSEVENT_SYSTEM, 0, LOG_NOTICE, __func__,
					log_buffer);
				continue;
			}

			win_cnt += res.window_count;
			for (j=0; j < res.num_spigots; j++) {
				/*
				 ** Look through the ports to get all the netid's.
				 */
				for (k=0; k < numnets; k++) {
					if (netid[k] == res.network_id[j])
						break;	/* already seen */
				}
				if (k == numnets)	/* another net */
					netid[numnets++] = res.network_id[j];
			}
		}
		sprintf(log_buffer, "detected %d InfiniBand adapters connected to "
			"%d networks using %d windows", ib_num, numnets, win_cnt);
		log_event(PBSEVENT_SYSTEM, 0, LOG_NOTICE, __func__, log_buffer);

		if (vnlp == NULL) {
			if (vnl_alloc(&vnlp) == NULL) {
				log_err(errno, __func__, "vnl_alloc failed!");
				goto bad_vnl;
			}
		}

		/*
		 * Check to see if ncpus or mem already exist.  If so,
		 * don't replace them.
		 */
		attr = "resources_available.ncpus";
		if (!vn_exist(vnlp, mom_short_name, attr)) {
			sprintf(count, "%d", num_acpus);
			if (vn_addvnr(vnlp, mom_short_name, attr, count, 0, 0, NULL) == -1)
				goto bad_vnl;
		}

		attr = "resources_available.mem";
		if (!vn_exist(vnlp, mom_short_name, attr)) {
			sprintf(count, "%ukb", realmem);
			if (vn_addvnr(vnlp, mom_short_name, attr, count, 0, 0, NULL) == -1)
				goto bad_vnl;
		}

		vnlp->vnl_modtime = time(NULL);
		rerr = 0;

bad_vnl:
		if (rerr && vnlp != NULL) {
			vnl_free(vnlp);
			vnlp = NULL;
		}
	}
#endif	/* IBM_AIXIB */

	mom_topology();
	return;

outofmem:
	log_err(errno, __func__, "out of memory");
	exit(1);
}

/**
 * @brief
 * 	This cleans up when MOM is restarted.
 *
 * @return	Void
 *
 */
void
dep_cleanup()
{
	int	i;

	close(kd);
	kd = -1;

	if (proc_tbl) {
		free(proc_tbl);
		proc_tbl = NULL;
	}

	if (swap_dev) {
		for (i=0; swap_dev[i]; i++) {
			free(swap_dev[i]);
			swap_dev[i] = NULL;
		}
	}
}

/**
 * @brief
 *      Don't need any periodic procsessing except in some special cases.
 *
 * @return      Void
 *
 */
void
end_proc()
{
	return;
}

/**
 *Time decoding macro.  Accepts a timeval structure.  Returns unsigned long
 *time in seconds.
 */

#define tv(val) (ulong)((val).tv_sec)

/**
 * @brief
 * 	Check if a session id belongs to a job.
 *
 * @param[in] pjob - job pointer
 * @para[in] sesid - session id
 *
 * @return      Bool
 * @retval      TRUE    Success
 * @retval      FALSE   Error
 *
 */
static int
injob(job *pjob, pid_t sid)
{
	task		*ptask;

	for (ptask = (task *)GET_NEXT(pjob->ji_tasks);
		ptask;
		ptask = (task *)GET_NEXT(ptask->ti_jobtask)) {
		if (ptask->ti_qs.ti_sid <= 1)
			continue;
		if (ptask->ti_qs.ti_sid == sesid)
			return TRUE;
	}
	return FALSE;
}

/**
 * @brief
 *      Internal session cpu time decoding routine.
 *
 * @param[in] job - a job pointer.
 *
 * @return      ulong
 * @retval      sum of all cpu time consumed for all tasks executed by the job, in seconds,
 *              adjusted by cputfactor.
 *
 */
static unsigned long
cput_sum(job *pjob)
{
	char			*id = "cput_ses";
	int			i;
	unsigned long		cputime = 0;
	int			nps = 0;
	int			taskprocs;
	task			*ptask;
	ulong			tcput;

	for (ptask = (task *)GET_NEXT(pjob->ji_tasks);
		ptask != NULL;
		ptask = (task *)GET_NEXT(ptask->ti_jobtask)) {

		/* DEAD task */
		if (ptask->ti_qs.ti_sid <= 1) {
			cputime += ptask->ti_cput;
			continue;
		}

		tcput = 0;
		taskprocs = 0;
		for (i=0; i<nproc; i++) {
			struct procsinfo	*pp = &proc_tbl[i];

			if (pp->pi_state == SNONE)
				continue;

			/* is this process part of the task? */
			if (ptask->ti_qs.ti_sid != pp->pi_sid)
				continue;

			nps++;
			taskprocs++;
			DBPRT(("%s: pid=%d task=%u", id, pp->pi_pid,
				ptask->ti_qs.ti_task))
			if (pp->pi_state == SZOMB) {
				/* get zombie time only if top process in job */
				if ((pp->pi_sid == pp->pi_pid) ||
					(pp->pi_ppid == mom_pid)) {
					DBPRT((" (zombie)"))
					tcput += (pp->pi_utime + pp->pi_stime);
				}
			} else {
				DBPRT((" (active)"))
				tcput += tv(pp->pi_ru.ru_utime) +
					tv(pp->pi_ru.ru_stime) +
				tv(pp->pi_cru.ru_utime) +
				tv(pp->pi_cru.ru_stime);
			}
			DBPRT((" sum=%lu\n", tcput))
		}
		if (tcput > ptask->ti_cput)
			ptask->ti_cput = tcput;
		cputime += ptask->ti_cput;
		DBPRT(("%s: task %08.8X cput %u jobsum %lu\n", id,
			ptask->ti_qs.ti_task, ptask->ti_cput, cputime))

		if (taskprocs == 0) {
			sprintf(log_buffer,
				"no active process for task %8.8X",
				ptask->ti_qs.ti_task);
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB,
				LOG_INFO, pjob->ji_qs.ji_jobid,
				log_buffer);
			ptask->ti_qs.ti_status = TI_STATE_EXITED;
			task_save(ptask);
			exiting_tasks = 1;
		}
	}

	if (nps == 0)
		pjob->ji_flags |= MOM_NO_PROC;

	return ((unsigned long)((double)cputime * cputfactor));
}

/**
 * @brief
 *      Internal session memory usage function.
 *
 * @param[in] job - job pointer
 *
 * @return      rlim64_t
 * @retval      the total number of bytes of address
 *              space consumed by all current processes within the job.
 *
 */
static rlim64_t
mem_sum(job *pjob)
{
	char		*id="mem_ses";
	int		i;
	rlim64_t	memsize;

	memsize = 0;
	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (!injob(pjob, pp->pi_sid))
			continue;

		memsize += pp->pi_size;
		DBPRT(("%s: pid=%d size=%lu\n", id, pp->pi_pid,
			memsize * page_size))
	}

	return (memsize * (rlim64_t)page_size);
}

/**
 * @brief
 *      Internal session workingset size function.
 *
 * @param[in] pjob - job pointer
 *
 * @return      rlim64_t
 * @retval      new resident set size   Success
 * @retval      old resident set size   Error
 *
 */
static rlim64_t
resi_sum(job *pjob)
{
	char		*id="resi_ses";
	int		i;
	rlim64_t	memsize;

	memsize = 0;
	for (i=0; i<nproc; i++) {
		struct	procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (!injob(pjob, pp->pi_sid))
			continue;

		if (pp->pi_state == SZOMB)
			continue;

		memsize += (pp->pi_drss == -1) ? 0 : pp->pi_drss;
		memsize += (pp->pi_trss == -1) ? 0 : pp->pi_trss;
		DBPRT(("%s: pid=%d size=%lu\n", id, pp->pi_pid,
			memsize*page_size))
	}

	return (memsize * (rlim64_t)page_size);
}

/**
 * @brief
 *      Establish system-enforced limits for the job.
 *
 *      Run through the resource list, checking the values for all items
 *      we recognize.
 *
 * @param[in] pjob - job pointer
 * @param[in]  set_mode - setting mode   SET_LIMIT_SET or SET_LIMIT_ALTER 
 *
 *      If set_mode is SET_LIMIT_SET, then also set hard limits for the
 *                        system enforced limits (not-polled).
 *      If anything goes wrong with the process, return a PBS error code
 *      and print a message on standard error.  A zero-length resource list
 *      is not an error.
 *
 *      If set_mode is SET_LIMIT_SET the entry conditions are:
 *          1.  MOM has already forked, and we are called from the child.
 *          2.  The child is still running as root.
 *          3.  Standard error is open to the user's file.
 *
 *      If set_mode is SET_LIMIT_ALTER, we are beening called to modify
 *      existing limits.  Cannot alter those set by setrlimit (kernel)
 *      because we are the wrong process.
 *
 * @return      int
 * @retval      PBSE_NONE       Success
 * @retval      PBSE_*          Error
 *
 */
int
mom_set_limits(job *pjob, int set_mode)
{
	char		*pname;
	int		retval;
	unsigned long	value;	/* place in which to build resource value */
	rlim64_t	valsize;
	resource	*pres;
	struct rlimit64	reslim;
	rlim64_t	mem_limit  = 0;
	rlim64_t	vmem_limit  = 0;
	rlim64_t	cpu_limit  = 0;

	DBPRT(("%s: entered\n", __func__))
	assert(pjob != NULL);
	assert(pjob->ji_wattr[(int)JOB_ATR_resource].at_type == ATR_TYPE_RESC);
	pres = (resource *)
		GET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);

	/*
	 * Cycle through all the resource specifications,
	 * setting limits appropriately.
	 */

	/* mem and vmem limits come from the local node limits, not the job */
	mem_limit  = pjob->ji_hosts[pjob->ji_nodeid].hn_nrlimit.rl_mem << 10;
	vmem_limit = pjob->ji_hosts[pjob->ji_nodeid].hn_nrlimit.rl_vmem << 10;

	while (pres != NULL) {
		assert(pres->rs_defin != NULL);
		pname = pres->rs_defin->rs_name;
		assert(pname != NULL);
		assert(*pname != '\0');

		if (strcmp(pname, "cput") == 0 ||
			strcmp(pname, "pcput") == 0) {		/* set */
			retval = local_gettime(pres, &value);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
			if ((cpu_limit == 0) || (value < cpu_limit))
				cpu_limit = value;
		} else if (strcmp(pname, "pvmem") == 0) {	/* set */
			retval = local_getsize(pres, &valsize);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
			if ((vmem_limit == 0) || (valsize < vmem_limit))
				vmem_limit = valsize;
		} else if (strcmp(pname, "pmem") == 0) {	/* set */
			retval = local_getsize(pres, &valsize);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
			if ((mem_limit == 0) || (valsize < mem_limit))
				mem_limit = valsize;
		} else if (strcmp(pname, "file") == 0) {	/* set */
			if (set_mode == SET_LIMIT_SET) {
				retval = local_getsize(pres, &valsize);
				if (retval != PBSE_NONE)
					return (error(pname, retval));
				reslim.rlim_cur = reslim.rlim_max = valsize;
				if (setrlimit64(RLIMIT_FSIZE, &reslim) < 0)
					return (error(pname, PBSE_SYSTEM));
			}
		} else if (strcmp(pname, "walltime") == 0) {	/* Check */
			retval = local_gettime(pres, &value);
			if (retval != PBSE_NONE)
				return (error(pname, retval));
		} else if (strcmp(pname, "nice") == 0) {	/* set nice */
			if (set_mode == SET_LIMIT_SET) {
				errno = 0;
				if ((nice((int)pres->rs_value.at_val.at_long) == -1)
					&& (errno != 0))
					return (error(pname, PBSE_BADATVAL));
			}
		}
		pres = (resource *)GET_NEXT(pres->rs_link);
	}

	if (set_mode == SET_LIMIT_SET) {

		/* if either vmem or pvmem was given, set sys limit to lesser */
		if (vmem_limit != 0) {
			reslim.rlim_cur = reslim.rlim_max = vmem_limit;
			if (setrlimit64(RLIMIT_DATA, &reslim) < 0)
				return (error("RLIMIT_DATA", PBSE_SYSTEM));
			if (setrlimit64(RLIMIT_STACK, &reslim) < 0)
				return (error("RLIMIT_STACK", PBSE_SYSTEM));
		}

		/* if either mem or pmem was given, set sys limit to lesser */
		if (mem_limit != 0) {
			reslim.rlim_cur = reslim.rlim_max = mem_limit;
			if (setrlimit64(RLIMIT_RSS, &reslim) < 0)
				return (error("RLIMIT_RSS", PBSE_SYSTEM));
		}

		/* if either cput or pcput was given, set sys limit to lesser */
		if (cpu_limit != 0) {
			reslim.rlim_cur = reslim.rlim_max =
				(rlim64_t)((double)cpu_limit / cputfactor);
			if (setrlimit64(RLIMIT_CPU, &reslim) < 0)
				return (error("RLIMIT_CPU", PBSE_SYSTEM));
		}
	}

	return (PBSE_NONE);
}

/**
 * @brief
 *      State whether MOM main loop has to poll this job to determine if some
 *      limits are being exceeded.
 *
 * @param[in] pjob - job pointer
 *
 * @return      int
 * @retval      TRUE    if polling is necessary
 * @retval      FALSE   otherwise.
 *
 * NOTE: Actual polling is done using the mom_over_limit machine-dependent function.
 *
 */
int
mom_do_poll(job *pjob)
{
	char		*pname;
	resource	*pres;

	DBPRT(("%s: entered\n", __func__))
	assert(pjob != NULL);
	assert(pjob->ji_wattr[(int)JOB_ATR_resource].at_type == ATR_TYPE_RESC);
	pres = (resource *)
		GET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);

	while (pres != NULL) {
		assert(pres->rs_defin != NULL);
		pname = pres->rs_defin->rs_name;
		assert(pname != NULL);
		assert(*pname != '\0');

		if (strcmp(pname, "walltime") == 0 ||
			strcmp(pname, "cput") == 0 ||
			strcmp(pname, "mem")  == 0 ||
			strcmp(pname, "vmem") == 0 ||
			strcmp(pname, "ncpus") == 0)
			return (TRUE);
		pres = (resource *)GET_NEXT(pres->rs_link);
	}

	return (FALSE);
}

/**
 * @brief
 *      Setup for polling.
 *
 * @return      int
 * @retval      PBSE_NONE               Success
 * @retval      PBSE_SYSTEM             Error
 *
 */
int
mom_open_poll()
{
	DBPRT(("%s: entered\n", __func__))

	proc_tbl = malloc(ASIZE*sizeof(struct procsinfo));
	if (proc_tbl == NULL) {
		log_err(errno, __func__, "out of memory");
		exit(1);
	}
	proctot = ASIZE;

	return (PBSE_NONE);
}

/**
 * @brief
 *      Declare start of polling loop.
 *
 * @return      int
 * @retval      PBSE_INTERNAL   Dir pdir in NULL
 * @retval      PBSE_NONE       Success
 *
 */
int
mom_get_sample()
{
	int		num;
	pid_t		pid;
	extern time_t time_last_sample;

	time_last_sample = time_now;
	sampletime_floor = time_last_sample;

	DBPRT(("%s: entered\n", __func__))

	nproc = 0;
	pid = 0;

	while ((num = getprocs(proc_tbl, sizeof(struct procsinfo),
		NULL, sizeof(struct fdsinfo),
		&pid, proctot)) > 0) {
		DBPRT(("%s: loop start: got %d\n", __func__, num))

		nproc = num;
		if (num < proctot)
			break;

		proctot = num + ASIZE;
		proc_tbl = realloc(proc_tbl, proctot*sizeof(struct procsinfo));
		assert(proc_tbl != NULL);
		pid = 0;
	}
	if (num == -1) {
		log_err(errno, __func__, "getprocs");
		return PBSE_SYSTEM;
	}
	DBPRT(("%s: nproc = %d\n", __func__, nproc))

	sampletime_ceil = time(0);
	return (PBSE_NONE);
}

/**
 * @brief
 *      Update the resources used.<attributes> of a job.
 *
 * @param[in]   pjob - job in question.
 *
 * @note
 *      The first time this is called for a job, set up resource entries for
 *      each resource that can be reported for this machine.  Fill in the
 *      correct values.
 *      If a resource attribute has been set in a mom hook, then its value
 *      will not be updated here. This allows a mom  hook to override
 *      resource value.
 *
 * @return int
 * @retval PBSE_NONE    for success.
 */
int
mom_set_use(job *pjob)
{
	resource		*pres;
	resource		*pres_req;
	attribute		*at;
	attribute		*at_req;
	resource_def		*rd;
	u_Long			*lp_sz, lnum_sz;
	unsigned long		*lp, lnum, oldcput;
	long                     ncpus_req;

	assert(pjob != NULL);
	at = &pjob->ji_wattr[(int)JOB_ATR_resc_used];
	assert(at->at_type == ATR_TYPE_RESC);

	if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_Suspend) != 0)
		return (PBSE_NONE);	/* job suspended, don't track it */

	DBPRT(("%s: entered\n", __func__))
	at->at_flags |= (ATR_VFLAG_MODIFY|ATR_VFLAG_SET);

	rd = find_resc_def(svr_resc_def, "ncpus", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	if (pres == NULL) {
		pres = add_resource_entry(at, rd);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_LONG;
		/*
		 * get pointer to list of resources *requested* for the job
		 * so the ncpus used can be set to ncpus requested
		 */
		at_req = &pjob->ji_wattr[(int)JOB_ATR_resource];
		assert(at->at_type == ATR_TYPE_RESC);

		pres_req = find_resc_entry(at_req, rd);
		if ((pres_req != NULL) &&
			((ncpus_req=pres_req->rs_value.at_val.at_long) !=0))
				pres->rs_value.at_val.at_long = ncpus_req;
		else
			pres->rs_value.at_val.at_long = 0;
	}

	rd = find_resc_def(svr_resc_def, "cput", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	if (pres == NULL) {
		pres = add_resource_entry(at, rd);
		assert(pres != NULL);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_LONG;
		pres->rs_value.at_val.at_long = 0;
	}
	lp = (unsigned long *)&pres->rs_value.at_val.at_long;
	oldcput = *lp;
	lnum = cput_sum(pjob);
	lnum = MAX(*lp, lnum);
	if ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {
		*lp = lnum;
	}

	rd = find_resc_def(svr_resc_def, "cpupercent", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	if (pres == NULL) {
		pres = add_resource_entry(at, rd);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_LONG;
		pres->rs_value.at_val.at_long = 0;
	}
	if ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {
		/* now calculate weighted moving average cpu usage */
		/* percentage */
		calc_cpupercent(pjob, oldcput, lnum, sampletime_ceil);
	}
	pjob->ji_sampletim = sampletime_floor;

	rd = find_resc_def(svr_resc_def, "vmem", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	if (pres == NULL) {
		pres = add_resource_entry(at, rd);
		assert(pres != NULL);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_SIZE;
		pres->rs_value.at_val.at_size.atsv_shift = 10; /* KB */
		pres->rs_value.at_val.at_size.atsv_units = ATR_SV_BYTESZ;
		pres->rs_value.at_val.at_size.atsv_num = 0;
	} else if ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {
		lp_sz = &pres->rs_value.at_val.at_size.atsv_num;
		lnum_sz = (mem_sum(pjob) + 1023) >> 10;	/* as KB */
		*lp_sz = MAX(*lp_sz, lnum_sz);
	}

	rd = find_resc_def(svr_resc_def, "walltime", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	if (pres == NULL) {
		pres = add_resource_entry(at, rd);
		assert(pres != NULL);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_LONG;
		pres->rs_value.at_val.at_long = 0;
	} else if ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {
		pres->rs_value.at_val.at_long =
			(long)((double)(time_now - pjob->ji_qs.ji_stime) * wallfactor);
	}

	rd = find_resc_def(svr_resc_def, "mem", svr_resc_size);
	assert(rd != NULL);
	pres = find_resc_entry(at, rd);
	if (pres == NULL) {
		pres = add_resource_entry(at, rd);
		assert(pres != NULL);
		pres->rs_value.at_flags |= ATR_VFLAG_SET;
		pres->rs_value.at_type = ATR_TYPE_SIZE;
		pres->rs_value.at_val.at_size.atsv_shift = 10; /* KB */
		pres->rs_value.at_val.at_size.atsv_units = ATR_SV_BYTESZ;
		pres->rs_value.at_val.at_size.atsv_num = 0;
	} else if ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {
		lp_sz = &pres->rs_value.at_val.at_size.atsv_num;
		lnum_sz = (resi_sum(pjob) + 1023) >> 10; /* as KB */
		*lp_sz = MAX(*lp_sz, lnum_sz);
	}

	return (PBSE_NONE);
}

/**
 * @brief
 *      bld_ptree - establish links (parent, child, and sibling) for processes
 *      in a given session.
 *
 *      The PBS_PROC_* macros are defined in resmom/.../mom_mach.h
 *      to refer to the correct machine dependent table.
 *      Linkage scope changed from static to default as this gets referred
 *      from scan_for_terminated(), declaration added in the mom_mach.h.
 *
 * @param[in] sid - session id
 *
 * @return      int
 * @retval      number of processes in session  Success
 *
 */
int
bld_ptree(pid_t sid)
{

	int	myproc_ct;	/* count of processes in a session */
	int	i, j;

	if (Proc_lnks == NULL) {
		Proc_lnks = (pbs_plinks *)malloc(TBL_INC * sizeof(pbs_plinks));
		assert(Proc_lnks != NULL);
		myproc_max = TBL_INC;
	}

	/*
	 * Build links for processes in the session in question.
	 * First, load with the processes in the session.
	 */

	myproc_ct = 0;
	for (i = 0; i < nproc; i++) {
		if (PBS_PROC_PID(i) <= 1)
			continue;
		if ((int)PBS_PROC_SID(i) == sid) {
			Proc_lnks[myproc_ct].pl_pid    = PBS_PROC_PID(i);
			Proc_lnks[myproc_ct].pl_ppid   = PBS_PROC_PPID(i);
			Proc_lnks[myproc_ct].pl_parent = -1;
			Proc_lnks[myproc_ct].pl_sib    = -1;
			Proc_lnks[myproc_ct].pl_child  = -1;
			Proc_lnks[myproc_ct].pl_done   = 0;
			if (++myproc_ct == myproc_max) {
				void * hold;

				myproc_max += TBL_INC;
				hold = realloc((void *)Proc_lnks,
					myproc_max*sizeof(pbs_plinks));
				assert(hold != NULL);
				Proc_lnks = (pbs_plinks *)hold;
			}
		}
	}

	/* Now build the tree for those processes */

	for (i = 0; i < myproc_ct; i++) {
		/*
		 * Find all the children for this process, establish links.
		 */
		for (j = 0; j < myproc_ct; j++) {
			if (j == i)
				continue;
			if (Proc_lnks[j].pl_ppid == Proc_lnks[i].pl_pid) {
				Proc_lnks[j].pl_parent = i;
				Proc_lnks[j].pl_sib = Proc_lnks[i].pl_child;
				Proc_lnks[i].pl_child = j;
			}
		}
	}
	return (myproc_ct);	/* number of processes in session */
}

/**
 * @brief
 *      kill_ptree - traverse the process tree, killing the processes as we go
 *
 * @param[in]   idx:    current pid index
 * @param[in]   flag:   traverse order, top down (1) or bottom up (0)
 * @param[in]   sig:    the signal to send
 *
 * @return      Void
 *
 */
static void
kill_ptree(int idx, int flag, int sig)
{
	int		 child;

	if (flag && !Proc_lnks[idx].pl_done) {		/* top down */
		(void)kill(Proc_lnks[idx].pl_pid, sig);
		Proc_lnks[idx].pl_done = 1;
	}
	child = Proc_lnks[idx].pl_child;
	while (child != -1) {
		kill_ptree(child, flag, sig);
		child = Proc_lnks[child].pl_sib;
	}
	if (!flag && !Proc_lnks[idx].pl_done) {		/* bottom up */
		(void)kill(Proc_lnks[idx].pl_pid, sig);
		Proc_lnks[idx].pl_done = 1;
	}
}

/**
 * @brief
 *      kill task session
 *
 * @param[in] ptask - pointer to pbs_task structure
 * @param[in] sig - signal number
 * @param[in] dir - indication how to kill
 *                  0 - kill child first
 *                  1 - kill parent first
 *
 * @return      int
 * @retval      number of tasks
 *
 */
int
kill_task(pbs_task *ptask, int sig, int dir)
{
	return kill_session(ptask->ti_qs.ti_sid, sig, dir);
}

/**
 * @brief
 *      Kill a task session.
 *      Call with the task pointer and a signal number.
 *
 * @param[in] sesid - session id
 * @param[in] sig - signal number
 * @param[in] dir - indication how to kill
 *                  0 - kill child first
 *                  1 - kill parent first
 *
 * @return      int
 * @retval      number of tasks
 *
 */
int
kill_session(pid_t sesid, int sig, int dir)
{
	int		ct = 0;
	int		i;

	DBPRT(("%s: entered sid %d\n", __func__, sesid))
	if (sesid <= 1)
		return 0;

	(void)mom_get_sample();
	ct = bld_ptree(sesid);
	DBPRT(("%s: bld_ptree %d\n", __func__, ct))

	/*
	 ** Find index into the Proc_lnks table for the session lead.
	 */
	for (i = 0; i < ct; i++) {
		if (Proc_lnks[i].pl_pid == sesid) {
			kill_ptree(i, dir, sig);
			break;
		}
	}
	/*
	 ** Do a linear pass.
	 */
	for (i = 0; i < ct; i++) {
		if (Proc_lnks[i].pl_done)
			continue;
		DBPRT(("%s: cleanup %d\n", __func__, Proc_lnks[i].pl_pid))
		kill(Proc_lnks[i].pl_pid, sig);
	}

	return ct;
}

/**
 * @brief
 *      Clean up everything related to polling.
 *
 * @return      int
 * @retval      PBSE_NONE       Success
 * @retval      PBSE_SYSTEM     Error
 *
 */
int
mom_close_poll()
{
	DBPRT(("mom_close_poll entered\n"))

	if (proc_tbl) {
		free(proc_tbl);
		proc_tbl = NULL;
	}

	return (PBSE_NONE);
}

/**
 * @brief
 *      Checkpoint the job.
 *
 * @param[in] ptask - pointer to task
 * @param[in] file - filename
 * @param[in] abort - value indicating abort
 *
 * If abort is true, kill it too.
 *
 * @return      int
 * @retval      -1
 */
int
mach_checkpoint(task *ptask, char *file, int abort)
{
	return (-1);
}

/**
 * @brief
 *      Restart the job from the checkpoint file.
 *
 * @param[in] ptask - pointer to task
 * @param[in] file - filename
 *
 * @return      long
 * @retval      session id      Success
 * @retval      -1              Error
 */
long
mach_restart(task *ptask, char *file)
{
	return (-1);
}

int
kvm_read(int fd, long addr, char buf, int size)
{
	int	ret;

	if (lseek(fd, addr, SEEK_SET) != addr)
		return -1;
	if ((ret = read(fd, buf, size)) == -1)
		return -1;
	return ret;
}

int
getproctab()
{
	static	uint	lastproc = 0;

	if (lastproc == reqnum)		/* don't need new proc table */
		return nproc;

	if (mom_get_sample() != PBSE_NONE)
		return 0;

	lastproc = reqnum;
	return (nproc);
}

double
dsecs(val)
struct	timeval	*val;
{
	return ((double)val->tv_sec + (double)val->tv_usec*1e-6);
}

/**
 * @brief
 *      computes and returns the cpu time process with  pid jobid
 *
 * @param[in] jobid - process id for job
 *
 * @return      string
 * @retval      cputime         Success
 * @retval      NULL            Error
 *
 */
char *
cput_job(pid_t jobid)
{
	int		i, nproc;
	int		found = 0;
	double		cputime, addtime;

	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	cputime = 0;
	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (jobid != pp->pi_sid)
			continue;

		found = 1;
		DBPRT(("%s: pid=%d", __func__, pp->pi_pid))
		if (pp->pi_state == SZOMB) {
			DBPRT((" (zombie)"))
			addtime = dsecs(&pp->pi_utime) +
				dsecs(&pp->pi_stime);
		}
		else {
			DBPRT((" (active)"))
			addtime = dsecs(&pp->pi_ru.ru_utime) +
				dsecs(&pp->pi_ru.ru_stime) +
			dsecs(&pp->pi_cru.ru_utime) +
			dsecs(&pp->pi_cru.ru_stime);
		}
		cputime += addtime;
		DBPRT((" %.2f total=%.2f\n", addtime, cputime))

	}
	if (found) {
		sprintf(ret_string, "%.2f", cputime * cputfactor);
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      computes and returns the cpu time process with  pid pid.
 *
 * @param[in] pid - process id
 *
 * @return      string
 * @retval      cputime         Success
 * @retval      NULL            Error
 *
 */
char *
cput_proc(pid_t pid)
{
	int			i, nproc;
	int			found = 0;
	double			cputime;

	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (pid != pp->pi_pid)
			continue;

		DBPRT(("%s: pid=%d", __func__, pp->pi_pid))
		if (pp->pi_state == SZOMB) {
			DBPRT((" (zombie)"))
			cputime = dsecs(&pp->pi_utime) +
				dsecs(&pp->pi_stime);
		}
		else {
			DBPRT((" (active)"))
			cputime = dsecs(&pp->pi_ru.ru_utime) +
				dsecs(&pp->pi_ru.ru_stime) +
			dsecs(&pp->pi_cru.ru_utime) +
			dsecs(&pp->pi_cru.ru_stime);
		}
		DBPRT((" %.2f\n", cputime))
		found = 1;
		break;
	}
	if (found) {
		sprintf(ret_string, "%.2f", cputime * cputfactor);
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      wrapper function for cput_proc and cput_job.
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      cputime         Success
 * @retval      NULL            ERRor
 *
 */
char *
cput(struct rm_attribute *attrib)
{
	int			value;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((value = atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "session") == 0)
		return (cput_job((pid_t)value));
	else if (strcmp(attrib->a_qualifier, "proc") == 0)
		return (cput_proc((pid_t)value));
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
}

/**
 * @brief
 *      computes and returns the memory for session with  pid sid..
 *
 * @param[in] sid - process id
 *
 * @return      string
 * @retval      memsize         Success
 * @retval      NULL            Error
 *
 */
char *
mem_job(pid_t jobid)
{
	int			i, nproc;
	int			memsize;
	int			found = 0;

	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	memsize = 0;
	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (jobid != pp->pi_sid)
			continue;

		found = 1;
		memsize += pp->pi_size;
		DBPRT(("%s: pid %d memsize %d pi_size %d\n", __func__, pp->pi_pid,
			memsize, pp->pi_size))
	}
	if (found) {
		sprintf(ret_string, "%ukb", ctob(memsize) >> 10); /* KB */
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      computes and returns the memory for process with  pid sid..
 *
 * @param[in] pid - process id
 *
 * @return      string
 * @retval      memsize         Success
 * @retval      NULL            Error
 *
 */
char *
mem_proc(pid_t pid)
{
	int			i, nproc;
	int			memsize;
	int			found = 0;

	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	memsize = 0;
	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (pid != pp->pi_pid)
			continue;

		found = 1;
		memsize = pp->pi_size;
		break;
	}
	if (found) {
		sprintf(ret_string, "%ukb", ctob(memsize) >> 10); /* KB */
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      wrapper function for mem_job and mem_proc..
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      memsize         Success
 * @retval      NULL            ERRor
 *
 */
char *
mem(struct rm_attribute *attrib)
{
	int			value;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((value = atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "session") == 0)
		return (mem_job((pid_t)value));
	else if (strcmp(attrib->a_qualifier, "proc") == 0)
		return (mem_proc((pid_t)value));
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
}

/**
 * @brief
 *      return the number of cpus
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      number of cpus  Success
 * @retval      NULL            Error
 *
 */
static char *
ncpus(struct rm_attribute *attrib)
{
	if (attrib) {
		log_err(-1, "ncpus", extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	sprintf(ret_string, "%d", num_acpus);
	return ret_string;
}

/**
 * @brief
 *      computes and returns resident set size for job
 *
 * @param[in] jobid - pid for job
 *
 * @return      string
 * @retval      resident set size       Success
 * @retval      NULL                    Error
 *
 */
static char *
resi_job(pid_t jobid)
{
	int			i, nproc;
	int			resisize;
	int			found = 0;

	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	resisize = 0;
	for (i=0; i<nproc; i++) {
		struct	procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (jobid)
			continue;

		found = 1;
		if (pp->pi_state == SZOMB)
			continue;

		resisize += pp->pi_drss + pp->pi_trss;
		DBPRT(("%s: pid=%d size=%d\n", __func__, pp->pi_pid, resisize))
	}
	if (found) {
		sprintf(ret_string, "%ukb", ctob(resisize) >> 10);  /* KB */
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      computes and returns resident set size for process
 *
 * @param[in] pid - process id
 *
 * @return      string
 * @retval      resident set size       Success
 * @retval      NULL                    Error
 *
 */
static char *
resi_proc(pid_t pid)
{
	int			i, nproc;
	int			resisize;
	int			found = 0;

	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	resisize = 0;
	for (i=0; i<nproc; i++) {
		struct	procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (pid != pp->pi_pid)
			continue;

		found = 1;
		if (pp->pi_state == SZOMB)
			break;

		resisize = pp->pi_drss + pp->pi_trss;
		DBPRT(("%s: pid=%d size=%d\n", __func__, pp->pi_pid, resisize))
		break;
	}
	if (found) {
		sprintf(ret_string, "%ukb", ctob(resisize) >> 10); /* KB */
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      wrapper function for mem_job and mem_proc..
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      resident set size       Success
 * @retval      NULL                    ERRor
 *
 */
static char *
resi(struct rm_attribute *attrib)
{
	int			value;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((value = atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "session") == 0)
		return (resi_job((pid_t)value));
	else if (strcmp(attrib->a_qualifier, "proc") == 0)
		return (resi_proc((pid_t)value));
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
}

/**
 * @brief
 *      returns the number of sessions
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      sessions        Success
 * @retval      NULL            error
 *
 */
char *
sessions(struct rm_attribute *attrib)
{
	int			nproc;
	int			i, j;
	char			*fmt;
	int			njids = 0;
	pid_t			*jids, jobid;

	if (attrib) {
		log_err(-1, id, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	if ((jids = calloc(nproc, sizeof(pid_t))) == NULL) {
		log_err(errno, __func__, "no memory");
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}

	/*
	 ** Search for session
	 */
	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];
		if (pp->pi_state == SNONE)
			continue;
		if (pp->pi_suid == 0)
			continue;

		jobid = pp->pi_sid;
		if (jobid == 0)
			continue;

		DBPRT(("%s: pid %d sid %u\n", __func__, pp->pi_pid, jobid))
		for (j=0; j<njids; j++) {
			if (jids[j] == jobid)
				break;
		}
		if (j == njids)			/* not found */
			jids[njids++] = jobid;	/* so add it to list */
	}

	fmt = ret_string;
	for (j=0; j<njids; j++) {
		checkret(&fmt, 100);
		sprintf(fmt, " %d", jids[j]);
		fmt += strlen(fmt);
	}
	free(jids);
	return ret_string;
}

/**
 * @brief
 *      wrapper function for sessions().
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      sessions        Success
 * @retval      0               error
 *
 */
char *
nsessions(struct rm_attribute *attrib)
{
	char	*result, *ch;
	int	num = 0;

	if ((result = sessions(attrib)) == NULL)
		return result;

	for (ch=result; *ch; ch++) {
		if (*ch == ' ')		/* count blanks */
			num++;
	}
	sprintf(ret_string, "%d", num);
	return ret_string;
}

/**
 * @brief
 *      returns the number of processes in session
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      process        Success
 * @retval      NULL            error
 *
 */
char *
pids(struct rm_attribute *attrib)
{
	pid_t			jobid;
	int			nproc;
	int			i;
	char			*fmt;
	int			num_pids = 0;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((jobid = (pid_t)atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "session") != 0) {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}

	/*
	 ** Search for members of session
	 */
	fmt = ret_string;
	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (jobid != pp->pi_sid)
			continue;

		checkret(&fmt, 100);
		sprintf(fmt, " %d", pp->pi_pid);
		fmt += strlen(fmt);
		num_pids++;

		DBPRT(("%s[%d]: pid %d sid %u\n",
			__func__, num_pids, pp->pi_pid, pp->pi_sid))
	}
	if (num_pids == 0) {
		rm_errno = RM_ERR_EXIST;
		return NULL;
	}
	return ret_string;
}

/**
 * @brief
 *      returns all the process ids
 *
 * @return      pid_t
 * @retval      pids    Success
 * @retval      NULl    Error
 *
 */
pid_t	*
allpids(void)
{
	int			 i;
	static	pid_t		*pids = NULL;

	if ((nproc = getproctab()) == 0)
		return NULL;

	if (pids != NULL)
		free(pids);
	if ((pids = (pid_t *)calloc(nproc+1, sizeof(pid_t))) == NULL) {
		log_err(errno, __func__, "no memory");
		return NULL;
	}

	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		pids[i] = pp->pi_pid;	/* add pid to list */
	}
	pids[nproc] = -1;
	return pids;
}

/**
 * @brief
 *      returns the number of users
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      users        Success
 * @retval      NULL            error
 *
 */
char *
nusers(struct rm_attribute *attrib)
{
	int			nproc;
	int			i, j;
	int			nuids = 0;
	uid_t			*uids, uid;

	if (attrib) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	if ((uids = calloc(nproc, sizeof(uid_t))) == NULL) {
		log_err(errno, __func__, "no memory");
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}

	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;
		if ((uid = pp->pi_suid) == 0)
			continue;

		DBPRT(("%s: pid %d uid %u\n", __func__, pp->pi_pid, uid))
		for (j=0; j<nuids; j++) {
			if (uids[j] == uid)
				break;
		}
		if (j == nuids)			/* not found */
			uids[nuids++] = uid;	/* so add it to list */
	}

	sprintf(ret_string, "%d", nuids);
	free(uids);
	return ret_string;
}

uint	swap_free;
uint	swap_size;

int
getswap(char *id)
{
	static	unsigned	int	lastai = 0;
	int	i;
	struct	pginfo	pginfo;

	if (lastai == reqnum)	/* already have anoninfo */
		return 0;

	swap_free = swap_size = 0;
	for (i=0; swap_dev[i]; i++) {
		if (swapqry(swap_dev[i], &pginfo) == -1) {
			log_err(errno, id, swap_dev[i]);
			continue;
		}
		swap_free += pginfo.free;
		swap_size += pginfo.size;
	}

	lastai = reqnum;
	return 0;
}

/**
 * @brief
 *      returns total process memory
 *
 * @return      pid_t
 * @retval      tot process memory      Success
 * @retval      NULl                    Error
 *
 */

static char *
totmem(struct rm_attribute *attrib)
{
	if (attrib) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (getswap(__func__))
		return NULL;

	sprintf(ret_string, "%lukb", (swap_size * page_size) >> 10); /* KB */
	return ret_string;
}

/**
 * @brief
 *      returns available process memory
 *
 * @return      pid_t
 * @retval      avbl process memory             Success
 * @retval      NULl                            Error
 *
 */
static char *
availmem(struct rm_attribute *attrib)
{
	if (attrib) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (getswap(__func__))
		return NULL;

	sprintf(ret_string, "%lukb", (swap_free * page_size) >> 10); /* KB */
	return ret_string;
}

/**
 * @brief
 *      returns the size of file system present in machine
 *
 * @param[in] param - attribute value(file system)
 *
 * @return      string
 * @retval      size of file system     Success
 * @retval      NULL                    Error
 *
 */
char *
size_fs(char *param)
{
	struct	statfs	fsbuf;

	if (param[0] != '/') {
		sprintf(log_buffer, "%s: not full path filesystem name: %s",
			__func__, param);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (statfs(param, &fsbuf) == -1) {
		log_err(errno, __func__, "statfs");
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	/* in KB */
	sprintf(ret_string, "%lukb",
		(unsigned long)(((double)fsbuf.f_bsize *
		(double)fsbuf.f_bavail) / 1024.0));
	return ret_string;
}

/**
 * @brief
 *      get file attribute from param and put them in buffer.
 *
 * @param[in] param - file attributes
 *
 * @return      string
 * @retval      size of file    Success
 * @retval      NULL            Error
 *
 */
char *
size_file(char *param)
{
	struct	stat	sbuf;

	if (param[0] != '/') {
		sprintf(log_buffer, "%s: not full path filesystem name: %s",
			__func__, param);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (stat(param, &sbuf) == -1) {
		log_err(errno, __func__, "stat");
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	sprintf(ret_string, "%ukb", sbuf.st_size >> 10); /* KB */
	return ret_string;
}

/**
 * @brief
 *      wrapper function for size_file which returns the size of file system
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      size of file system     Success
 * @retval      NULL                    Error
 *
 */
char *
size(struct rm_attribute *attrib)
{
	char	*param;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	param = attrib->a_value;
	if (strcmp(attrib->a_qualifier, "file") == 0)
		return (size_file(param));
	else if (strcmp(attrib->a_qualifier, "fs") == 0)
		return (size_fs(param));
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
}

/**
 * @brief
 *      computes and returns walltime for process or session.
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      walltime        Success
 * @retval      NULL            Error
 *
 */
static char *
walltime(struct rm_attribute *attrib)
{
	pid_t			value;
	int			i, nproc, job, found = 0;
	time_t			now, start;

	if (attrib == NULL) {
		log_err(-1, __func__, no_parm);
		rm_errno = RM_ERR_NOPARAM;
		return NULL;
	}
	if ((value = (pid_t)atoi(attrib->a_value)) == 0) {
		sprintf(log_buffer, "bad param: %s", attrib->a_value);
		log_err(-1, __func__, log_buffer);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	if (momgetattr(NULL)) {
		log_err(-1, __func__, extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if (strcmp(attrib->a_qualifier, "proc") == 0)
		job = 0;
	else if (strcmp(attrib->a_qualifier, "session") == 0)
		job = 1;
	else {
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}

	if ((nproc = getproctab()) == 0) {
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}
	if ((now = time(NULL)) <= 0) {
		log_err(errno, __func__, "time");
		rm_errno = RM_ERR_SYSTEM;
		return NULL;
	}

	start = now;
	for (i=0; i<nproc; i++) {
		struct	procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (job) {
			if (value != pp->pi_sid)
				continue;
		}
		else {
			if (value != pp->pi_pid)
				continue;
		}

		found = 1;
		DBPRT(("%s: pid %d start %d\n", __func__, pp->pi_pid, pp->pi_start))
		start = MIN(start, pp->pi_start);
	}
	if (found) {
		sprintf(ret_string, "%ld",
			(long)((double)(now - start) * wallfactor));
		return ret_string;
	}

	rm_errno = RM_ERR_EXIST;
	return NULL;
}

/**
 * @brief
 *      returns the total physical memory
 *
 * @param[in] attrib - pointer to rm_attribute structure
 *
 * @return      string
 * @retval      tot physical memory     Success
 * @retval      NULL                    Error
 *
 */
char *
physmem(struct rm_attribute *attrib)
{
	if (attrib) {
		log_err(-1, "physmem", extra_parm);
		rm_errno = RM_ERR_BADPARAM;
		return NULL;
	}
	sprintf(ret_string, "%ukb", realmem);
	return (ret_string);
}


#define	FSCALE	(1<<16)

/**
 * @brief
 *      reads load avg from file and returns
 *
 * @param[out] rv - var to hold load avg
 *
 * @return      int
 * @retval      0                       Success
 * @retval      RM_ERR_SYSTEM(15205)    error
 *
 */
int
get_la(double *rv)
{
	long	load;

	if (kd == -1) {
		log_err(-1, __func__, nokernel);
		return (rm_errno = RM_ERR_SYSTEM);
	}
	if (kvm_read(kd, nl[KSYM_LOAD].n_value, (char *)&load,
		sizeof(load)) != sizeof(load)) {
		log_err(errno, __func__, "kvm_read");
		return (rm_errno = RM_ERR_SYSTEM);
	}

	*rv = (double)load/FSCALE;
	return 0;
}

/**
 * @brief
 *      set priority of processes.
 *
 * @return      Void
 *
 */
void
mom_nice()
{
	return;
}

/**
 * @brief
 *      Unset priority of processes.
 *
 * @return      Void
 *
 */
void
mom_unnice()
{
	return;
}

/**
 * @brief
 *      Get the info required for tm_attach.
 *
 * @param[in] pid - process id
 * @param[in] sid - session id
 * @param[in] uid - user id
 * @param[in] comm - command name
 * @param[in] len - size of command
 *
 * @return      int
 * @retval      TM_OKAY                 Success
 * @retval      TM_ENOPROC(17011)       Error
 *
 */
int
dep_procinfo(pid_t pid, pid_t *sid, uid_t *uid, char *comm, size_t len)
{
	int	i;

	if ((nproc = getproctab()) == 0)
		return TM_ESYSTEM;

	for (i=0; i<nproc; i++) {
		register struct procsinfo	*pp = &proc_tbl[i];

		if (pp->pi_state == SNONE)
			continue;

		if (pid == pp->pi_pid) {
			*sid = pp->pi_sid;
			*uid = pp->pi_suid;
			memset(comm, '\0', len);
			memcpy(comm, pp->pi_comm,
				MIN(len-1, sizeof(pp->pi_comm)));
			return TM_OKAY;
		}
	}
	return TM_ENOPROC;
}

/**
 * @brief
 *	No special attach functionality is required.
 *
 * @return	int
 * @retval	TM_OKAY(0)	Success
 *
 */
int
dep_attach(task *ptask)
{
	return TM_OKAY;
}
