/*
 * Copyright (C) 1994-2016 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *  
 * This file is part of the PBS Professional ("PBS Pro") software.
 * 
 * Open Source License Information:
 *  
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free 
 * Software Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *  
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.
 *  
 * You should have received a copy of the GNU Affero General Public License along 
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *  
 * Commercial License Information: 
 * 
 * The PBS Pro software is licensed under the terms of the GNU Affero General 
 * Public License agreement ("AGPL"), except where a separate commercial license 
 * agreement for PBS Pro version 14 or later has been executed in writing with Altair.
 *  
 * Altair’s dual-license business model allows companies, individuals, and 
 * organizations to create proprietary derivative works of PBS Pro and distribute 
 * them - whether embedded or bundled with other software - under a commercial 
 * license agreement.
 * 
 * Use of Altair’s trademarks, including but not limited to "PBS™", 
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's 
 * trademark licensing policies.
 *
 */
/*	int_jcred.c

 send job credentials to the server.

 Note: This code is not mean to be used by a persistent process.
 If an error occurs, not all the allocated structures are freed.
 */

#include <pbs_config.h>   /* the master config generated by configure */

#include <string.h>
#include <stdio.h>
#include <assert.h>
#include "libpbs.h"
#include "dis.h"
#include "ticket.h"
#include "net_connect.h"
#include "rpp.h"


#ifdef	PBS_CRED_GRIDPROXY
#include <gssapi.h>

/**
 * @brief
 *	-encodes a request header in GSS context
 *
 * @param[in] sock - socket descriptor
 * @param[in]   buf - a block of data
 * @param[in]   len - size of buf
 *
 * @return 	int
 * @retval      0 for success
 * @retval      non-zero otherwise.
 */

static int
PBSD_GSS_context(int sock, char *buf, int len)
{
	int			rc;

	if (len == 0)
		return 0;

	if ((rc = encode_DIS_ReqHdr(sock, PBS_BATCH_GSS_Context,
		pbs_current_user)) ||
		(rc = diswcs(sock, buf, (size_t)len)) ||
		(rc = encode_DIS_ReqExtend(sock, (char *)0))) {
		return rc;
	}
	if (DIS_tcp_wflush(sock))
		return DIS_NOCOMMIT;

	return 0;
}

/**
 * @brief
 *	-add major or minor status in gss context
 *
 * @param[in] str - msg
 * @param[in] code - status code
 * @param[in] type - status code type
 *
 * @return	Void
 *
 */
static void
add_status(char **str, OM_uint32 code, int type)
{
	OM_uint32	maj_stat, min_stat;
	gss_buffer_desc	msg = GSS_C_EMPTY_BUFFER;
	OM_uint32	msg_ctx;
	char		*message, *sp, *mp;
	int		len, lastspace;

	msg_ctx = 0;
	for (;;) {
		maj_stat = gss_display_status(&min_stat, code,
			type, GSS_C_NO_OID,
			&msg_ctx, &msg);
		if (maj_stat != GSS_S_COMPLETE)
			message = "error in gss_display_status";
		else
			message = (char *)msg.value;

		len = strlen(*str);
		*str = realloc(*str, len + strlen(message) + 3);
		assert(*str != NULL);

		lastspace = 0;
		sp = (*str) + len;	/* nul char */
		*sp++ = ':';
		*sp++ = ' ';

		for (mp = message; *mp; mp++) {
			if (*mp == ' ') {
				if (lastspace)
					continue;
				lastspace = 1;
				*sp++ = *mp;
				continue;
			}

			if (*mp == '\n') {
				if (lastspace)
					*sp++ = '-';
				else
					*sp++ = '.';
			}
			else
				*sp++ = *mp;
			lastspace = 0;
		}
		*sp = '\0';

		if (maj_stat != GSS_S_COMPLETE)
			break;
		if (msg.length != 0)
			(void)gss_release_buffer(&min_stat, &msg);
		if (!msg_ctx)
			break;
	}
	return;
}

/**
 * @brief
 *	Create a GSS error message in a malloc'ed buffer.
 *
 * @param[in] msg - msg buf holding error msg
 * @param[in] maj - major status
 * @param[in] min - minor status
 *
 * @return	string
 * @retval	err msg	
 *
 */
char *
pbs_gss_error(char *msg, OM_uint32 maj, OM_uint32 min)
{
	char	*buf;

	buf = malloc(strlen(msg) + 1);
	assert(buf != NULL);
	strcpy(buf, msg);
	add_status(&buf, maj, GSS_C_GSS_CODE);
	add_status(&buf, min, GSS_C_MECH_CODE);
	return buf;
}

#endif

/**
 * @brief
 *	 encode a Job Credential Batch Request
 *
 * @param[in] c - socket descriptor
 * @param[in] type - credential type
 * @param[in] buf - credentials
 * @param[in] len - credential length
 * @param[in] rpp - indication for whether to use rpp
 * @param[in] msgid - msg id
 *
 * @return	int
 * @retval	0		success
 * @retval	!0(pbse error)	error
 *
 */
int
PBSD_jcred(int c, int type, char *buf, int len, int rpp, char **msgid)
{
	int			rc;
	struct batch_reply	*reply = NULL;
	int			sock;

	if (!rpp) {
		sock = connection[c].ch_socket;
		DIS_tcp_setup(sock);
	} else {
		sock = c;
		if ((rc = is_compose_cmd(sock, IS_CMD, msgid)) != DIS_SUCCESS)
			return rc;
	}

#ifdef  PBS_CRED_GRIDPROXY
	if (type == PBS_CREDTYPE_GRIDPROXY) {
		OM_uint32		major, minor;
		gss_buffer_desc		input, output;
		/*
		 OM_uint32		flag = GSS_C_CONF_FLAG|GSS_C_DELEG_FLAG;
		 */
		OM_uint32		flag = GSS_C_CONF_FLAG;
		gss_ctx_id_t		context = GSS_C_NO_CONTEXT;
		OM_uint32		life;
		int			ret;

		output.length = 0;
		input.length = 0;

		for (;;) {
			major = gss_init_sec_context(&minor,
				GSS_C_NO_CREDENTIAL, &context,
				GSS_C_NO_NAME, GSS_C_NO_OID, flag, 0,
				GSS_C_NO_CHANNEL_BINDINGS, &input, NULL,
				&output, NULL, NULL);

			if (reply)
				PBSD_FreeReply(reply);

			rc = PBSD_GSS_context(sock, output.value, output.length);
			if (rc) {
				connection[c].ch_errtxt = strdup(dis_emsg[rc]);
				if (connection[c].ch_errtxt == NULL)
					return (pbs_errno = PBSE_SYSTEM);
				return (pbs_errno = PBSE_PROTOCOL);
			}

			if (GSS_ERROR(major)) {
				connection[c].ch_errtxt =
					pbs_gss_error("gss_init_sec_context",
					major, minor);
				return (pbs_errno = PBSE_PROTOCOL);
			}

			reply = PBSD_rdrpy(c);
			if (reply == NULL)
				return (pbs_errno = PBSE_PROTOCOL);
			if (pbs_errno != PBSE_NONE) {
				PBSD_FreeReply(reply);
				return pbs_errno;
			}
			if (reply->brp_choice == BATCH_REPLY_CHOICE_Text) {
				input.length = reply->brp_un.brp_txt.brp_txtlen;
				input.value = reply->brp_un.brp_txt.brp_str;
			}
			else {
				input.length = 0;
				input.value = NULL;
			}
			if (input.length == 0 &&
				(major & GSS_S_CONTINUE_NEEDED) == 0)
				break;
		}
		if (reply)
			PBSD_FreeReply(reply);

		(void)gss_release_buffer(&minor, &output);
		if (major != GSS_S_COMPLETE || context == GSS_C_NO_CONTEXT) {
			connection[c].ch_errtxt =
				strdup("context could not be established");
			if (connection[c].ch_errtxt == NULL)
				return (pbs_errno = PBSE_SYSTEM);
			return (pbs_errno = PBSE_PROTOCOL);
		}

		input.value = buf;
		input.length = len;
		output.length = 0;
		major = gss_seal(&minor, context, 1, GSS_C_QOP_DEFAULT,
			&input, &ret, &output);
		if (major != GSS_S_COMPLETE) {
			connection[c].ch_errtxt =
				pbs_gss_error("gss_seal", major, minor);
			return (pbs_errno = PBSE_PROTOCOL);
		}
		if (ret == 0) {
			connection[c].ch_errtxt =
				strdup("confidentiality not available");
			if (connection[c].ch_errtxt == NULL)
				return (pbs_errno = PBSE_SYSTEM);
			return (pbs_errno = PBSE_PROTOCOL);
		}

		buf = output.value;
		len = output.length;

		output.length = 0;
		major = gss_delete_sec_context(&minor, &context, &output);
		if (major == GSS_S_COMPLETE && output.length > 0) {
			(void)gss_process_context_token(&minor,
				context, &output);
			(void)gss_release_buffer(&minor, &output);
		}
	}
#endif

	if ((rc =encode_DIS_ReqHdr(sock, PBS_BATCH_JobCred, pbs_current_user)) ||
		(rc = encode_DIS_JobCred(sock, type, buf, len)) ||
		(rc = encode_DIS_ReqExtend(sock, (char *)0))) {
		if (!rpp) {
			connection[c].ch_errtxt = strdup(dis_emsg[rc]);
			if (connection[c].ch_errtxt == NULL)
				return (pbs_errno = PBSE_SYSTEM);
		}
		return (pbs_errno = PBSE_PROTOCOL);
	}

	if (rpp) {
		pbs_errno = PBSE_NONE;
		if (rpp_flush(sock))
			pbs_errno = PBSE_PROTOCOL;

		return (pbs_errno);
	}

	if (DIS_tcp_wflush(sock)) {
		return (pbs_errno = PBSE_PROTOCOL);
	}

	reply = PBSD_rdrpy(c);

	PBSD_FreeReply(reply);

	return connection[c].ch_errno;
}

